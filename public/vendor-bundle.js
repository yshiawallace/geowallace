/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/photoswipe/dist/photoswipe.js":
/*!****************************************************!*\
  !*** ./node_modules/photoswipe/dist/photoswipe.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! PhotoSwipe - v4.1.3 - 2019-01-08\n* http://photoswipe.com\n* Copyright (c) 2019 Dmitry Semenov; */\n(function (root, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(this, function () {\n  'use strict';\n\n  var PhotoSwipe = function (template, UiClass, items, options) {\n    /*>>framework-bridge*/\n\n    /**\n     *\n     * Set of generic functions used by gallery.\n     * \n     * You're free to modify anything here as long as functionality is kept.\n     * \n     */\n    var framework = {\n      features: null,\n      bind: function (target, type, listener, unbind) {\n        var methodName = (unbind ? 'remove' : 'add') + 'EventListener';\n        type = type.split(' ');\n\n        for (var i = 0; i < type.length; i++) {\n          if (type[i]) {\n            target[methodName](type[i], listener, false);\n          }\n        }\n      },\n      isArray: function (obj) {\n        return obj instanceof Array;\n      },\n      createEl: function (classes, tag) {\n        var el = document.createElement(tag || 'div');\n\n        if (classes) {\n          el.className = classes;\n        }\n\n        return el;\n      },\n      getScrollY: function () {\n        var yOffset = window.pageYOffset;\n        return yOffset !== undefined ? yOffset : document.documentElement.scrollTop;\n      },\n      unbind: function (target, type, listener) {\n        framework.bind(target, type, listener, true);\n      },\n      removeClass: function (el, className) {\n        var reg = new RegExp('(\\\\s|^)' + className + '(\\\\s|$)');\n        el.className = el.className.replace(reg, ' ').replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n      },\n      addClass: function (el, className) {\n        if (!framework.hasClass(el, className)) {\n          el.className += (el.className ? ' ' : '') + className;\n        }\n      },\n      hasClass: function (el, className) {\n        return el.className && new RegExp('(^|\\\\s)' + className + '(\\\\s|$)').test(el.className);\n      },\n      getChildByClass: function (parentEl, childClassName) {\n        var node = parentEl.firstChild;\n\n        while (node) {\n          if (framework.hasClass(node, childClassName)) {\n            return node;\n          }\n\n          node = node.nextSibling;\n        }\n      },\n      arraySearch: function (array, value, key) {\n        var i = array.length;\n\n        while (i--) {\n          if (array[i][key] === value) {\n            return i;\n          }\n        }\n\n        return -1;\n      },\n      extend: function (o1, o2, preventOverwrite) {\n        for (var prop in o2) {\n          if (o2.hasOwnProperty(prop)) {\n            if (preventOverwrite && o1.hasOwnProperty(prop)) {\n              continue;\n            }\n\n            o1[prop] = o2[prop];\n          }\n        }\n      },\n      easing: {\n        sine: {\n          out: function (k) {\n            return Math.sin(k * (Math.PI / 2));\n          },\n          inOut: function (k) {\n            return -(Math.cos(Math.PI * k) - 1) / 2;\n          }\n        },\n        cubic: {\n          out: function (k) {\n            return --k * k * k + 1;\n          }\n          /*\n          \telastic: {\n          \t\tout: function ( k ) {\n          \t\t\t\tvar s, a = 0.1, p = 0.4;\n          \t\t\tif ( k === 0 ) return 0;\n          \t\t\tif ( k === 1 ) return 1;\n          \t\t\tif ( !a || a < 1 ) { a = 1; s = p / 4; }\n          \t\t\telse s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );\n          \t\t\treturn ( a * Math.pow( 2, - 10 * k) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) + 1 );\n          \t\t\t},\n          \t},\n          \tback: {\n          \t\tout: function ( k ) {\n          \t\t\tvar s = 1.70158;\n          \t\t\treturn --k * k * ( ( s + 1 ) * k + s ) + 1;\n          \t\t}\n          \t}\n          */\n\n        }\n      },\n\n      /**\n       * \n       * @return {object}\n       * \n       * {\n       *  raf : request animation frame function\n       *  caf : cancel animation frame function\n       *  transfrom : transform property key (with vendor), or null if not supported\n       *  oldIE : IE8 or below\n       * }\n       * \n       */\n      detectFeatures: function () {\n        if (framework.features) {\n          return framework.features;\n        }\n\n        var helperEl = framework.createEl(),\n            helperStyle = helperEl.style,\n            vendor = '',\n            features = {}; // IE8 and below\n\n        features.oldIE = document.all && !document.addEventListener;\n        features.touch = 'ontouchstart' in window;\n\n        if (window.requestAnimationFrame) {\n          features.raf = window.requestAnimationFrame;\n          features.caf = window.cancelAnimationFrame;\n        }\n\n        features.pointerEvent = !!window.PointerEvent || navigator.msPointerEnabled; // fix false-positive detection of old Android in new IE\n        // (IE11 ua string contains \"Android 4.0\")\n\n        if (!features.pointerEvent) {\n          var ua = navigator.userAgent; // Detect if device is iPhone or iPod and if it's older than iOS 8\n          // http://stackoverflow.com/a/14223920\n          // \n          // This detection is made because of buggy top/bottom toolbars\n          // that don't trigger window.resize event.\n          // For more info refer to _isFixedPosition variable in core.js\n\n          if (/iP(hone|od)/.test(navigator.platform)) {\n            var v = navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n\n            if (v && v.length > 0) {\n              v = parseInt(v[1], 10);\n\n              if (v >= 1 && v < 8) {\n                features.isOldIOSPhone = true;\n              }\n            }\n          } // Detect old Android (before KitKat)\n          // due to bugs related to position:fixed\n          // http://stackoverflow.com/questions/7184573/pick-up-the-android-version-in-the-browser-by-javascript\n\n\n          var match = ua.match(/Android\\s([0-9\\.]*)/);\n          var androidversion = match ? match[1] : 0;\n          androidversion = parseFloat(androidversion);\n\n          if (androidversion >= 1) {\n            if (androidversion < 4.4) {\n              features.isOldAndroid = true; // for fixed position bug & performance\n            }\n\n            features.androidVersion = androidversion; // for touchend bug\n          }\n\n          features.isMobileOpera = /opera mini|opera mobi/i.test(ua); // p.s. yes, yes, UA sniffing is bad, propose your solution for above bugs.\n        }\n\n        var styleChecks = ['transform', 'perspective', 'animationName'],\n            vendors = ['', 'webkit', 'Moz', 'ms', 'O'],\n            styleCheckItem,\n            styleName;\n\n        for (var i = 0; i < 4; i++) {\n          vendor = vendors[i];\n\n          for (var a = 0; a < 3; a++) {\n            styleCheckItem = styleChecks[a]; // uppercase first letter of property name, if vendor is present\n\n            styleName = vendor + (vendor ? styleCheckItem.charAt(0).toUpperCase() + styleCheckItem.slice(1) : styleCheckItem);\n\n            if (!features[styleCheckItem] && styleName in helperStyle) {\n              features[styleCheckItem] = styleName;\n            }\n          }\n\n          if (vendor && !features.raf) {\n            vendor = vendor.toLowerCase();\n            features.raf = window[vendor + 'RequestAnimationFrame'];\n\n            if (features.raf) {\n              features.caf = window[vendor + 'CancelAnimationFrame'] || window[vendor + 'CancelRequestAnimationFrame'];\n            }\n          }\n        }\n\n        if (!features.raf) {\n          var lastTime = 0;\n\n          features.raf = function (fn) {\n            var currTime = new Date().getTime();\n            var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n            var id = window.setTimeout(function () {\n              fn(currTime + timeToCall);\n            }, timeToCall);\n            lastTime = currTime + timeToCall;\n            return id;\n          };\n\n          features.caf = function (id) {\n            clearTimeout(id);\n          };\n        } // Detect SVG support\n\n\n        features.svg = !!document.createElementNS && !!document.createElementNS('http://www.w3.org/2000/svg', 'svg').createSVGRect;\n        framework.features = features;\n        return features;\n      }\n    };\n    framework.detectFeatures(); // Override addEventListener for old versions of IE\n\n    if (framework.features.oldIE) {\n      framework.bind = function (target, type, listener, unbind) {\n        type = type.split(' ');\n\n        var methodName = (unbind ? 'detach' : 'attach') + 'Event',\n            evName,\n            _handleEv = function () {\n          listener.handleEvent.call(listener);\n        };\n\n        for (var i = 0; i < type.length; i++) {\n          evName = type[i];\n\n          if (evName) {\n            if (typeof listener === 'object' && listener.handleEvent) {\n              if (!unbind) {\n                listener['oldIE' + evName] = _handleEv;\n              } else {\n                if (!listener['oldIE' + evName]) {\n                  return false;\n                }\n              }\n\n              target[methodName]('on' + evName, listener['oldIE' + evName]);\n            } else {\n              target[methodName]('on' + evName, listener);\n            }\n          }\n        }\n      };\n    }\n    /*>>framework-bridge*/\n\n    /*>>core*/\n    //function(template, UiClass, items, options)\n\n\n    var self = this;\n    /**\n     * Static vars, don't change unless you know what you're doing.\n     */\n\n    var DOUBLE_TAP_RADIUS = 25,\n        NUM_HOLDERS = 3;\n    /**\n     * Options\n     */\n\n    var _options = {\n      allowPanToNext: true,\n      spacing: 0.12,\n      bgOpacity: 1,\n      mouseUsed: false,\n      loop: true,\n      pinchToClose: true,\n      closeOnScroll: true,\n      closeOnVerticalDrag: true,\n      verticalDragRange: 0.75,\n      hideAnimationDuration: 333,\n      showAnimationDuration: 333,\n      showHideOpacity: false,\n      focus: true,\n      escKey: true,\n      arrowKeys: true,\n      mainScrollEndFriction: 0.35,\n      panEndFriction: 0.35,\n      isClickableElement: function (el) {\n        return el.tagName === 'A';\n      },\n      getDoubleTapZoom: function (isMouseClick, item) {\n        if (isMouseClick) {\n          return 1;\n        } else {\n          return item.initialZoomLevel < 0.7 ? 1 : 1.33;\n        }\n      },\n      maxSpreadZoom: 1.33,\n      modal: true,\n      // not fully implemented yet\n      scaleMode: 'fit' // TODO\n\n    };\n    framework.extend(_options, options);\n    /**\n     * Private helper variables & functions\n     */\n\n    var _getEmptyPoint = function () {\n      return {\n        x: 0,\n        y: 0\n      };\n    };\n\n    var _isOpen,\n        _isDestroying,\n        _closedByScroll,\n        _currentItemIndex,\n        _containerStyle,\n        _containerShiftIndex,\n        _currPanDist = _getEmptyPoint(),\n        _startPanOffset = _getEmptyPoint(),\n        _panOffset = _getEmptyPoint(),\n        _upMoveEvents,\n        // drag move, drag end & drag cancel events array\n    _downEvents,\n        // drag start events array\n    _globalEventHandlers,\n        _viewportSize = {},\n        _currZoomLevel,\n        _startZoomLevel,\n        _translatePrefix,\n        _translateSufix,\n        _updateSizeInterval,\n        _itemsNeedUpdate,\n        _currPositionIndex = 0,\n        _offset = {},\n        _slideSize = _getEmptyPoint(),\n        // size of slide area, including spacing\n    _itemHolders,\n        _prevItemIndex,\n        _indexDiff = 0,\n        // difference of indexes since last content update\n    _dragStartEvent,\n        _dragMoveEvent,\n        _dragEndEvent,\n        _dragCancelEvent,\n        _transformKey,\n        _pointerEventEnabled,\n        _isFixedPosition = true,\n        _likelyTouchDevice,\n        _modules = [],\n        _requestAF,\n        _cancelAF,\n        _initalClassName,\n        _initalWindowScrollY,\n        _oldIE,\n        _currentWindowScrollY,\n        _features,\n        _windowVisibleSize = {},\n        _renderMaxResolution = false,\n        _orientationChangeTimeout,\n        // Registers PhotoSWipe module (History, Controller ...)\n    _registerModule = function (name, module) {\n      framework.extend(self, module.publicMethods);\n\n      _modules.push(name);\n    },\n        _getLoopedId = function (index) {\n      var numSlides = _getNumItems();\n\n      if (index > numSlides - 1) {\n        return index - numSlides;\n      } else if (index < 0) {\n        return numSlides + index;\n      }\n\n      return index;\n    },\n        // Micro bind/trigger\n    _listeners = {},\n        _listen = function (name, fn) {\n      if (!_listeners[name]) {\n        _listeners[name] = [];\n      }\n\n      return _listeners[name].push(fn);\n    },\n        _shout = function (name) {\n      var listeners = _listeners[name];\n\n      if (listeners) {\n        var args = Array.prototype.slice.call(arguments);\n        args.shift();\n\n        for (var i = 0; i < listeners.length; i++) {\n          listeners[i].apply(self, args);\n        }\n      }\n    },\n        _getCurrentTime = function () {\n      return new Date().getTime();\n    },\n        _applyBgOpacity = function (opacity) {\n      _bgOpacity = opacity;\n      self.bg.style.opacity = opacity * _options.bgOpacity;\n    },\n        _applyZoomTransform = function (styleObj, x, y, zoom, item) {\n      if (!_renderMaxResolution || item && item !== self.currItem) {\n        zoom = zoom / (item ? item.fitRatio : self.currItem.fitRatio);\n      }\n\n      styleObj[_transformKey] = _translatePrefix + x + 'px, ' + y + 'px' + _translateSufix + ' scale(' + zoom + ')';\n    },\n        _applyCurrentZoomPan = function (allowRenderResolution) {\n      if (_currZoomElementStyle) {\n        if (allowRenderResolution) {\n          if (_currZoomLevel > self.currItem.fitRatio) {\n            if (!_renderMaxResolution) {\n              _setImageSize(self.currItem, false, true);\n\n              _renderMaxResolution = true;\n            }\n          } else {\n            if (_renderMaxResolution) {\n              _setImageSize(self.currItem);\n\n              _renderMaxResolution = false;\n            }\n          }\n        }\n\n        _applyZoomTransform(_currZoomElementStyle, _panOffset.x, _panOffset.y, _currZoomLevel);\n      }\n    },\n        _applyZoomPanToItem = function (item) {\n      if (item.container) {\n        _applyZoomTransform(item.container.style, item.initialPosition.x, item.initialPosition.y, item.initialZoomLevel, item);\n      }\n    },\n        _setTranslateX = function (x, elStyle) {\n      elStyle[_transformKey] = _translatePrefix + x + 'px, 0px' + _translateSufix;\n    },\n        _moveMainScroll = function (x, dragging) {\n      if (!_options.loop && dragging) {\n        var newSlideIndexOffset = _currentItemIndex + (_slideSize.x * _currPositionIndex - x) / _slideSize.x,\n            delta = Math.round(x - _mainScrollPos.x);\n\n        if (newSlideIndexOffset < 0 && delta > 0 || newSlideIndexOffset >= _getNumItems() - 1 && delta < 0) {\n          x = _mainScrollPos.x + delta * _options.mainScrollEndFriction;\n        }\n      }\n\n      _mainScrollPos.x = x;\n\n      _setTranslateX(x, _containerStyle);\n    },\n        _calculatePanOffset = function (axis, zoomLevel) {\n      var m = _midZoomPoint[axis] - _offset[axis];\n      return _startPanOffset[axis] + _currPanDist[axis] + m - m * (zoomLevel / _startZoomLevel);\n    },\n        _equalizePoints = function (p1, p2) {\n      p1.x = p2.x;\n      p1.y = p2.y;\n\n      if (p2.id) {\n        p1.id = p2.id;\n      }\n    },\n        _roundPoint = function (p) {\n      p.x = Math.round(p.x);\n      p.y = Math.round(p.y);\n    },\n        _mouseMoveTimeout = null,\n        _onFirstMouseMove = function () {\n      // Wait until mouse move event is fired at least twice during 100ms\n      // We do this, because some mobile browsers trigger it on touchstart\n      if (_mouseMoveTimeout) {\n        framework.unbind(document, 'mousemove', _onFirstMouseMove);\n        framework.addClass(template, 'pswp--has_mouse');\n        _options.mouseUsed = true;\n\n        _shout('mouseUsed');\n      }\n\n      _mouseMoveTimeout = setTimeout(function () {\n        _mouseMoveTimeout = null;\n      }, 100);\n    },\n        _bindEvents = function () {\n      framework.bind(document, 'keydown', self);\n\n      if (_features.transform) {\n        // don't bind click event in browsers that don't support transform (mostly IE8)\n        framework.bind(self.scrollWrap, 'click', self);\n      }\n\n      if (!_options.mouseUsed) {\n        framework.bind(document, 'mousemove', _onFirstMouseMove);\n      }\n\n      framework.bind(window, 'resize scroll orientationchange', self);\n\n      _shout('bindEvents');\n    },\n        _unbindEvents = function () {\n      framework.unbind(window, 'resize scroll orientationchange', self);\n      framework.unbind(window, 'scroll', _globalEventHandlers.scroll);\n      framework.unbind(document, 'keydown', self);\n      framework.unbind(document, 'mousemove', _onFirstMouseMove);\n\n      if (_features.transform) {\n        framework.unbind(self.scrollWrap, 'click', self);\n      }\n\n      if (_isDragging) {\n        framework.unbind(window, _upMoveEvents, self);\n      }\n\n      clearTimeout(_orientationChangeTimeout);\n\n      _shout('unbindEvents');\n    },\n        _calculatePanBounds = function (zoomLevel, update) {\n      var bounds = _calculateItemSize(self.currItem, _viewportSize, zoomLevel);\n\n      if (update) {\n        _currPanBounds = bounds;\n      }\n\n      return bounds;\n    },\n        _getMinZoomLevel = function (item) {\n      if (!item) {\n        item = self.currItem;\n      }\n\n      return item.initialZoomLevel;\n    },\n        _getMaxZoomLevel = function (item) {\n      if (!item) {\n        item = self.currItem;\n      }\n\n      return item.w > 0 ? _options.maxSpreadZoom : 1;\n    },\n        // Return true if offset is out of the bounds\n    _modifyDestPanOffset = function (axis, destPanBounds, destPanOffset, destZoomLevel) {\n      if (destZoomLevel === self.currItem.initialZoomLevel) {\n        destPanOffset[axis] = self.currItem.initialPosition[axis];\n        return true;\n      } else {\n        destPanOffset[axis] = _calculatePanOffset(axis, destZoomLevel);\n\n        if (destPanOffset[axis] > destPanBounds.min[axis]) {\n          destPanOffset[axis] = destPanBounds.min[axis];\n          return true;\n        } else if (destPanOffset[axis] < destPanBounds.max[axis]) {\n          destPanOffset[axis] = destPanBounds.max[axis];\n          return true;\n        }\n      }\n\n      return false;\n    },\n        _setupTransforms = function () {\n      if (_transformKey) {\n        // setup 3d transforms\n        var allow3dTransform = _features.perspective && !_likelyTouchDevice;\n        _translatePrefix = 'translate' + (allow3dTransform ? '3d(' : '(');\n        _translateSufix = _features.perspective ? ', 0px)' : ')';\n        return;\n      } // Override zoom/pan/move functions in case old browser is used (most likely IE)\n      // (so they use left/top/width/height, instead of CSS transform)\n\n\n      _transformKey = 'left';\n      framework.addClass(template, 'pswp--ie');\n\n      _setTranslateX = function (x, elStyle) {\n        elStyle.left = x + 'px';\n      };\n\n      _applyZoomPanToItem = function (item) {\n        var zoomRatio = item.fitRatio > 1 ? 1 : item.fitRatio,\n            s = item.container.style,\n            w = zoomRatio * item.w,\n            h = zoomRatio * item.h;\n        s.width = w + 'px';\n        s.height = h + 'px';\n        s.left = item.initialPosition.x + 'px';\n        s.top = item.initialPosition.y + 'px';\n      };\n\n      _applyCurrentZoomPan = function () {\n        if (_currZoomElementStyle) {\n          var s = _currZoomElementStyle,\n              item = self.currItem,\n              zoomRatio = item.fitRatio > 1 ? 1 : item.fitRatio,\n              w = zoomRatio * item.w,\n              h = zoomRatio * item.h;\n          s.width = w + 'px';\n          s.height = h + 'px';\n          s.left = _panOffset.x + 'px';\n          s.top = _panOffset.y + 'px';\n        }\n      };\n    },\n        _onKeyDown = function (e) {\n      var keydownAction = '';\n\n      if (_options.escKey && e.keyCode === 27) {\n        keydownAction = 'close';\n      } else if (_options.arrowKeys) {\n        if (e.keyCode === 37) {\n          keydownAction = 'prev';\n        } else if (e.keyCode === 39) {\n          keydownAction = 'next';\n        }\n      }\n\n      if (keydownAction) {\n        // don't do anything if special key pressed to prevent from overriding default browser actions\n        // e.g. in Chrome on Mac cmd+arrow-left returns to previous page\n        if (!e.ctrlKey && !e.altKey && !e.shiftKey && !e.metaKey) {\n          if (e.preventDefault) {\n            e.preventDefault();\n          } else {\n            e.returnValue = false;\n          }\n\n          self[keydownAction]();\n        }\n      }\n    },\n        _onGlobalClick = function (e) {\n      if (!e) {\n        return;\n      } // don't allow click event to pass through when triggering after drag or some other gesture\n\n\n      if (_moved || _zoomStarted || _mainScrollAnimating || _verticalDragInitiated) {\n        e.preventDefault();\n        e.stopPropagation();\n      }\n    },\n        _updatePageScrollOffset = function () {\n      self.setScrollOffset(0, framework.getScrollY());\n    }; // Micro animation engine\n\n\n    var _animations = {},\n        _numAnimations = 0,\n        _stopAnimation = function (name) {\n      if (_animations[name]) {\n        if (_animations[name].raf) {\n          _cancelAF(_animations[name].raf);\n        }\n\n        _numAnimations--;\n        delete _animations[name];\n      }\n    },\n        _registerStartAnimation = function (name) {\n      if (_animations[name]) {\n        _stopAnimation(name);\n      }\n\n      if (!_animations[name]) {\n        _numAnimations++;\n        _animations[name] = {};\n      }\n    },\n        _stopAllAnimations = function () {\n      for (var prop in _animations) {\n        if (_animations.hasOwnProperty(prop)) {\n          _stopAnimation(prop);\n        }\n      }\n    },\n        _animateProp = function (name, b, endProp, d, easingFn, onUpdate, onComplete) {\n      var startAnimTime = _getCurrentTime(),\n          t;\n\n      _registerStartAnimation(name);\n\n      var animloop = function () {\n        if (_animations[name]) {\n          t = _getCurrentTime() - startAnimTime; // time diff\n          //b - beginning (start prop)\n          //d - anim duration\n\n          if (t >= d) {\n            _stopAnimation(name);\n\n            onUpdate(endProp);\n\n            if (onComplete) {\n              onComplete();\n            }\n\n            return;\n          }\n\n          onUpdate((endProp - b) * easingFn(t / d) + b);\n          _animations[name].raf = _requestAF(animloop);\n        }\n      };\n\n      animloop();\n    };\n\n    var publicMethods = {\n      // make a few local variables and functions public\n      shout: _shout,\n      listen: _listen,\n      viewportSize: _viewportSize,\n      options: _options,\n      isMainScrollAnimating: function () {\n        return _mainScrollAnimating;\n      },\n      getZoomLevel: function () {\n        return _currZoomLevel;\n      },\n      getCurrentIndex: function () {\n        return _currentItemIndex;\n      },\n      isDragging: function () {\n        return _isDragging;\n      },\n      isZooming: function () {\n        return _isZooming;\n      },\n      setScrollOffset: function (x, y) {\n        _offset.x = x;\n        _currentWindowScrollY = _offset.y = y;\n\n        _shout('updateScrollOffset', _offset);\n      },\n      applyZoomPan: function (zoomLevel, panX, panY, allowRenderResolution) {\n        _panOffset.x = panX;\n        _panOffset.y = panY;\n        _currZoomLevel = zoomLevel;\n\n        _applyCurrentZoomPan(allowRenderResolution);\n      },\n      init: function () {\n        if (_isOpen || _isDestroying) {\n          return;\n        }\n\n        var i;\n        self.framework = framework; // basic functionality\n\n        self.template = template; // root DOM element of PhotoSwipe\n\n        self.bg = framework.getChildByClass(template, 'pswp__bg');\n        _initalClassName = template.className;\n        _isOpen = true;\n        _features = framework.detectFeatures();\n        _requestAF = _features.raf;\n        _cancelAF = _features.caf;\n        _transformKey = _features.transform;\n        _oldIE = _features.oldIE;\n        self.scrollWrap = framework.getChildByClass(template, 'pswp__scroll-wrap');\n        self.container = framework.getChildByClass(self.scrollWrap, 'pswp__container');\n        _containerStyle = self.container.style; // for fast access\n        // Objects that hold slides (there are only 3 in DOM)\n\n        self.itemHolders = _itemHolders = [{\n          el: self.container.children[0],\n          wrap: 0,\n          index: -1\n        }, {\n          el: self.container.children[1],\n          wrap: 0,\n          index: -1\n        }, {\n          el: self.container.children[2],\n          wrap: 0,\n          index: -1\n        }]; // hide nearby item holders until initial zoom animation finishes (to avoid extra Paints)\n\n        _itemHolders[0].el.style.display = _itemHolders[2].el.style.display = 'none';\n\n        _setupTransforms(); // Setup global events\n\n\n        _globalEventHandlers = {\n          resize: self.updateSize,\n          // Fixes: iOS 10.3 resize event\n          // does not update scrollWrap.clientWidth instantly after resize\n          // https://github.com/dimsemenov/PhotoSwipe/issues/1315\n          orientationchange: function () {\n            clearTimeout(_orientationChangeTimeout);\n            _orientationChangeTimeout = setTimeout(function () {\n              if (_viewportSize.x !== self.scrollWrap.clientWidth) {\n                self.updateSize();\n              }\n            }, 500);\n          },\n          scroll: _updatePageScrollOffset,\n          keydown: _onKeyDown,\n          click: _onGlobalClick\n        }; // disable show/hide effects on old browsers that don't support CSS animations or transforms, \n        // old IOS, Android and Opera mobile. Blackberry seems to work fine, even older models.\n\n        var oldPhone = _features.isOldIOSPhone || _features.isOldAndroid || _features.isMobileOpera;\n\n        if (!_features.animationName || !_features.transform || oldPhone) {\n          _options.showAnimationDuration = _options.hideAnimationDuration = 0;\n        } // init modules\n\n\n        for (i = 0; i < _modules.length; i++) {\n          self['init' + _modules[i]]();\n        } // init\n\n\n        if (UiClass) {\n          var ui = self.ui = new UiClass(self, framework);\n          ui.init();\n        }\n\n        _shout('firstUpdate');\n\n        _currentItemIndex = _currentItemIndex || _options.index || 0; // validate index\n\n        if (isNaN(_currentItemIndex) || _currentItemIndex < 0 || _currentItemIndex >= _getNumItems()) {\n          _currentItemIndex = 0;\n        }\n\n        self.currItem = _getItemAt(_currentItemIndex);\n\n        if (_features.isOldIOSPhone || _features.isOldAndroid) {\n          _isFixedPosition = false;\n        }\n\n        template.setAttribute('aria-hidden', 'false');\n\n        if (_options.modal) {\n          if (!_isFixedPosition) {\n            template.style.position = 'absolute';\n            template.style.top = framework.getScrollY() + 'px';\n          } else {\n            template.style.position = 'fixed';\n          }\n        }\n\n        if (_currentWindowScrollY === undefined) {\n          _shout('initialLayout');\n\n          _currentWindowScrollY = _initalWindowScrollY = framework.getScrollY();\n        } // add classes to root element of PhotoSwipe\n\n\n        var rootClasses = 'pswp--open ';\n\n        if (_options.mainClass) {\n          rootClasses += _options.mainClass + ' ';\n        }\n\n        if (_options.showHideOpacity) {\n          rootClasses += 'pswp--animate_opacity ';\n        }\n\n        rootClasses += _likelyTouchDevice ? 'pswp--touch' : 'pswp--notouch';\n        rootClasses += _features.animationName ? ' pswp--css_animation' : '';\n        rootClasses += _features.svg ? ' pswp--svg' : '';\n        framework.addClass(template, rootClasses);\n        self.updateSize(); // initial update\n\n        _containerShiftIndex = -1;\n        _indexDiff = null;\n\n        for (i = 0; i < NUM_HOLDERS; i++) {\n          _setTranslateX((i + _containerShiftIndex) * _slideSize.x, _itemHolders[i].el.style);\n        }\n\n        if (!_oldIE) {\n          framework.bind(self.scrollWrap, _downEvents, self); // no dragging for old IE\n        }\n\n        _listen('initialZoomInEnd', function () {\n          self.setContent(_itemHolders[0], _currentItemIndex - 1);\n          self.setContent(_itemHolders[2], _currentItemIndex + 1);\n          _itemHolders[0].el.style.display = _itemHolders[2].el.style.display = 'block';\n\n          if (_options.focus) {\n            // focus causes layout, \n            // which causes lag during the animation, \n            // that's why we delay it untill the initial zoom transition ends\n            template.focus();\n          }\n\n          _bindEvents();\n        }); // set content for center slide (first time)\n\n\n        self.setContent(_itemHolders[1], _currentItemIndex);\n        self.updateCurrItem();\n\n        _shout('afterInit');\n\n        if (!_isFixedPosition) {\n          // On all versions of iOS lower than 8.0, we check size of viewport every second.\n          // \n          // This is done to detect when Safari top & bottom bars appear, \n          // as this action doesn't trigger any events (like resize). \n          // \n          // On iOS8 they fixed this.\n          // \n          // 10 Nov 2014: iOS 7 usage ~40%. iOS 8 usage 56%.\n          _updateSizeInterval = setInterval(function () {\n            if (!_numAnimations && !_isDragging && !_isZooming && _currZoomLevel === self.currItem.initialZoomLevel) {\n              self.updateSize();\n            }\n          }, 1000);\n        }\n\n        framework.addClass(template, 'pswp--visible');\n      },\n      // Close the gallery, then destroy it\n      close: function () {\n        if (!_isOpen) {\n          return;\n        }\n\n        _isOpen = false;\n        _isDestroying = true;\n\n        _shout('close');\n\n        _unbindEvents();\n\n        _showOrHide(self.currItem, null, true, self.destroy);\n      },\n      // destroys the gallery (unbinds events, cleans up intervals and timeouts to avoid memory leaks)\n      destroy: function () {\n        _shout('destroy');\n\n        if (_showOrHideTimeout) {\n          clearTimeout(_showOrHideTimeout);\n        }\n\n        template.setAttribute('aria-hidden', 'true');\n        template.className = _initalClassName;\n\n        if (_updateSizeInterval) {\n          clearInterval(_updateSizeInterval);\n        }\n\n        framework.unbind(self.scrollWrap, _downEvents, self); // we unbind scroll event at the end, as closing animation may depend on it\n\n        framework.unbind(window, 'scroll', self);\n\n        _stopDragUpdateLoop();\n\n        _stopAllAnimations();\n\n        _listeners = null;\n      },\n\n      /**\n       * Pan image to position\n       * @param {Number} x     \n       * @param {Number} y     \n       * @param {Boolean} force Will ignore bounds if set to true.\n       */\n      panTo: function (x, y, force) {\n        if (!force) {\n          if (x > _currPanBounds.min.x) {\n            x = _currPanBounds.min.x;\n          } else if (x < _currPanBounds.max.x) {\n            x = _currPanBounds.max.x;\n          }\n\n          if (y > _currPanBounds.min.y) {\n            y = _currPanBounds.min.y;\n          } else if (y < _currPanBounds.max.y) {\n            y = _currPanBounds.max.y;\n          }\n        }\n\n        _panOffset.x = x;\n        _panOffset.y = y;\n\n        _applyCurrentZoomPan();\n      },\n      handleEvent: function (e) {\n        e = e || window.event;\n\n        if (_globalEventHandlers[e.type]) {\n          _globalEventHandlers[e.type](e);\n        }\n      },\n      goTo: function (index) {\n        index = _getLoopedId(index);\n        var diff = index - _currentItemIndex;\n        _indexDiff = diff;\n        _currentItemIndex = index;\n        self.currItem = _getItemAt(_currentItemIndex);\n        _currPositionIndex -= diff;\n\n        _moveMainScroll(_slideSize.x * _currPositionIndex);\n\n        _stopAllAnimations();\n\n        _mainScrollAnimating = false;\n        self.updateCurrItem();\n      },\n      next: function () {\n        self.goTo(_currentItemIndex + 1);\n      },\n      prev: function () {\n        self.goTo(_currentItemIndex - 1);\n      },\n      // update current zoom/pan objects\n      updateCurrZoomItem: function (emulateSetContent) {\n        if (emulateSetContent) {\n          _shout('beforeChange', 0);\n        } // itemHolder[1] is middle (current) item\n\n\n        if (_itemHolders[1].el.children.length) {\n          var zoomElement = _itemHolders[1].el.children[0];\n\n          if (framework.hasClass(zoomElement, 'pswp__zoom-wrap')) {\n            _currZoomElementStyle = zoomElement.style;\n          } else {\n            _currZoomElementStyle = null;\n          }\n        } else {\n          _currZoomElementStyle = null;\n        }\n\n        _currPanBounds = self.currItem.bounds;\n        _startZoomLevel = _currZoomLevel = self.currItem.initialZoomLevel;\n        _panOffset.x = _currPanBounds.center.x;\n        _panOffset.y = _currPanBounds.center.y;\n\n        if (emulateSetContent) {\n          _shout('afterChange');\n        }\n      },\n      invalidateCurrItems: function () {\n        _itemsNeedUpdate = true;\n\n        for (var i = 0; i < NUM_HOLDERS; i++) {\n          if (_itemHolders[i].item) {\n            _itemHolders[i].item.needsUpdate = true;\n          }\n        }\n      },\n      updateCurrItem: function (beforeAnimation) {\n        if (_indexDiff === 0) {\n          return;\n        }\n\n        var diffAbs = Math.abs(_indexDiff),\n            tempHolder;\n\n        if (beforeAnimation && diffAbs < 2) {\n          return;\n        }\n\n        self.currItem = _getItemAt(_currentItemIndex);\n        _renderMaxResolution = false;\n\n        _shout('beforeChange', _indexDiff);\n\n        if (diffAbs >= NUM_HOLDERS) {\n          _containerShiftIndex += _indexDiff + (_indexDiff > 0 ? -NUM_HOLDERS : NUM_HOLDERS);\n          diffAbs = NUM_HOLDERS;\n        }\n\n        for (var i = 0; i < diffAbs; i++) {\n          if (_indexDiff > 0) {\n            tempHolder = _itemHolders.shift();\n            _itemHolders[NUM_HOLDERS - 1] = tempHolder; // move first to last\n\n            _containerShiftIndex++;\n\n            _setTranslateX((_containerShiftIndex + 2) * _slideSize.x, tempHolder.el.style);\n\n            self.setContent(tempHolder, _currentItemIndex - diffAbs + i + 1 + 1);\n          } else {\n            tempHolder = _itemHolders.pop();\n\n            _itemHolders.unshift(tempHolder); // move last to first\n\n\n            _containerShiftIndex--;\n\n            _setTranslateX(_containerShiftIndex * _slideSize.x, tempHolder.el.style);\n\n            self.setContent(tempHolder, _currentItemIndex + diffAbs - i - 1 - 1);\n          }\n        } // reset zoom/pan on previous item\n\n\n        if (_currZoomElementStyle && Math.abs(_indexDiff) === 1) {\n          var prevItem = _getItemAt(_prevItemIndex);\n\n          if (prevItem.initialZoomLevel !== _currZoomLevel) {\n            _calculateItemSize(prevItem, _viewportSize);\n\n            _setImageSize(prevItem);\n\n            _applyZoomPanToItem(prevItem);\n          }\n        } // reset diff after update\n\n\n        _indexDiff = 0;\n        self.updateCurrZoomItem();\n        _prevItemIndex = _currentItemIndex;\n\n        _shout('afterChange');\n      },\n      updateSize: function (force) {\n        if (!_isFixedPosition && _options.modal) {\n          var windowScrollY = framework.getScrollY();\n\n          if (_currentWindowScrollY !== windowScrollY) {\n            template.style.top = windowScrollY + 'px';\n            _currentWindowScrollY = windowScrollY;\n          }\n\n          if (!force && _windowVisibleSize.x === window.innerWidth && _windowVisibleSize.y === window.innerHeight) {\n            return;\n          }\n\n          _windowVisibleSize.x = window.innerWidth;\n          _windowVisibleSize.y = window.innerHeight; //template.style.width = _windowVisibleSize.x + 'px';\n\n          template.style.height = _windowVisibleSize.y + 'px';\n        }\n\n        _viewportSize.x = self.scrollWrap.clientWidth;\n        _viewportSize.y = self.scrollWrap.clientHeight;\n\n        _updatePageScrollOffset();\n\n        _slideSize.x = _viewportSize.x + Math.round(_viewportSize.x * _options.spacing);\n        _slideSize.y = _viewportSize.y;\n\n        _moveMainScroll(_slideSize.x * _currPositionIndex);\n\n        _shout('beforeResize'); // even may be used for example to switch image sources\n        // don't re-calculate size on inital size update\n\n\n        if (_containerShiftIndex !== undefined) {\n          var holder, item, hIndex;\n\n          for (var i = 0; i < NUM_HOLDERS; i++) {\n            holder = _itemHolders[i];\n\n            _setTranslateX((i + _containerShiftIndex) * _slideSize.x, holder.el.style);\n\n            hIndex = _currentItemIndex + i - 1;\n\n            if (_options.loop && _getNumItems() > 2) {\n              hIndex = _getLoopedId(hIndex);\n            } // update zoom level on items and refresh source (if needsUpdate)\n\n\n            item = _getItemAt(hIndex); // re-render gallery item if `needsUpdate`,\n            // or doesn't have `bounds` (entirely new slide object)\n\n            if (item && (_itemsNeedUpdate || item.needsUpdate || !item.bounds)) {\n              self.cleanSlide(item);\n              self.setContent(holder, hIndex); // if \"center\" slide\n\n              if (i === 1) {\n                self.currItem = item;\n                self.updateCurrZoomItem(true);\n              }\n\n              item.needsUpdate = false;\n            } else if (holder.index === -1 && hIndex >= 0) {\n              // add content first time\n              self.setContent(holder, hIndex);\n            }\n\n            if (item && item.container) {\n              _calculateItemSize(item, _viewportSize);\n\n              _setImageSize(item);\n\n              _applyZoomPanToItem(item);\n            }\n          }\n\n          _itemsNeedUpdate = false;\n        }\n\n        _startZoomLevel = _currZoomLevel = self.currItem.initialZoomLevel;\n        _currPanBounds = self.currItem.bounds;\n\n        if (_currPanBounds) {\n          _panOffset.x = _currPanBounds.center.x;\n          _panOffset.y = _currPanBounds.center.y;\n\n          _applyCurrentZoomPan(true);\n        }\n\n        _shout('resize');\n      },\n      // Zoom current item to\n      zoomTo: function (destZoomLevel, centerPoint, speed, easingFn, updateFn) {\n        /*\n        \tif(destZoomLevel === 'fit') {\n        \t\tdestZoomLevel = self.currItem.fitRatio;\n        \t} else if(destZoomLevel === 'fill') {\n        \t\tdestZoomLevel = self.currItem.fillRatio;\n        \t}\n        */\n        if (centerPoint) {\n          _startZoomLevel = _currZoomLevel;\n          _midZoomPoint.x = Math.abs(centerPoint.x) - _panOffset.x;\n          _midZoomPoint.y = Math.abs(centerPoint.y) - _panOffset.y;\n\n          _equalizePoints(_startPanOffset, _panOffset);\n        }\n\n        var destPanBounds = _calculatePanBounds(destZoomLevel, false),\n            destPanOffset = {};\n\n        _modifyDestPanOffset('x', destPanBounds, destPanOffset, destZoomLevel);\n\n        _modifyDestPanOffset('y', destPanBounds, destPanOffset, destZoomLevel);\n\n        var initialZoomLevel = _currZoomLevel;\n        var initialPanOffset = {\n          x: _panOffset.x,\n          y: _panOffset.y\n        };\n\n        _roundPoint(destPanOffset);\n\n        var onUpdate = function (now) {\n          if (now === 1) {\n            _currZoomLevel = destZoomLevel;\n            _panOffset.x = destPanOffset.x;\n            _panOffset.y = destPanOffset.y;\n          } else {\n            _currZoomLevel = (destZoomLevel - initialZoomLevel) * now + initialZoomLevel;\n            _panOffset.x = (destPanOffset.x - initialPanOffset.x) * now + initialPanOffset.x;\n            _panOffset.y = (destPanOffset.y - initialPanOffset.y) * now + initialPanOffset.y;\n          }\n\n          if (updateFn) {\n            updateFn(now);\n          }\n\n          _applyCurrentZoomPan(now === 1);\n        };\n\n        if (speed) {\n          _animateProp('customZoomTo', 0, 1, speed, easingFn || framework.easing.sine.inOut, onUpdate);\n        } else {\n          onUpdate(1);\n        }\n      }\n    };\n    /*>>core*/\n\n    /*>>gestures*/\n\n    /**\n     * Mouse/touch/pointer event handlers.\n     * \n     * separated from @core.js for readability\n     */\n\n    var MIN_SWIPE_DISTANCE = 30,\n        DIRECTION_CHECK_OFFSET = 10; // amount of pixels to drag to determine direction of swipe\n\n    var _gestureStartTime,\n        _gestureCheckSpeedTime,\n        // pool of objects that are used during dragging of zooming\n    p = {},\n        // first point\n    p2 = {},\n        // second point (for zoom gesture)\n    delta = {},\n        _currPoint = {},\n        _startPoint = {},\n        _currPointers = [],\n        _startMainScrollPos = {},\n        _releaseAnimData,\n        _posPoints = [],\n        // array of points during dragging, used to determine type of gesture\n    _tempPoint = {},\n        _isZoomingIn,\n        _verticalDragInitiated,\n        _oldAndroidTouchEndTimeout,\n        _currZoomedItemIndex = 0,\n        _centerPoint = _getEmptyPoint(),\n        _lastReleaseTime = 0,\n        _isDragging,\n        // at least one pointer is down\n    _isMultitouch,\n        // at least two _pointers are down\n    _zoomStarted,\n        // zoom level changed during zoom gesture\n    _moved,\n        _dragAnimFrame,\n        _mainScrollShifted,\n        _currentPoints,\n        // array of current touch points\n    _isZooming,\n        _currPointsDistance,\n        _startPointsDistance,\n        _currPanBounds,\n        _mainScrollPos = _getEmptyPoint(),\n        _currZoomElementStyle,\n        _mainScrollAnimating,\n        // true, if animation after swipe gesture is running\n    _midZoomPoint = _getEmptyPoint(),\n        _currCenterPoint = _getEmptyPoint(),\n        _direction,\n        _isFirstMove,\n        _opacityChanged,\n        _bgOpacity,\n        _wasOverInitialZoom,\n        _isEqualPoints = function (p1, p2) {\n      return p1.x === p2.x && p1.y === p2.y;\n    },\n        _isNearbyPoints = function (touch0, touch1) {\n      return Math.abs(touch0.x - touch1.x) < DOUBLE_TAP_RADIUS && Math.abs(touch0.y - touch1.y) < DOUBLE_TAP_RADIUS;\n    },\n        _calculatePointsDistance = function (p1, p2) {\n      _tempPoint.x = Math.abs(p1.x - p2.x);\n      _tempPoint.y = Math.abs(p1.y - p2.y);\n      return Math.sqrt(_tempPoint.x * _tempPoint.x + _tempPoint.y * _tempPoint.y);\n    },\n        _stopDragUpdateLoop = function () {\n      if (_dragAnimFrame) {\n        _cancelAF(_dragAnimFrame);\n\n        _dragAnimFrame = null;\n      }\n    },\n        _dragUpdateLoop = function () {\n      if (_isDragging) {\n        _dragAnimFrame = _requestAF(_dragUpdateLoop);\n\n        _renderMovement();\n      }\n    },\n        _canPan = function () {\n      return !(_options.scaleMode === 'fit' && _currZoomLevel === self.currItem.initialZoomLevel);\n    },\n        // find the closest parent DOM element\n    _closestElement = function (el, fn) {\n      if (!el || el === document) {\n        return false;\n      } // don't search elements above pswp__scroll-wrap\n\n\n      if (el.getAttribute('class') && el.getAttribute('class').indexOf('pswp__scroll-wrap') > -1) {\n        return false;\n      }\n\n      if (fn(el)) {\n        return el;\n      }\n\n      return _closestElement(el.parentNode, fn);\n    },\n        _preventObj = {},\n        _preventDefaultEventBehaviour = function (e, isDown) {\n      _preventObj.prevent = !_closestElement(e.target, _options.isClickableElement);\n\n      _shout('preventDragEvent', e, isDown, _preventObj);\n\n      return _preventObj.prevent;\n    },\n        _convertTouchToPoint = function (touch, p) {\n      p.x = touch.pageX;\n      p.y = touch.pageY;\n      p.id = touch.identifier;\n      return p;\n    },\n        _findCenterOfPoints = function (p1, p2, pCenter) {\n      pCenter.x = (p1.x + p2.x) * 0.5;\n      pCenter.y = (p1.y + p2.y) * 0.5;\n    },\n        _pushPosPoint = function (time, x, y) {\n      if (time - _gestureCheckSpeedTime > 50) {\n        var o = _posPoints.length > 2 ? _posPoints.shift() : {};\n        o.x = x;\n        o.y = y;\n\n        _posPoints.push(o);\n\n        _gestureCheckSpeedTime = time;\n      }\n    },\n        _calculateVerticalDragOpacityRatio = function () {\n      var yOffset = _panOffset.y - self.currItem.initialPosition.y; // difference between initial and current position\n\n      return 1 - Math.abs(yOffset / (_viewportSize.y / 2));\n    },\n        // points pool, reused during touch events\n    _ePoint1 = {},\n        _ePoint2 = {},\n        _tempPointsArr = [],\n        _tempCounter,\n        _getTouchPoints = function (e) {\n      // clean up previous points, without recreating array\n      while (_tempPointsArr.length > 0) {\n        _tempPointsArr.pop();\n      }\n\n      if (!_pointerEventEnabled) {\n        if (e.type.indexOf('touch') > -1) {\n          if (e.touches && e.touches.length > 0) {\n            _tempPointsArr[0] = _convertTouchToPoint(e.touches[0], _ePoint1);\n\n            if (e.touches.length > 1) {\n              _tempPointsArr[1] = _convertTouchToPoint(e.touches[1], _ePoint2);\n            }\n          }\n        } else {\n          _ePoint1.x = e.pageX;\n          _ePoint1.y = e.pageY;\n          _ePoint1.id = '';\n          _tempPointsArr[0] = _ePoint1; //_ePoint1;\n        }\n      } else {\n        _tempCounter = 0; // we can use forEach, as pointer events are supported only in modern browsers\n\n        _currPointers.forEach(function (p) {\n          if (_tempCounter === 0) {\n            _tempPointsArr[0] = p;\n          } else if (_tempCounter === 1) {\n            _tempPointsArr[1] = p;\n          }\n\n          _tempCounter++;\n        });\n      }\n\n      return _tempPointsArr;\n    },\n        _panOrMoveMainScroll = function (axis, delta) {\n      var panFriction,\n          overDiff = 0,\n          newOffset = _panOffset[axis] + delta[axis],\n          startOverDiff,\n          dir = delta[axis] > 0,\n          newMainScrollPosition = _mainScrollPos.x + delta.x,\n          mainScrollDiff = _mainScrollPos.x - _startMainScrollPos.x,\n          newPanPos,\n          newMainScrollPos; // calculate fdistance over the bounds and friction\n\n      if (newOffset > _currPanBounds.min[axis] || newOffset < _currPanBounds.max[axis]) {\n        panFriction = _options.panEndFriction; // Linear increasing of friction, so at 1/4 of viewport it's at max value. \n        // Looks not as nice as was expected. Left for history.\n        // panFriction = (1 - (_panOffset[axis] + delta[axis] + panBounds.min[axis]) / (_viewportSize[axis] / 4) );\n      } else {\n        panFriction = 1;\n      }\n\n      newOffset = _panOffset[axis] + delta[axis] * panFriction; // move main scroll or start panning\n\n      if (_options.allowPanToNext || _currZoomLevel === self.currItem.initialZoomLevel) {\n        if (!_currZoomElementStyle) {\n          newMainScrollPos = newMainScrollPosition;\n        } else if (_direction === 'h' && axis === 'x' && !_zoomStarted) {\n          if (dir) {\n            if (newOffset > _currPanBounds.min[axis]) {\n              panFriction = _options.panEndFriction;\n              overDiff = _currPanBounds.min[axis] - newOffset;\n              startOverDiff = _currPanBounds.min[axis] - _startPanOffset[axis];\n            } // drag right\n\n\n            if ((startOverDiff <= 0 || mainScrollDiff < 0) && _getNumItems() > 1) {\n              newMainScrollPos = newMainScrollPosition;\n\n              if (mainScrollDiff < 0 && newMainScrollPosition > _startMainScrollPos.x) {\n                newMainScrollPos = _startMainScrollPos.x;\n              }\n            } else {\n              if (_currPanBounds.min.x !== _currPanBounds.max.x) {\n                newPanPos = newOffset;\n              }\n            }\n          } else {\n            if (newOffset < _currPanBounds.max[axis]) {\n              panFriction = _options.panEndFriction;\n              overDiff = newOffset - _currPanBounds.max[axis];\n              startOverDiff = _startPanOffset[axis] - _currPanBounds.max[axis];\n            }\n\n            if ((startOverDiff <= 0 || mainScrollDiff > 0) && _getNumItems() > 1) {\n              newMainScrollPos = newMainScrollPosition;\n\n              if (mainScrollDiff > 0 && newMainScrollPosition < _startMainScrollPos.x) {\n                newMainScrollPos = _startMainScrollPos.x;\n              }\n            } else {\n              if (_currPanBounds.min.x !== _currPanBounds.max.x) {\n                newPanPos = newOffset;\n              }\n            }\n          } //\n\n        }\n\n        if (axis === 'x') {\n          if (newMainScrollPos !== undefined) {\n            _moveMainScroll(newMainScrollPos, true);\n\n            if (newMainScrollPos === _startMainScrollPos.x) {\n              _mainScrollShifted = false;\n            } else {\n              _mainScrollShifted = true;\n            }\n          }\n\n          if (_currPanBounds.min.x !== _currPanBounds.max.x) {\n            if (newPanPos !== undefined) {\n              _panOffset.x = newPanPos;\n            } else if (!_mainScrollShifted) {\n              _panOffset.x += delta.x * panFriction;\n            }\n          }\n\n          return newMainScrollPos !== undefined;\n        }\n      }\n\n      if (!_mainScrollAnimating) {\n        if (!_mainScrollShifted) {\n          if (_currZoomLevel > self.currItem.fitRatio) {\n            _panOffset[axis] += delta[axis] * panFriction;\n          }\n        }\n      }\n    },\n        // Pointerdown/touchstart/mousedown handler\n    _onDragStart = function (e) {\n      // Allow dragging only via left mouse button.\n      // As this handler is not added in IE8 - we ignore e.which\n      // \n      // http://www.quirksmode.org/js/events_properties.html\n      // https://developer.mozilla.org/en-US/docs/Web/API/event.button\n      if (e.type === 'mousedown' && e.button > 0) {\n        return;\n      }\n\n      if (_initialZoomRunning) {\n        e.preventDefault();\n        return;\n      }\n\n      if (_oldAndroidTouchEndTimeout && e.type === 'mousedown') {\n        return;\n      }\n\n      if (_preventDefaultEventBehaviour(e, true)) {\n        e.preventDefault();\n      }\n\n      _shout('pointerDown');\n\n      if (_pointerEventEnabled) {\n        var pointerIndex = framework.arraySearch(_currPointers, e.pointerId, 'id');\n\n        if (pointerIndex < 0) {\n          pointerIndex = _currPointers.length;\n        }\n\n        _currPointers[pointerIndex] = {\n          x: e.pageX,\n          y: e.pageY,\n          id: e.pointerId\n        };\n      }\n\n      var startPointsList = _getTouchPoints(e),\n          numPoints = startPointsList.length;\n\n      _currentPoints = null;\n\n      _stopAllAnimations(); // init drag\n\n\n      if (!_isDragging || numPoints === 1) {\n        _isDragging = _isFirstMove = true;\n        framework.bind(window, _upMoveEvents, self);\n        _isZoomingIn = _wasOverInitialZoom = _opacityChanged = _verticalDragInitiated = _mainScrollShifted = _moved = _isMultitouch = _zoomStarted = false;\n        _direction = null;\n\n        _shout('firstTouchStart', startPointsList);\n\n        _equalizePoints(_startPanOffset, _panOffset);\n\n        _currPanDist.x = _currPanDist.y = 0;\n\n        _equalizePoints(_currPoint, startPointsList[0]);\n\n        _equalizePoints(_startPoint, _currPoint); //_equalizePoints(_startMainScrollPos, _mainScrollPos);\n\n\n        _startMainScrollPos.x = _slideSize.x * _currPositionIndex;\n        _posPoints = [{\n          x: _currPoint.x,\n          y: _currPoint.y\n        }];\n        _gestureCheckSpeedTime = _gestureStartTime = _getCurrentTime(); //_mainScrollAnimationEnd(true);\n\n        _calculatePanBounds(_currZoomLevel, true); // Start rendering\n\n\n        _stopDragUpdateLoop();\n\n        _dragUpdateLoop();\n      } // init zoom\n\n\n      if (!_isZooming && numPoints > 1 && !_mainScrollAnimating && !_mainScrollShifted) {\n        _startZoomLevel = _currZoomLevel;\n        _zoomStarted = false; // true if zoom changed at least once\n\n        _isZooming = _isMultitouch = true;\n        _currPanDist.y = _currPanDist.x = 0;\n\n        _equalizePoints(_startPanOffset, _panOffset);\n\n        _equalizePoints(p, startPointsList[0]);\n\n        _equalizePoints(p2, startPointsList[1]);\n\n        _findCenterOfPoints(p, p2, _currCenterPoint);\n\n        _midZoomPoint.x = Math.abs(_currCenterPoint.x) - _panOffset.x;\n        _midZoomPoint.y = Math.abs(_currCenterPoint.y) - _panOffset.y;\n        _currPointsDistance = _startPointsDistance = _calculatePointsDistance(p, p2);\n      }\n    },\n        // Pointermove/touchmove/mousemove handler\n    _onDragMove = function (e) {\n      e.preventDefault();\n\n      if (_pointerEventEnabled) {\n        var pointerIndex = framework.arraySearch(_currPointers, e.pointerId, 'id');\n\n        if (pointerIndex > -1) {\n          var p = _currPointers[pointerIndex];\n          p.x = e.pageX;\n          p.y = e.pageY;\n        }\n      }\n\n      if (_isDragging) {\n        var touchesList = _getTouchPoints(e);\n\n        if (!_direction && !_moved && !_isZooming) {\n          if (_mainScrollPos.x !== _slideSize.x * _currPositionIndex) {\n            // if main scroll position is shifted  direction is always horizontal\n            _direction = 'h';\n          } else {\n            var diff = Math.abs(touchesList[0].x - _currPoint.x) - Math.abs(touchesList[0].y - _currPoint.y); // check the direction of movement\n\n            if (Math.abs(diff) >= DIRECTION_CHECK_OFFSET) {\n              _direction = diff > 0 ? 'h' : 'v';\n              _currentPoints = touchesList;\n            }\n          }\n        } else {\n          _currentPoints = touchesList;\n        }\n      }\n    },\n        // \n    _renderMovement = function () {\n      if (!_currentPoints) {\n        return;\n      }\n\n      var numPoints = _currentPoints.length;\n\n      if (numPoints === 0) {\n        return;\n      }\n\n      _equalizePoints(p, _currentPoints[0]);\n\n      delta.x = p.x - _currPoint.x;\n      delta.y = p.y - _currPoint.y;\n\n      if (_isZooming && numPoints > 1) {\n        // Handle behaviour for more than 1 point\n        _currPoint.x = p.x;\n        _currPoint.y = p.y; // check if one of two points changed\n\n        if (!delta.x && !delta.y && _isEqualPoints(_currentPoints[1], p2)) {\n          return;\n        }\n\n        _equalizePoints(p2, _currentPoints[1]);\n\n        if (!_zoomStarted) {\n          _zoomStarted = true;\n\n          _shout('zoomGestureStarted');\n        } // Distance between two points\n\n\n        var pointsDistance = _calculatePointsDistance(p, p2);\n\n        var zoomLevel = _calculateZoomLevel(pointsDistance); // slightly over the of initial zoom level\n\n\n        if (zoomLevel > self.currItem.initialZoomLevel + self.currItem.initialZoomLevel / 15) {\n          _wasOverInitialZoom = true;\n        } // Apply the friction if zoom level is out of the bounds\n\n\n        var zoomFriction = 1,\n            minZoomLevel = _getMinZoomLevel(),\n            maxZoomLevel = _getMaxZoomLevel();\n\n        if (zoomLevel < minZoomLevel) {\n          if (_options.pinchToClose && !_wasOverInitialZoom && _startZoomLevel <= self.currItem.initialZoomLevel) {\n            // fade out background if zooming out\n            var minusDiff = minZoomLevel - zoomLevel;\n            var percent = 1 - minusDiff / (minZoomLevel / 1.2);\n\n            _applyBgOpacity(percent);\n\n            _shout('onPinchClose', percent);\n\n            _opacityChanged = true;\n          } else {\n            zoomFriction = (minZoomLevel - zoomLevel) / minZoomLevel;\n\n            if (zoomFriction > 1) {\n              zoomFriction = 1;\n            }\n\n            zoomLevel = minZoomLevel - zoomFriction * (minZoomLevel / 3);\n          }\n        } else if (zoomLevel > maxZoomLevel) {\n          // 1.5 - extra zoom level above the max. E.g. if max is x6, real max 6 + 1.5 = 7.5\n          zoomFriction = (zoomLevel - maxZoomLevel) / (minZoomLevel * 6);\n\n          if (zoomFriction > 1) {\n            zoomFriction = 1;\n          }\n\n          zoomLevel = maxZoomLevel + zoomFriction * minZoomLevel;\n        }\n\n        if (zoomFriction < 0) {\n          zoomFriction = 0;\n        } // distance between touch points after friction is applied\n\n\n        _currPointsDistance = pointsDistance; // _centerPoint - The point in the middle of two pointers\n\n        _findCenterOfPoints(p, p2, _centerPoint); // paning with two pointers pressed\n\n\n        _currPanDist.x += _centerPoint.x - _currCenterPoint.x;\n        _currPanDist.y += _centerPoint.y - _currCenterPoint.y;\n\n        _equalizePoints(_currCenterPoint, _centerPoint);\n\n        _panOffset.x = _calculatePanOffset('x', zoomLevel);\n        _panOffset.y = _calculatePanOffset('y', zoomLevel);\n        _isZoomingIn = zoomLevel > _currZoomLevel;\n        _currZoomLevel = zoomLevel;\n\n        _applyCurrentZoomPan();\n      } else {\n        // handle behaviour for one point (dragging or panning)\n        if (!_direction) {\n          return;\n        }\n\n        if (_isFirstMove) {\n          _isFirstMove = false; // subtract drag distance that was used during the detection direction  \n\n          if (Math.abs(delta.x) >= DIRECTION_CHECK_OFFSET) {\n            delta.x -= _currentPoints[0].x - _startPoint.x;\n          }\n\n          if (Math.abs(delta.y) >= DIRECTION_CHECK_OFFSET) {\n            delta.y -= _currentPoints[0].y - _startPoint.y;\n          }\n        }\n\n        _currPoint.x = p.x;\n        _currPoint.y = p.y; // do nothing if pointers position hasn't changed\n\n        if (delta.x === 0 && delta.y === 0) {\n          return;\n        }\n\n        if (_direction === 'v' && _options.closeOnVerticalDrag) {\n          if (!_canPan()) {\n            _currPanDist.y += delta.y;\n            _panOffset.y += delta.y;\n\n            var opacityRatio = _calculateVerticalDragOpacityRatio();\n\n            _verticalDragInitiated = true;\n\n            _shout('onVerticalDrag', opacityRatio);\n\n            _applyBgOpacity(opacityRatio);\n\n            _applyCurrentZoomPan();\n\n            return;\n          }\n        }\n\n        _pushPosPoint(_getCurrentTime(), p.x, p.y);\n\n        _moved = true;\n        _currPanBounds = self.currItem.bounds;\n\n        var mainScrollChanged = _panOrMoveMainScroll('x', delta);\n\n        if (!mainScrollChanged) {\n          _panOrMoveMainScroll('y', delta);\n\n          _roundPoint(_panOffset);\n\n          _applyCurrentZoomPan();\n        }\n      }\n    },\n        // Pointerup/pointercancel/touchend/touchcancel/mouseup event handler\n    _onDragRelease = function (e) {\n      if (_features.isOldAndroid) {\n        if (_oldAndroidTouchEndTimeout && e.type === 'mouseup') {\n          return;\n        } // on Android (v4.1, 4.2, 4.3 & possibly older) \n        // ghost mousedown/up event isn't preventable via e.preventDefault,\n        // which causes fake mousedown event\n        // so we block mousedown/up for 600ms\n\n\n        if (e.type.indexOf('touch') > -1) {\n          clearTimeout(_oldAndroidTouchEndTimeout);\n          _oldAndroidTouchEndTimeout = setTimeout(function () {\n            _oldAndroidTouchEndTimeout = 0;\n          }, 600);\n        }\n      }\n\n      _shout('pointerUp');\n\n      if (_preventDefaultEventBehaviour(e, false)) {\n        e.preventDefault();\n      }\n\n      var releasePoint;\n\n      if (_pointerEventEnabled) {\n        var pointerIndex = framework.arraySearch(_currPointers, e.pointerId, 'id');\n\n        if (pointerIndex > -1) {\n          releasePoint = _currPointers.splice(pointerIndex, 1)[0];\n\n          if (navigator.msPointerEnabled) {\n            var MSPOINTER_TYPES = {\n              4: 'mouse',\n              // event.MSPOINTER_TYPE_MOUSE\n              2: 'touch',\n              // event.MSPOINTER_TYPE_TOUCH \n              3: 'pen' // event.MSPOINTER_TYPE_PEN\n\n            };\n            releasePoint.type = MSPOINTER_TYPES[e.pointerType];\n\n            if (!releasePoint.type) {\n              releasePoint.type = e.pointerType || 'mouse';\n            }\n          } else {\n            releasePoint.type = e.pointerType || 'mouse';\n          }\n        }\n      }\n\n      var touchList = _getTouchPoints(e),\n          gestureType,\n          numPoints = touchList.length;\n\n      if (e.type === 'mouseup') {\n        numPoints = 0;\n      } // Do nothing if there were 3 touch points or more\n\n\n      if (numPoints === 2) {\n        _currentPoints = null;\n        return true;\n      } // if second pointer released\n\n\n      if (numPoints === 1) {\n        _equalizePoints(_startPoint, touchList[0]);\n      } // pointer hasn't moved, send \"tap release\" point\n\n\n      if (numPoints === 0 && !_direction && !_mainScrollAnimating) {\n        if (!releasePoint) {\n          if (e.type === 'mouseup') {\n            releasePoint = {\n              x: e.pageX,\n              y: e.pageY,\n              type: 'mouse'\n            };\n          } else if (e.changedTouches && e.changedTouches[0]) {\n            releasePoint = {\n              x: e.changedTouches[0].pageX,\n              y: e.changedTouches[0].pageY,\n              type: 'touch'\n            };\n          }\n        }\n\n        _shout('touchRelease', e, releasePoint);\n      } // Difference in time between releasing of two last touch points (zoom gesture)\n\n\n      var releaseTimeDiff = -1; // Gesture completed, no pointers left\n\n      if (numPoints === 0) {\n        _isDragging = false;\n        framework.unbind(window, _upMoveEvents, self);\n\n        _stopDragUpdateLoop();\n\n        if (_isZooming) {\n          // Two points released at the same time\n          releaseTimeDiff = 0;\n        } else if (_lastReleaseTime !== -1) {\n          releaseTimeDiff = _getCurrentTime() - _lastReleaseTime;\n        }\n      }\n\n      _lastReleaseTime = numPoints === 1 ? _getCurrentTime() : -1;\n\n      if (releaseTimeDiff !== -1 && releaseTimeDiff < 150) {\n        gestureType = 'zoom';\n      } else {\n        gestureType = 'swipe';\n      }\n\n      if (_isZooming && numPoints < 2) {\n        _isZooming = false; // Only second point released\n\n        if (numPoints === 1) {\n          gestureType = 'zoomPointerUp';\n        }\n\n        _shout('zoomGestureEnded');\n      }\n\n      _currentPoints = null;\n\n      if (!_moved && !_zoomStarted && !_mainScrollAnimating && !_verticalDragInitiated) {\n        // nothing to animate\n        return;\n      }\n\n      _stopAllAnimations();\n\n      if (!_releaseAnimData) {\n        _releaseAnimData = _initDragReleaseAnimationData();\n      }\n\n      _releaseAnimData.calculateSwipeSpeed('x');\n\n      if (_verticalDragInitiated) {\n        var opacityRatio = _calculateVerticalDragOpacityRatio();\n\n        if (opacityRatio < _options.verticalDragRange) {\n          self.close();\n        } else {\n          var initalPanY = _panOffset.y,\n              initialBgOpacity = _bgOpacity;\n\n          _animateProp('verticalDrag', 0, 1, 300, framework.easing.cubic.out, function (now) {\n            _panOffset.y = (self.currItem.initialPosition.y - initalPanY) * now + initalPanY;\n\n            _applyBgOpacity((1 - initialBgOpacity) * now + initialBgOpacity);\n\n            _applyCurrentZoomPan();\n          });\n\n          _shout('onVerticalDrag', 1);\n        }\n\n        return;\n      } // main scroll \n\n\n      if ((_mainScrollShifted || _mainScrollAnimating) && numPoints === 0) {\n        var itemChanged = _finishSwipeMainScrollGesture(gestureType, _releaseAnimData);\n\n        if (itemChanged) {\n          return;\n        }\n\n        gestureType = 'zoomPointerUp';\n      } // prevent zoom/pan animation when main scroll animation runs\n\n\n      if (_mainScrollAnimating) {\n        return;\n      } // Complete simple zoom gesture (reset zoom level if it's out of the bounds)  \n\n\n      if (gestureType !== 'swipe') {\n        _completeZoomGesture();\n\n        return;\n      } // Complete pan gesture if main scroll is not shifted, and it's possible to pan current image\n\n\n      if (!_mainScrollShifted && _currZoomLevel > self.currItem.fitRatio) {\n        _completePanGesture(_releaseAnimData);\n      }\n    },\n        // Returns object with data about gesture\n    // It's created only once and then reused\n    _initDragReleaseAnimationData = function () {\n      // temp local vars\n      var lastFlickDuration, tempReleasePos; // s = this\n\n      var s = {\n        lastFlickOffset: {},\n        lastFlickDist: {},\n        lastFlickSpeed: {},\n        slowDownRatio: {},\n        slowDownRatioReverse: {},\n        speedDecelerationRatio: {},\n        speedDecelerationRatioAbs: {},\n        distanceOffset: {},\n        backAnimDestination: {},\n        backAnimStarted: {},\n        calculateSwipeSpeed: function (axis) {\n          if (_posPoints.length > 1) {\n            lastFlickDuration = _getCurrentTime() - _gestureCheckSpeedTime + 50;\n            tempReleasePos = _posPoints[_posPoints.length - 2][axis];\n          } else {\n            lastFlickDuration = _getCurrentTime() - _gestureStartTime; // total gesture duration\n\n            tempReleasePos = _startPoint[axis];\n          }\n\n          s.lastFlickOffset[axis] = _currPoint[axis] - tempReleasePos;\n          s.lastFlickDist[axis] = Math.abs(s.lastFlickOffset[axis]);\n\n          if (s.lastFlickDist[axis] > 20) {\n            s.lastFlickSpeed[axis] = s.lastFlickOffset[axis] / lastFlickDuration;\n          } else {\n            s.lastFlickSpeed[axis] = 0;\n          }\n\n          if (Math.abs(s.lastFlickSpeed[axis]) < 0.1) {\n            s.lastFlickSpeed[axis] = 0;\n          }\n\n          s.slowDownRatio[axis] = 0.95;\n          s.slowDownRatioReverse[axis] = 1 - s.slowDownRatio[axis];\n          s.speedDecelerationRatio[axis] = 1;\n        },\n        calculateOverBoundsAnimOffset: function (axis, speed) {\n          if (!s.backAnimStarted[axis]) {\n            if (_panOffset[axis] > _currPanBounds.min[axis]) {\n              s.backAnimDestination[axis] = _currPanBounds.min[axis];\n            } else if (_panOffset[axis] < _currPanBounds.max[axis]) {\n              s.backAnimDestination[axis] = _currPanBounds.max[axis];\n            }\n\n            if (s.backAnimDestination[axis] !== undefined) {\n              s.slowDownRatio[axis] = 0.7;\n              s.slowDownRatioReverse[axis] = 1 - s.slowDownRatio[axis];\n\n              if (s.speedDecelerationRatioAbs[axis] < 0.05) {\n                s.lastFlickSpeed[axis] = 0;\n                s.backAnimStarted[axis] = true;\n\n                _animateProp('bounceZoomPan' + axis, _panOffset[axis], s.backAnimDestination[axis], speed || 300, framework.easing.sine.out, function (pos) {\n                  _panOffset[axis] = pos;\n\n                  _applyCurrentZoomPan();\n                });\n              }\n            }\n          }\n        },\n        // Reduces the speed by slowDownRatio (per 10ms)\n        calculateAnimOffset: function (axis) {\n          if (!s.backAnimStarted[axis]) {\n            s.speedDecelerationRatio[axis] = s.speedDecelerationRatio[axis] * (s.slowDownRatio[axis] + s.slowDownRatioReverse[axis] - s.slowDownRatioReverse[axis] * s.timeDiff / 10);\n            s.speedDecelerationRatioAbs[axis] = Math.abs(s.lastFlickSpeed[axis] * s.speedDecelerationRatio[axis]);\n            s.distanceOffset[axis] = s.lastFlickSpeed[axis] * s.speedDecelerationRatio[axis] * s.timeDiff;\n            _panOffset[axis] += s.distanceOffset[axis];\n          }\n        },\n        panAnimLoop: function () {\n          if (_animations.zoomPan) {\n            _animations.zoomPan.raf = _requestAF(s.panAnimLoop);\n            s.now = _getCurrentTime();\n            s.timeDiff = s.now - s.lastNow;\n            s.lastNow = s.now;\n            s.calculateAnimOffset('x');\n            s.calculateAnimOffset('y');\n\n            _applyCurrentZoomPan();\n\n            s.calculateOverBoundsAnimOffset('x');\n            s.calculateOverBoundsAnimOffset('y');\n\n            if (s.speedDecelerationRatioAbs.x < 0.05 && s.speedDecelerationRatioAbs.y < 0.05) {\n              // round pan position\n              _panOffset.x = Math.round(_panOffset.x);\n              _panOffset.y = Math.round(_panOffset.y);\n\n              _applyCurrentZoomPan();\n\n              _stopAnimation('zoomPan');\n\n              return;\n            }\n          }\n        }\n      };\n      return s;\n    },\n        _completePanGesture = function (animData) {\n      // calculate swipe speed for Y axis (paanning)\n      animData.calculateSwipeSpeed('y');\n      _currPanBounds = self.currItem.bounds;\n      animData.backAnimDestination = {};\n      animData.backAnimStarted = {}; // Avoid acceleration animation if speed is too low\n\n      if (Math.abs(animData.lastFlickSpeed.x) <= 0.05 && Math.abs(animData.lastFlickSpeed.y) <= 0.05) {\n        animData.speedDecelerationRatioAbs.x = animData.speedDecelerationRatioAbs.y = 0; // Run pan drag release animation. E.g. if you drag image and release finger without momentum.\n\n        animData.calculateOverBoundsAnimOffset('x');\n        animData.calculateOverBoundsAnimOffset('y');\n        return true;\n      } // Animation loop that controls the acceleration after pan gesture ends\n\n\n      _registerStartAnimation('zoomPan');\n\n      animData.lastNow = _getCurrentTime();\n      animData.panAnimLoop();\n    },\n        _finishSwipeMainScrollGesture = function (gestureType, _releaseAnimData) {\n      var itemChanged;\n\n      if (!_mainScrollAnimating) {\n        _currZoomedItemIndex = _currentItemIndex;\n      }\n\n      var itemsDiff;\n\n      if (gestureType === 'swipe') {\n        var totalShiftDist = _currPoint.x - _startPoint.x,\n            isFastLastFlick = _releaseAnimData.lastFlickDist.x < 10; // if container is shifted for more than MIN_SWIPE_DISTANCE, \n        // and last flick gesture was in right direction\n\n        if (totalShiftDist > MIN_SWIPE_DISTANCE && (isFastLastFlick || _releaseAnimData.lastFlickOffset.x > 20)) {\n          // go to prev item\n          itemsDiff = -1;\n        } else if (totalShiftDist < -MIN_SWIPE_DISTANCE && (isFastLastFlick || _releaseAnimData.lastFlickOffset.x < -20)) {\n          // go to next item\n          itemsDiff = 1;\n        }\n      }\n\n      var nextCircle;\n\n      if (itemsDiff) {\n        _currentItemIndex += itemsDiff;\n\n        if (_currentItemIndex < 0) {\n          _currentItemIndex = _options.loop ? _getNumItems() - 1 : 0;\n          nextCircle = true;\n        } else if (_currentItemIndex >= _getNumItems()) {\n          _currentItemIndex = _options.loop ? 0 : _getNumItems() - 1;\n          nextCircle = true;\n        }\n\n        if (!nextCircle || _options.loop) {\n          _indexDiff += itemsDiff;\n          _currPositionIndex -= itemsDiff;\n          itemChanged = true;\n        }\n      }\n\n      var animateToX = _slideSize.x * _currPositionIndex;\n      var animateToDist = Math.abs(animateToX - _mainScrollPos.x);\n      var finishAnimDuration;\n\n      if (!itemChanged && animateToX > _mainScrollPos.x !== _releaseAnimData.lastFlickSpeed.x > 0) {\n        // \"return to current\" duration, e.g. when dragging from slide 0 to -1\n        finishAnimDuration = 333;\n      } else {\n        finishAnimDuration = Math.abs(_releaseAnimData.lastFlickSpeed.x) > 0 ? animateToDist / Math.abs(_releaseAnimData.lastFlickSpeed.x) : 333;\n        finishAnimDuration = Math.min(finishAnimDuration, 400);\n        finishAnimDuration = Math.max(finishAnimDuration, 250);\n      }\n\n      if (_currZoomedItemIndex === _currentItemIndex) {\n        itemChanged = false;\n      }\n\n      _mainScrollAnimating = true;\n\n      _shout('mainScrollAnimStart');\n\n      _animateProp('mainScroll', _mainScrollPos.x, animateToX, finishAnimDuration, framework.easing.cubic.out, _moveMainScroll, function () {\n        _stopAllAnimations();\n\n        _mainScrollAnimating = false;\n        _currZoomedItemIndex = -1;\n\n        if (itemChanged || _currZoomedItemIndex !== _currentItemIndex) {\n          self.updateCurrItem();\n        }\n\n        _shout('mainScrollAnimComplete');\n      });\n\n      if (itemChanged) {\n        self.updateCurrItem(true);\n      }\n\n      return itemChanged;\n    },\n        _calculateZoomLevel = function (touchesDistance) {\n      return 1 / _startPointsDistance * touchesDistance * _startZoomLevel;\n    },\n        // Resets zoom if it's out of bounds\n    _completeZoomGesture = function () {\n      var destZoomLevel = _currZoomLevel,\n          minZoomLevel = _getMinZoomLevel(),\n          maxZoomLevel = _getMaxZoomLevel();\n\n      if (_currZoomLevel < minZoomLevel) {\n        destZoomLevel = minZoomLevel;\n      } else if (_currZoomLevel > maxZoomLevel) {\n        destZoomLevel = maxZoomLevel;\n      }\n\n      var destOpacity = 1,\n          onUpdate,\n          initialOpacity = _bgOpacity;\n\n      if (_opacityChanged && !_isZoomingIn && !_wasOverInitialZoom && _currZoomLevel < minZoomLevel) {\n        //_closedByScroll = true;\n        self.close();\n        return true;\n      }\n\n      if (_opacityChanged) {\n        onUpdate = function (now) {\n          _applyBgOpacity((destOpacity - initialOpacity) * now + initialOpacity);\n        };\n      }\n\n      self.zoomTo(destZoomLevel, 0, 200, framework.easing.cubic.out, onUpdate);\n      return true;\n    };\n\n    _registerModule('Gestures', {\n      publicMethods: {\n        initGestures: function () {\n          // helper function that builds touch/pointer/mouse events\n          var addEventNames = function (pref, down, move, up, cancel) {\n            _dragStartEvent = pref + down;\n            _dragMoveEvent = pref + move;\n            _dragEndEvent = pref + up;\n\n            if (cancel) {\n              _dragCancelEvent = pref + cancel;\n            } else {\n              _dragCancelEvent = '';\n            }\n          };\n\n          _pointerEventEnabled = _features.pointerEvent;\n\n          if (_pointerEventEnabled && _features.touch) {\n            // we don't need touch events, if browser supports pointer events\n            _features.touch = false;\n          }\n\n          if (_pointerEventEnabled) {\n            if (navigator.msPointerEnabled) {\n              // IE10 pointer events are case-sensitive\n              addEventNames('MSPointer', 'Down', 'Move', 'Up', 'Cancel');\n            } else {\n              addEventNames('pointer', 'down', 'move', 'up', 'cancel');\n            }\n          } else if (_features.touch) {\n            addEventNames('touch', 'start', 'move', 'end', 'cancel');\n            _likelyTouchDevice = true;\n          } else {\n            addEventNames('mouse', 'down', 'move', 'up');\n          }\n\n          _upMoveEvents = _dragMoveEvent + ' ' + _dragEndEvent + ' ' + _dragCancelEvent;\n          _downEvents = _dragStartEvent;\n\n          if (_pointerEventEnabled && !_likelyTouchDevice) {\n            _likelyTouchDevice = navigator.maxTouchPoints > 1 || navigator.msMaxTouchPoints > 1;\n          } // make variable public\n\n\n          self.likelyTouchDevice = _likelyTouchDevice;\n          _globalEventHandlers[_dragStartEvent] = _onDragStart;\n          _globalEventHandlers[_dragMoveEvent] = _onDragMove;\n          _globalEventHandlers[_dragEndEvent] = _onDragRelease; // the Kraken\n\n          if (_dragCancelEvent) {\n            _globalEventHandlers[_dragCancelEvent] = _globalEventHandlers[_dragEndEvent];\n          } // Bind mouse events on device with detected hardware touch support, in case it supports multiple types of input.\n\n\n          if (_features.touch) {\n            _downEvents += ' mousedown';\n            _upMoveEvents += ' mousemove mouseup';\n            _globalEventHandlers.mousedown = _globalEventHandlers[_dragStartEvent];\n            _globalEventHandlers.mousemove = _globalEventHandlers[_dragMoveEvent];\n            _globalEventHandlers.mouseup = _globalEventHandlers[_dragEndEvent];\n          }\n\n          if (!_likelyTouchDevice) {\n            // don't allow pan to next slide from zoomed state on Desktop\n            _options.allowPanToNext = false;\n          }\n        }\n      }\n    });\n    /*>>gestures*/\n\n    /*>>show-hide-transition*/\n\n    /**\n     * show-hide-transition.js:\n     *\n     * Manages initial opening or closing transition.\n     *\n     * If you're not planning to use transition for gallery at all,\n     * you may set options hideAnimationDuration and showAnimationDuration to 0,\n     * and just delete startAnimation function.\n     * \n     */\n\n\n    var _showOrHideTimeout,\n        _showOrHide = function (item, img, out, completeFn) {\n      if (_showOrHideTimeout) {\n        clearTimeout(_showOrHideTimeout);\n      }\n\n      _initialZoomRunning = true;\n      _initialContentSet = true; // dimensions of small thumbnail {x:,y:,w:}.\n      // Height is optional, as calculated based on large image.\n\n      var thumbBounds;\n\n      if (item.initialLayout) {\n        thumbBounds = item.initialLayout;\n        item.initialLayout = null;\n      } else {\n        thumbBounds = _options.getThumbBoundsFn && _options.getThumbBoundsFn(_currentItemIndex);\n      }\n\n      var duration = out ? _options.hideAnimationDuration : _options.showAnimationDuration;\n\n      var onComplete = function () {\n        _stopAnimation('initialZoom');\n\n        if (!out) {\n          _applyBgOpacity(1);\n\n          if (img) {\n            img.style.display = 'block';\n          }\n\n          framework.addClass(template, 'pswp--animated-in');\n\n          _shout('initialZoom' + (out ? 'OutEnd' : 'InEnd'));\n        } else {\n          self.template.removeAttribute('style');\n          self.bg.removeAttribute('style');\n        }\n\n        if (completeFn) {\n          completeFn();\n        }\n\n        _initialZoomRunning = false;\n      }; // if bounds aren't provided, just open gallery without animation\n\n\n      if (!duration || !thumbBounds || thumbBounds.x === undefined) {\n        _shout('initialZoom' + (out ? 'Out' : 'In'));\n\n        _currZoomLevel = item.initialZoomLevel;\n\n        _equalizePoints(_panOffset, item.initialPosition);\n\n        _applyCurrentZoomPan();\n\n        template.style.opacity = out ? 0 : 1;\n\n        _applyBgOpacity(1);\n\n        if (duration) {\n          setTimeout(function () {\n            onComplete();\n          }, duration);\n        } else {\n          onComplete();\n        }\n\n        return;\n      }\n\n      var startAnimation = function () {\n        var closeWithRaf = _closedByScroll,\n            fadeEverything = !self.currItem.src || self.currItem.loadError || _options.showHideOpacity; // apply hw-acceleration to image\n\n        if (item.miniImg) {\n          item.miniImg.style.webkitBackfaceVisibility = 'hidden';\n        }\n\n        if (!out) {\n          _currZoomLevel = thumbBounds.w / item.w;\n          _panOffset.x = thumbBounds.x;\n          _panOffset.y = thumbBounds.y - _initalWindowScrollY;\n          self[fadeEverything ? 'template' : 'bg'].style.opacity = 0.001;\n\n          _applyCurrentZoomPan();\n        }\n\n        _registerStartAnimation('initialZoom');\n\n        if (out && !closeWithRaf) {\n          framework.removeClass(template, 'pswp--animated-in');\n        }\n\n        if (fadeEverything) {\n          if (out) {\n            framework[(closeWithRaf ? 'remove' : 'add') + 'Class'](template, 'pswp--animate_opacity');\n          } else {\n            setTimeout(function () {\n              framework.addClass(template, 'pswp--animate_opacity');\n            }, 30);\n          }\n        }\n\n        _showOrHideTimeout = setTimeout(function () {\n          _shout('initialZoom' + (out ? 'Out' : 'In'));\n\n          if (!out) {\n            // \"in\" animation always uses CSS transitions (instead of rAF).\n            // CSS transition work faster here, \n            // as developer may also want to animate other things, \n            // like ui on top of sliding area, which can be animated just via CSS\n            _currZoomLevel = item.initialZoomLevel;\n\n            _equalizePoints(_panOffset, item.initialPosition);\n\n            _applyCurrentZoomPan();\n\n            _applyBgOpacity(1);\n\n            if (fadeEverything) {\n              template.style.opacity = 1;\n            } else {\n              _applyBgOpacity(1);\n            }\n\n            _showOrHideTimeout = setTimeout(onComplete, duration + 20);\n          } else {\n            // \"out\" animation uses rAF only when PhotoSwipe is closed by browser scroll, to recalculate position\n            var destZoomLevel = thumbBounds.w / item.w,\n                initialPanOffset = {\n              x: _panOffset.x,\n              y: _panOffset.y\n            },\n                initialZoomLevel = _currZoomLevel,\n                initalBgOpacity = _bgOpacity,\n                onUpdate = function (now) {\n              if (now === 1) {\n                _currZoomLevel = destZoomLevel;\n                _panOffset.x = thumbBounds.x;\n                _panOffset.y = thumbBounds.y - _currentWindowScrollY;\n              } else {\n                _currZoomLevel = (destZoomLevel - initialZoomLevel) * now + initialZoomLevel;\n                _panOffset.x = (thumbBounds.x - initialPanOffset.x) * now + initialPanOffset.x;\n                _panOffset.y = (thumbBounds.y - _currentWindowScrollY - initialPanOffset.y) * now + initialPanOffset.y;\n              }\n\n              _applyCurrentZoomPan();\n\n              if (fadeEverything) {\n                template.style.opacity = 1 - now;\n              } else {\n                _applyBgOpacity(initalBgOpacity - now * initalBgOpacity);\n              }\n            };\n\n            if (closeWithRaf) {\n              _animateProp('initialZoom', 0, 1, duration, framework.easing.cubic.out, onUpdate, onComplete);\n            } else {\n              onUpdate(1);\n              _showOrHideTimeout = setTimeout(onComplete, duration + 20);\n            }\n          }\n        }, out ? 25 : 90); // Main purpose of this delay is to give browser time to paint and\n        // create composite layers of PhotoSwipe UI parts (background, controls, caption, arrows).\n        // Which avoids lag at the beginning of scale transition.\n      };\n\n      startAnimation();\n    };\n    /*>>show-hide-transition*/\n\n    /*>>items-controller*/\n\n    /**\n    *\n    * Controller manages gallery items, their dimensions, and their content.\n    * \n    */\n\n\n    var _items,\n        _tempPanAreaSize = {},\n        _imagesToAppendPool = [],\n        _initialContentSet,\n        _initialZoomRunning,\n        _controllerDefaultOptions = {\n      index: 0,\n      errorMsg: '<div class=\"pswp__error-msg\"><a href=\"%url%\" target=\"_blank\">The image</a> could not be loaded.</div>',\n      forceProgressiveLoading: false,\n      // TODO\n      preload: [1, 1],\n      getNumItemsFn: function () {\n        return _items.length;\n      }\n    };\n\n    var _getItemAt,\n        _getNumItems,\n        _initialIsLoop,\n        _getZeroBounds = function () {\n      return {\n        center: {\n          x: 0,\n          y: 0\n        },\n        max: {\n          x: 0,\n          y: 0\n        },\n        min: {\n          x: 0,\n          y: 0\n        }\n      };\n    },\n        _calculateSingleItemPanBounds = function (item, realPanElementW, realPanElementH) {\n      var bounds = item.bounds; // position of element when it's centered\n\n      bounds.center.x = Math.round((_tempPanAreaSize.x - realPanElementW) / 2);\n      bounds.center.y = Math.round((_tempPanAreaSize.y - realPanElementH) / 2) + item.vGap.top; // maximum pan position\n\n      bounds.max.x = realPanElementW > _tempPanAreaSize.x ? Math.round(_tempPanAreaSize.x - realPanElementW) : bounds.center.x;\n      bounds.max.y = realPanElementH > _tempPanAreaSize.y ? Math.round(_tempPanAreaSize.y - realPanElementH) + item.vGap.top : bounds.center.y; // minimum pan position\n\n      bounds.min.x = realPanElementW > _tempPanAreaSize.x ? 0 : bounds.center.x;\n      bounds.min.y = realPanElementH > _tempPanAreaSize.y ? item.vGap.top : bounds.center.y;\n    },\n        _calculateItemSize = function (item, viewportSize, zoomLevel) {\n      if (item.src && !item.loadError) {\n        var isInitial = !zoomLevel;\n\n        if (isInitial) {\n          if (!item.vGap) {\n            item.vGap = {\n              top: 0,\n              bottom: 0\n            };\n          } // allows overriding vertical margin for individual items\n\n\n          _shout('parseVerticalMargin', item);\n        }\n\n        _tempPanAreaSize.x = viewportSize.x;\n        _tempPanAreaSize.y = viewportSize.y - item.vGap.top - item.vGap.bottom;\n\n        if (isInitial) {\n          var hRatio = _tempPanAreaSize.x / item.w;\n          var vRatio = _tempPanAreaSize.y / item.h;\n          item.fitRatio = hRatio < vRatio ? hRatio : vRatio; //item.fillRatio = hRatio > vRatio ? hRatio : vRatio;\n\n          var scaleMode = _options.scaleMode;\n\n          if (scaleMode === 'orig') {\n            zoomLevel = 1;\n          } else if (scaleMode === 'fit') {\n            zoomLevel = item.fitRatio;\n          }\n\n          if (zoomLevel > 1) {\n            zoomLevel = 1;\n          }\n\n          item.initialZoomLevel = zoomLevel;\n\n          if (!item.bounds) {\n            // reuse bounds object\n            item.bounds = _getZeroBounds();\n          }\n        }\n\n        if (!zoomLevel) {\n          return;\n        }\n\n        _calculateSingleItemPanBounds(item, item.w * zoomLevel, item.h * zoomLevel);\n\n        if (isInitial && zoomLevel === item.initialZoomLevel) {\n          item.initialPosition = item.bounds.center;\n        }\n\n        return item.bounds;\n      } else {\n        item.w = item.h = 0;\n        item.initialZoomLevel = item.fitRatio = 1;\n        item.bounds = _getZeroBounds();\n        item.initialPosition = item.bounds.center; // if it's not image, we return zero bounds (content is not zoomable)\n\n        return item.bounds;\n      }\n    },\n        _appendImage = function (index, item, baseDiv, img, preventAnimation, keepPlaceholder) {\n      if (item.loadError) {\n        return;\n      }\n\n      if (img) {\n        item.imageAppended = true;\n\n        _setImageSize(item, img, item === self.currItem && _renderMaxResolution);\n\n        baseDiv.appendChild(img);\n\n        if (keepPlaceholder) {\n          setTimeout(function () {\n            if (item && item.loaded && item.placeholder) {\n              item.placeholder.style.display = 'none';\n              item.placeholder = null;\n            }\n          }, 500);\n        }\n      }\n    },\n        _preloadImage = function (item) {\n      item.loading = true;\n      item.loaded = false;\n      var img = item.img = framework.createEl('pswp__img', 'img');\n\n      var onComplete = function () {\n        item.loading = false;\n        item.loaded = true;\n\n        if (item.loadComplete) {\n          item.loadComplete(item);\n        } else {\n          item.img = null; // no need to store image object\n        }\n\n        img.onload = img.onerror = null;\n        img = null;\n      };\n\n      img.onload = onComplete;\n\n      img.onerror = function () {\n        item.loadError = true;\n        onComplete();\n      };\n\n      img.src = item.src; // + '?a=' + Math.random();\n\n      return img;\n    },\n        _checkForError = function (item, cleanUp) {\n      if (item.src && item.loadError && item.container) {\n        if (cleanUp) {\n          item.container.innerHTML = '';\n        }\n\n        item.container.innerHTML = _options.errorMsg.replace('%url%', item.src);\n        return true;\n      }\n    },\n        _setImageSize = function (item, img, maxRes) {\n      if (!item.src) {\n        return;\n      }\n\n      if (!img) {\n        img = item.container.lastChild;\n      }\n\n      var w = maxRes ? item.w : Math.round(item.w * item.fitRatio),\n          h = maxRes ? item.h : Math.round(item.h * item.fitRatio);\n\n      if (item.placeholder && !item.loaded) {\n        item.placeholder.style.width = w + 'px';\n        item.placeholder.style.height = h + 'px';\n      }\n\n      img.style.width = w + 'px';\n      img.style.height = h + 'px';\n    },\n        _appendImagesPool = function () {\n      if (_imagesToAppendPool.length) {\n        var poolItem;\n\n        for (var i = 0; i < _imagesToAppendPool.length; i++) {\n          poolItem = _imagesToAppendPool[i];\n\n          if (poolItem.holder.index === poolItem.index) {\n            _appendImage(poolItem.index, poolItem.item, poolItem.baseDiv, poolItem.img, false, poolItem.clearPlaceholder);\n          }\n        }\n\n        _imagesToAppendPool = [];\n      }\n    };\n\n    _registerModule('Controller', {\n      publicMethods: {\n        lazyLoadItem: function (index) {\n          index = _getLoopedId(index);\n\n          var item = _getItemAt(index);\n\n          if (!item || (item.loaded || item.loading) && !_itemsNeedUpdate) {\n            return;\n          }\n\n          _shout('gettingData', index, item);\n\n          if (!item.src) {\n            return;\n          }\n\n          _preloadImage(item);\n        },\n        initController: function () {\n          framework.extend(_options, _controllerDefaultOptions, true);\n          self.items = _items = items;\n          _getItemAt = self.getItemAt;\n          _getNumItems = _options.getNumItemsFn; //self.getNumItems;\n\n          _initialIsLoop = _options.loop;\n\n          if (_getNumItems() < 3) {\n            _options.loop = false; // disable loop if less then 3 items\n          }\n\n          _listen('beforeChange', function (diff) {\n            var p = _options.preload,\n                isNext = diff === null ? true : diff >= 0,\n                preloadBefore = Math.min(p[0], _getNumItems()),\n                preloadAfter = Math.min(p[1], _getNumItems()),\n                i;\n\n            for (i = 1; i <= (isNext ? preloadAfter : preloadBefore); i++) {\n              self.lazyLoadItem(_currentItemIndex + i);\n            }\n\n            for (i = 1; i <= (isNext ? preloadBefore : preloadAfter); i++) {\n              self.lazyLoadItem(_currentItemIndex - i);\n            }\n          });\n\n          _listen('initialLayout', function () {\n            self.currItem.initialLayout = _options.getThumbBoundsFn && _options.getThumbBoundsFn(_currentItemIndex);\n          });\n\n          _listen('mainScrollAnimComplete', _appendImagesPool);\n\n          _listen('initialZoomInEnd', _appendImagesPool);\n\n          _listen('destroy', function () {\n            var item;\n\n            for (var i = 0; i < _items.length; i++) {\n              item = _items[i]; // remove reference to DOM elements, for GC\n\n              if (item.container) {\n                item.container = null;\n              }\n\n              if (item.placeholder) {\n                item.placeholder = null;\n              }\n\n              if (item.img) {\n                item.img = null;\n              }\n\n              if (item.preloader) {\n                item.preloader = null;\n              }\n\n              if (item.loadError) {\n                item.loaded = item.loadError = false;\n              }\n            }\n\n            _imagesToAppendPool = null;\n          });\n        },\n        getItemAt: function (index) {\n          if (index >= 0) {\n            return _items[index] !== undefined ? _items[index] : false;\n          }\n\n          return false;\n        },\n        allowProgressiveImg: function () {\n          // 1. Progressive image loading isn't working on webkit/blink \n          //    when hw-acceleration (e.g. translateZ) is applied to IMG element.\n          //    That's why in PhotoSwipe parent element gets zoom transform, not image itself.\n          //    \n          // 2. Progressive image loading sometimes blinks in webkit/blink when applying animation to parent element.\n          //    That's why it's disabled on touch devices (mainly because of swipe transition)\n          //    \n          // 3. Progressive image loading sometimes doesn't work in IE (up to 11).\n          // Don't allow progressive loading on non-large touch devices\n          return _options.forceProgressiveLoading || !_likelyTouchDevice || _options.mouseUsed || screen.width > 1200; // 1200 - to eliminate touch devices with large screen (like Chromebook Pixel)\n        },\n        setContent: function (holder, index) {\n          if (_options.loop) {\n            index = _getLoopedId(index);\n          }\n\n          var prevItem = self.getItemAt(holder.index);\n\n          if (prevItem) {\n            prevItem.container = null;\n          }\n\n          var item = self.getItemAt(index),\n              img;\n\n          if (!item) {\n            holder.el.innerHTML = '';\n            return;\n          } // allow to override data\n\n\n          _shout('gettingData', index, item);\n\n          holder.index = index;\n          holder.item = item; // base container DIV is created only once for each of 3 holders\n\n          var baseDiv = item.container = framework.createEl('pswp__zoom-wrap');\n\n          if (!item.src && item.html) {\n            if (item.html.tagName) {\n              baseDiv.appendChild(item.html);\n            } else {\n              baseDiv.innerHTML = item.html;\n            }\n          }\n\n          _checkForError(item);\n\n          _calculateItemSize(item, _viewportSize);\n\n          if (item.src && !item.loadError && !item.loaded) {\n            item.loadComplete = function (item) {\n              // gallery closed before image finished loading\n              if (!_isOpen) {\n                return;\n              } // check if holder hasn't changed while image was loading\n\n\n              if (holder && holder.index === index) {\n                if (_checkForError(item, true)) {\n                  item.loadComplete = item.img = null;\n\n                  _calculateItemSize(item, _viewportSize);\n\n                  _applyZoomPanToItem(item);\n\n                  if (holder.index === _currentItemIndex) {\n                    // recalculate dimensions\n                    self.updateCurrZoomItem();\n                  }\n\n                  return;\n                }\n\n                if (!item.imageAppended) {\n                  if (_features.transform && (_mainScrollAnimating || _initialZoomRunning)) {\n                    _imagesToAppendPool.push({\n                      item: item,\n                      baseDiv: baseDiv,\n                      img: item.img,\n                      index: index,\n                      holder: holder,\n                      clearPlaceholder: true\n                    });\n                  } else {\n                    _appendImage(index, item, baseDiv, item.img, _mainScrollAnimating || _initialZoomRunning, true);\n                  }\n                } else {\n                  // remove preloader & mini-img\n                  if (!_initialZoomRunning && item.placeholder) {\n                    item.placeholder.style.display = 'none';\n                    item.placeholder = null;\n                  }\n                }\n              }\n\n              item.loadComplete = null;\n              item.img = null; // no need to store image element after it's added\n\n              _shout('imageLoadComplete', index, item);\n            };\n\n            if (framework.features.transform) {\n              var placeholderClassName = 'pswp__img pswp__img--placeholder';\n              placeholderClassName += item.msrc ? '' : ' pswp__img--placeholder--blank';\n              var placeholder = framework.createEl(placeholderClassName, item.msrc ? 'img' : '');\n\n              if (item.msrc) {\n                placeholder.src = item.msrc;\n              }\n\n              _setImageSize(item, placeholder);\n\n              baseDiv.appendChild(placeholder);\n              item.placeholder = placeholder;\n            }\n\n            if (!item.loading) {\n              _preloadImage(item);\n            }\n\n            if (self.allowProgressiveImg()) {\n              // just append image\n              if (!_initialContentSet && _features.transform) {\n                _imagesToAppendPool.push({\n                  item: item,\n                  baseDiv: baseDiv,\n                  img: item.img,\n                  index: index,\n                  holder: holder\n                });\n              } else {\n                _appendImage(index, item, baseDiv, item.img, true, true);\n              }\n            }\n          } else if (item.src && !item.loadError) {\n            // image object is created every time, due to bugs of image loading & delay when switching images\n            img = framework.createEl('pswp__img', 'img');\n            img.style.opacity = 1;\n            img.src = item.src;\n\n            _setImageSize(item, img);\n\n            _appendImage(index, item, baseDiv, img, true);\n          }\n\n          if (!_initialContentSet && index === _currentItemIndex) {\n            _currZoomElementStyle = baseDiv.style;\n\n            _showOrHide(item, img || item.img);\n          } else {\n            _applyZoomPanToItem(item);\n          }\n\n          holder.el.innerHTML = '';\n          holder.el.appendChild(baseDiv);\n        },\n        cleanSlide: function (item) {\n          if (item.img) {\n            item.img.onload = item.img.onerror = null;\n          }\n\n          item.loaded = item.loading = item.img = item.imageAppended = false;\n        }\n      }\n    });\n    /*>>items-controller*/\n\n    /*>>tap*/\n\n    /**\n     * tap.js:\n     *\n     * Displatches tap and double-tap events.\n     * \n     */\n\n\n    var tapTimer,\n        tapReleasePoint = {},\n        _dispatchTapEvent = function (origEvent, releasePoint, pointerType) {\n      var e = document.createEvent('CustomEvent'),\n          eDetail = {\n        origEvent: origEvent,\n        target: origEvent.target,\n        releasePoint: releasePoint,\n        pointerType: pointerType || 'touch'\n      };\n      e.initCustomEvent('pswpTap', true, true, eDetail);\n      origEvent.target.dispatchEvent(e);\n    };\n\n    _registerModule('Tap', {\n      publicMethods: {\n        initTap: function () {\n          _listen('firstTouchStart', self.onTapStart);\n\n          _listen('touchRelease', self.onTapRelease);\n\n          _listen('destroy', function () {\n            tapReleasePoint = {};\n            tapTimer = null;\n          });\n        },\n        onTapStart: function (touchList) {\n          if (touchList.length > 1) {\n            clearTimeout(tapTimer);\n            tapTimer = null;\n          }\n        },\n        onTapRelease: function (e, releasePoint) {\n          if (!releasePoint) {\n            return;\n          }\n\n          if (!_moved && !_isMultitouch && !_numAnimations) {\n            var p0 = releasePoint;\n\n            if (tapTimer) {\n              clearTimeout(tapTimer);\n              tapTimer = null; // Check if taped on the same place\n\n              if (_isNearbyPoints(p0, tapReleasePoint)) {\n                _shout('doubleTap', p0);\n\n                return;\n              }\n            }\n\n            if (releasePoint.type === 'mouse') {\n              _dispatchTapEvent(e, releasePoint, 'mouse');\n\n              return;\n            }\n\n            var clickedTagName = e.target.tagName.toUpperCase(); // avoid double tap delay on buttons and elements that have class pswp__single-tap\n\n            if (clickedTagName === 'BUTTON' || framework.hasClass(e.target, 'pswp__single-tap')) {\n              _dispatchTapEvent(e, releasePoint);\n\n              return;\n            }\n\n            _equalizePoints(tapReleasePoint, p0);\n\n            tapTimer = setTimeout(function () {\n              _dispatchTapEvent(e, releasePoint);\n\n              tapTimer = null;\n            }, 300);\n          }\n        }\n      }\n    });\n    /*>>tap*/\n\n    /*>>desktop-zoom*/\n\n    /**\n     *\n     * desktop-zoom.js:\n     *\n     * - Binds mousewheel event for paning zoomed image.\n     * - Manages \"dragging\", \"zoomed-in\", \"zoom-out\" classes.\n     *   (which are used for cursors and zoom icon)\n     * - Adds toggleDesktopZoom function.\n     * \n     */\n\n\n    var _wheelDelta;\n\n    _registerModule('DesktopZoom', {\n      publicMethods: {\n        initDesktopZoom: function () {\n          if (_oldIE) {\n            // no zoom for old IE (<=8)\n            return;\n          }\n\n          if (_likelyTouchDevice) {\n            // if detected hardware touch support, we wait until mouse is used,\n            // and only then apply desktop-zoom features\n            _listen('mouseUsed', function () {\n              self.setupDesktopZoom();\n            });\n          } else {\n            self.setupDesktopZoom(true);\n          }\n        },\n        setupDesktopZoom: function (onInit) {\n          _wheelDelta = {};\n          var events = 'wheel mousewheel DOMMouseScroll';\n\n          _listen('bindEvents', function () {\n            framework.bind(template, events, self.handleMouseWheel);\n          });\n\n          _listen('unbindEvents', function () {\n            if (_wheelDelta) {\n              framework.unbind(template, events, self.handleMouseWheel);\n            }\n          });\n\n          self.mouseZoomedIn = false;\n\n          var hasDraggingClass,\n              updateZoomable = function () {\n            if (self.mouseZoomedIn) {\n              framework.removeClass(template, 'pswp--zoomed-in');\n              self.mouseZoomedIn = false;\n            }\n\n            if (_currZoomLevel < 1) {\n              framework.addClass(template, 'pswp--zoom-allowed');\n            } else {\n              framework.removeClass(template, 'pswp--zoom-allowed');\n            }\n\n            removeDraggingClass();\n          },\n              removeDraggingClass = function () {\n            if (hasDraggingClass) {\n              framework.removeClass(template, 'pswp--dragging');\n              hasDraggingClass = false;\n            }\n          };\n\n          _listen('resize', updateZoomable);\n\n          _listen('afterChange', updateZoomable);\n\n          _listen('pointerDown', function () {\n            if (self.mouseZoomedIn) {\n              hasDraggingClass = true;\n              framework.addClass(template, 'pswp--dragging');\n            }\n          });\n\n          _listen('pointerUp', removeDraggingClass);\n\n          if (!onInit) {\n            updateZoomable();\n          }\n        },\n        handleMouseWheel: function (e) {\n          if (_currZoomLevel <= self.currItem.fitRatio) {\n            if (_options.modal) {\n              if (!_options.closeOnScroll || _numAnimations || _isDragging) {\n                e.preventDefault();\n              } else if (_transformKey && Math.abs(e.deltaY) > 2) {\n                // close PhotoSwipe\n                // if browser supports transforms & scroll changed enough\n                _closedByScroll = true;\n                self.close();\n              }\n            }\n\n            return true;\n          } // allow just one event to fire\n\n\n          e.stopPropagation(); // https://developer.mozilla.org/en-US/docs/Web/Events/wheel\n\n          _wheelDelta.x = 0;\n\n          if ('deltaX' in e) {\n            if (e.deltaMode === 1\n            /* DOM_DELTA_LINE */\n            ) {\n                // 18 - average line height\n                _wheelDelta.x = e.deltaX * 18;\n                _wheelDelta.y = e.deltaY * 18;\n              } else {\n              _wheelDelta.x = e.deltaX;\n              _wheelDelta.y = e.deltaY;\n            }\n          } else if ('wheelDelta' in e) {\n            if (e.wheelDeltaX) {\n              _wheelDelta.x = -0.16 * e.wheelDeltaX;\n            }\n\n            if (e.wheelDeltaY) {\n              _wheelDelta.y = -0.16 * e.wheelDeltaY;\n            } else {\n              _wheelDelta.y = -0.16 * e.wheelDelta;\n            }\n          } else if ('detail' in e) {\n            _wheelDelta.y = e.detail;\n          } else {\n            return;\n          }\n\n          _calculatePanBounds(_currZoomLevel, true);\n\n          var newPanX = _panOffset.x - _wheelDelta.x,\n              newPanY = _panOffset.y - _wheelDelta.y; // only prevent scrolling in nonmodal mode when not at edges\n\n          if (_options.modal || newPanX <= _currPanBounds.min.x && newPanX >= _currPanBounds.max.x && newPanY <= _currPanBounds.min.y && newPanY >= _currPanBounds.max.y) {\n            e.preventDefault();\n          } // TODO: use rAF instead of mousewheel?\n\n\n          self.panTo(newPanX, newPanY);\n        },\n        toggleDesktopZoom: function (centerPoint) {\n          centerPoint = centerPoint || {\n            x: _viewportSize.x / 2 + _offset.x,\n            y: _viewportSize.y / 2 + _offset.y\n          };\n\n          var doubleTapZoomLevel = _options.getDoubleTapZoom(true, self.currItem);\n\n          var zoomOut = _currZoomLevel === doubleTapZoomLevel;\n          self.mouseZoomedIn = !zoomOut;\n          self.zoomTo(zoomOut ? self.currItem.initialZoomLevel : doubleTapZoomLevel, centerPoint, 333);\n          framework[(!zoomOut ? 'add' : 'remove') + 'Class'](template, 'pswp--zoomed-in');\n        }\n      }\n    });\n    /*>>desktop-zoom*/\n\n    /*>>history*/\n\n    /**\n     *\n     * history.js:\n     *\n     * - Back button to close gallery.\n     * \n     * - Unique URL for each slide: example.com/&pid=1&gid=3\n     *   (where PID is picture index, and GID and gallery index)\n     *   \n     * - Switch URL when slides change.\n     * \n     */\n\n\n    var _historyDefaultOptions = {\n      history: true,\n      galleryUID: 1\n    };\n\n    var _historyUpdateTimeout,\n        _hashChangeTimeout,\n        _hashAnimCheckTimeout,\n        _hashChangedByScript,\n        _hashChangedByHistory,\n        _hashReseted,\n        _initialHash,\n        _historyChanged,\n        _closedFromURL,\n        _urlChangedOnce,\n        _windowLoc,\n        _supportsPushState,\n        _getHash = function () {\n      return _windowLoc.hash.substring(1);\n    },\n        _cleanHistoryTimeouts = function () {\n      if (_historyUpdateTimeout) {\n        clearTimeout(_historyUpdateTimeout);\n      }\n\n      if (_hashAnimCheckTimeout) {\n        clearTimeout(_hashAnimCheckTimeout);\n      }\n    },\n        // pid - Picture index\n    // gid - Gallery index\n    _parseItemIndexFromURL = function () {\n      var hash = _getHash(),\n          params = {};\n\n      if (hash.length < 5) {\n        // pid=1\n        return params;\n      }\n\n      var i,\n          vars = hash.split('&');\n\n      for (i = 0; i < vars.length; i++) {\n        if (!vars[i]) {\n          continue;\n        }\n\n        var pair = vars[i].split('=');\n\n        if (pair.length < 2) {\n          continue;\n        }\n\n        params[pair[0]] = pair[1];\n      }\n\n      if (_options.galleryPIDs) {\n        // detect custom pid in hash and search for it among the items collection\n        var searchfor = params.pid;\n        params.pid = 0; // if custom pid cannot be found, fallback to the first item\n\n        for (i = 0; i < _items.length; i++) {\n          if (_items[i].pid === searchfor) {\n            params.pid = i;\n            break;\n          }\n        }\n      } else {\n        params.pid = parseInt(params.pid, 10) - 1;\n      }\n\n      if (params.pid < 0) {\n        params.pid = 0;\n      }\n\n      return params;\n    },\n        _updateHash = function () {\n      if (_hashAnimCheckTimeout) {\n        clearTimeout(_hashAnimCheckTimeout);\n      }\n\n      if (_numAnimations || _isDragging) {\n        // changing browser URL forces layout/paint in some browsers, which causes noticable lag during animation\n        // that's why we update hash only when no animations running\n        _hashAnimCheckTimeout = setTimeout(_updateHash, 500);\n        return;\n      }\n\n      if (_hashChangedByScript) {\n        clearTimeout(_hashChangeTimeout);\n      } else {\n        _hashChangedByScript = true;\n      }\n\n      var pid = _currentItemIndex + 1;\n\n      var item = _getItemAt(_currentItemIndex);\n\n      if (item.hasOwnProperty('pid')) {\n        // carry forward any custom pid assigned to the item\n        pid = item.pid;\n      }\n\n      var newHash = _initialHash + '&' + 'gid=' + _options.galleryUID + '&' + 'pid=' + pid;\n\n      if (!_historyChanged) {\n        if (_windowLoc.hash.indexOf(newHash) === -1) {\n          _urlChangedOnce = true;\n        } // first time - add new hisory record, then just replace\n\n      }\n\n      var newURL = _windowLoc.href.split('#')[0] + '#' + newHash;\n\n      if (_supportsPushState) {\n        if ('#' + newHash !== window.location.hash) {\n          history[_historyChanged ? 'replaceState' : 'pushState']('', document.title, newURL);\n        }\n      } else {\n        if (_historyChanged) {\n          _windowLoc.replace(newURL);\n        } else {\n          _windowLoc.hash = newHash;\n        }\n      }\n\n      _historyChanged = true;\n      _hashChangeTimeout = setTimeout(function () {\n        _hashChangedByScript = false;\n      }, 60);\n    };\n\n    _registerModule('History', {\n      publicMethods: {\n        initHistory: function () {\n          framework.extend(_options, _historyDefaultOptions, true);\n\n          if (!_options.history) {\n            return;\n          }\n\n          _windowLoc = window.location;\n          _urlChangedOnce = false;\n          _closedFromURL = false;\n          _historyChanged = false;\n          _initialHash = _getHash();\n          _supportsPushState = 'pushState' in history;\n\n          if (_initialHash.indexOf('gid=') > -1) {\n            _initialHash = _initialHash.split('&gid=')[0];\n            _initialHash = _initialHash.split('?gid=')[0];\n          }\n\n          _listen('afterChange', self.updateURL);\n\n          _listen('unbindEvents', function () {\n            framework.unbind(window, 'hashchange', self.onHashChange);\n          });\n\n          var returnToOriginal = function () {\n            _hashReseted = true;\n\n            if (!_closedFromURL) {\n              if (_urlChangedOnce) {\n                history.back();\n              } else {\n                if (_initialHash) {\n                  _windowLoc.hash = _initialHash;\n                } else {\n                  if (_supportsPushState) {\n                    // remove hash from url without refreshing it or scrolling to top\n                    history.pushState('', document.title, _windowLoc.pathname + _windowLoc.search);\n                  } else {\n                    _windowLoc.hash = '';\n                  }\n                }\n              }\n            }\n\n            _cleanHistoryTimeouts();\n          };\n\n          _listen('unbindEvents', function () {\n            if (_closedByScroll) {\n              // if PhotoSwipe is closed by scroll, we go \"back\" before the closing animation starts\n              // this is done to keep the scroll position\n              returnToOriginal();\n            }\n          });\n\n          _listen('destroy', function () {\n            if (!_hashReseted) {\n              returnToOriginal();\n            }\n          });\n\n          _listen('firstUpdate', function () {\n            _currentItemIndex = _parseItemIndexFromURL().pid;\n          });\n\n          var index = _initialHash.indexOf('pid=');\n\n          if (index > -1) {\n            _initialHash = _initialHash.substring(0, index);\n\n            if (_initialHash.slice(-1) === '&') {\n              _initialHash = _initialHash.slice(0, -1);\n            }\n          }\n\n          setTimeout(function () {\n            if (_isOpen) {\n              // hasn't destroyed yet\n              framework.bind(window, 'hashchange', self.onHashChange);\n            }\n          }, 40);\n        },\n        onHashChange: function () {\n          if (_getHash() === _initialHash) {\n            _closedFromURL = true;\n            self.close();\n            return;\n          }\n\n          if (!_hashChangedByScript) {\n            _hashChangedByHistory = true;\n            self.goTo(_parseItemIndexFromURL().pid);\n            _hashChangedByHistory = false;\n          }\n        },\n        updateURL: function () {\n          // Delay the update of URL, to avoid lag during transition, \n          // and to not to trigger actions like \"refresh page sound\" or \"blinking favicon\" to often\n          _cleanHistoryTimeouts();\n\n          if (_hashChangedByHistory) {\n            return;\n          }\n\n          if (!_historyChanged) {\n            _updateHash(); // first time\n\n          } else {\n            _historyUpdateTimeout = setTimeout(_updateHash, 800);\n          }\n        }\n      }\n    });\n    /*>>history*/\n\n\n    framework.extend(self, publicMethods);\n  };\n\n  return PhotoSwipe;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGhvdG9zd2lwZS9kaXN0L3Bob3Rvc3dpcGUuanM/YjI0ZiJdLCJuYW1lcyI6WyJyb290IiwiZmFjdG9yeSIsImRlZmluZSIsIlBob3RvU3dpcGUiLCJ0ZW1wbGF0ZSIsIlVpQ2xhc3MiLCJpdGVtcyIsIm9wdGlvbnMiLCJmcmFtZXdvcmsiLCJmZWF0dXJlcyIsImJpbmQiLCJ0YXJnZXQiLCJ0eXBlIiwibGlzdGVuZXIiLCJ1bmJpbmQiLCJtZXRob2ROYW1lIiwic3BsaXQiLCJpIiwibGVuZ3RoIiwiaXNBcnJheSIsIm9iaiIsIkFycmF5IiwiY3JlYXRlRWwiLCJjbGFzc2VzIiwidGFnIiwiZWwiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJnZXRTY3JvbGxZIiwieU9mZnNldCIsIndpbmRvdyIsInBhZ2VZT2Zmc2V0IiwidW5kZWZpbmVkIiwiZG9jdW1lbnRFbGVtZW50Iiwic2Nyb2xsVG9wIiwicmVtb3ZlQ2xhc3MiLCJyZWciLCJSZWdFeHAiLCJyZXBsYWNlIiwiYWRkQ2xhc3MiLCJoYXNDbGFzcyIsInRlc3QiLCJnZXRDaGlsZEJ5Q2xhc3MiLCJwYXJlbnRFbCIsImNoaWxkQ2xhc3NOYW1lIiwibm9kZSIsImZpcnN0Q2hpbGQiLCJuZXh0U2libGluZyIsImFycmF5U2VhcmNoIiwiYXJyYXkiLCJ2YWx1ZSIsImtleSIsImV4dGVuZCIsIm8xIiwibzIiLCJwcmV2ZW50T3ZlcndyaXRlIiwicHJvcCIsImhhc093blByb3BlcnR5IiwiZWFzaW5nIiwic2luZSIsIm91dCIsImsiLCJNYXRoIiwic2luIiwiUEkiLCJpbk91dCIsImNvcyIsImN1YmljIiwiZGV0ZWN0RmVhdHVyZXMiLCJoZWxwZXJFbCIsImhlbHBlclN0eWxlIiwic3R5bGUiLCJ2ZW5kb3IiLCJvbGRJRSIsImFsbCIsImFkZEV2ZW50TGlzdGVuZXIiLCJ0b3VjaCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJhZiIsImNhZiIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicG9pbnRlckV2ZW50IiwiUG9pbnRlckV2ZW50IiwibmF2aWdhdG9yIiwibXNQb2ludGVyRW5hYmxlZCIsInVhIiwidXNlckFnZW50IiwicGxhdGZvcm0iLCJ2IiwiYXBwVmVyc2lvbiIsIm1hdGNoIiwicGFyc2VJbnQiLCJpc09sZElPU1Bob25lIiwiYW5kcm9pZHZlcnNpb24iLCJwYXJzZUZsb2F0IiwiaXNPbGRBbmRyb2lkIiwiYW5kcm9pZFZlcnNpb24iLCJpc01vYmlsZU9wZXJhIiwic3R5bGVDaGVja3MiLCJ2ZW5kb3JzIiwic3R5bGVDaGVja0l0ZW0iLCJzdHlsZU5hbWUiLCJhIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzbGljZSIsInRvTG93ZXJDYXNlIiwibGFzdFRpbWUiLCJmbiIsImN1cnJUaW1lIiwiRGF0ZSIsImdldFRpbWUiLCJ0aW1lVG9DYWxsIiwibWF4IiwiaWQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0Iiwic3ZnIiwiY3JlYXRlRWxlbWVudE5TIiwiY3JlYXRlU1ZHUmVjdCIsImV2TmFtZSIsIl9oYW5kbGVFdiIsImhhbmRsZUV2ZW50IiwiY2FsbCIsInNlbGYiLCJET1VCTEVfVEFQX1JBRElVUyIsIk5VTV9IT0xERVJTIiwiX29wdGlvbnMiLCJhbGxvd1BhblRvTmV4dCIsInNwYWNpbmciLCJiZ09wYWNpdHkiLCJtb3VzZVVzZWQiLCJsb29wIiwicGluY2hUb0Nsb3NlIiwiY2xvc2VPblNjcm9sbCIsImNsb3NlT25WZXJ0aWNhbERyYWciLCJ2ZXJ0aWNhbERyYWdSYW5nZSIsImhpZGVBbmltYXRpb25EdXJhdGlvbiIsInNob3dBbmltYXRpb25EdXJhdGlvbiIsInNob3dIaWRlT3BhY2l0eSIsImZvY3VzIiwiZXNjS2V5IiwiYXJyb3dLZXlzIiwibWFpblNjcm9sbEVuZEZyaWN0aW9uIiwicGFuRW5kRnJpY3Rpb24iLCJpc0NsaWNrYWJsZUVsZW1lbnQiLCJ0YWdOYW1lIiwiZ2V0RG91YmxlVGFwWm9vbSIsImlzTW91c2VDbGljayIsIml0ZW0iLCJpbml0aWFsWm9vbUxldmVsIiwibWF4U3ByZWFkWm9vbSIsIm1vZGFsIiwic2NhbGVNb2RlIiwiX2dldEVtcHR5UG9pbnQiLCJ4IiwieSIsIl9pc09wZW4iLCJfaXNEZXN0cm95aW5nIiwiX2Nsb3NlZEJ5U2Nyb2xsIiwiX2N1cnJlbnRJdGVtSW5kZXgiLCJfY29udGFpbmVyU3R5bGUiLCJfY29udGFpbmVyU2hpZnRJbmRleCIsIl9jdXJyUGFuRGlzdCIsIl9zdGFydFBhbk9mZnNldCIsIl9wYW5PZmZzZXQiLCJfdXBNb3ZlRXZlbnRzIiwiX2Rvd25FdmVudHMiLCJfZ2xvYmFsRXZlbnRIYW5kbGVycyIsIl92aWV3cG9ydFNpemUiLCJfY3Vyclpvb21MZXZlbCIsIl9zdGFydFpvb21MZXZlbCIsIl90cmFuc2xhdGVQcmVmaXgiLCJfdHJhbnNsYXRlU3VmaXgiLCJfdXBkYXRlU2l6ZUludGVydmFsIiwiX2l0ZW1zTmVlZFVwZGF0ZSIsIl9jdXJyUG9zaXRpb25JbmRleCIsIl9vZmZzZXQiLCJfc2xpZGVTaXplIiwiX2l0ZW1Ib2xkZXJzIiwiX3ByZXZJdGVtSW5kZXgiLCJfaW5kZXhEaWZmIiwiX2RyYWdTdGFydEV2ZW50IiwiX2RyYWdNb3ZlRXZlbnQiLCJfZHJhZ0VuZEV2ZW50IiwiX2RyYWdDYW5jZWxFdmVudCIsIl90cmFuc2Zvcm1LZXkiLCJfcG9pbnRlckV2ZW50RW5hYmxlZCIsIl9pc0ZpeGVkUG9zaXRpb24iLCJfbGlrZWx5VG91Y2hEZXZpY2UiLCJfbW9kdWxlcyIsIl9yZXF1ZXN0QUYiLCJfY2FuY2VsQUYiLCJfaW5pdGFsQ2xhc3NOYW1lIiwiX2luaXRhbFdpbmRvd1Njcm9sbFkiLCJfb2xkSUUiLCJfY3VycmVudFdpbmRvd1Njcm9sbFkiLCJfZmVhdHVyZXMiLCJfd2luZG93VmlzaWJsZVNpemUiLCJfcmVuZGVyTWF4UmVzb2x1dGlvbiIsIl9vcmllbnRhdGlvbkNoYW5nZVRpbWVvdXQiLCJfcmVnaXN0ZXJNb2R1bGUiLCJuYW1lIiwibW9kdWxlIiwicHVibGljTWV0aG9kcyIsInB1c2giLCJfZ2V0TG9vcGVkSWQiLCJpbmRleCIsIm51bVNsaWRlcyIsIl9nZXROdW1JdGVtcyIsIl9saXN0ZW5lcnMiLCJfbGlzdGVuIiwiX3Nob3V0IiwibGlzdGVuZXJzIiwiYXJncyIsInByb3RvdHlwZSIsImFyZ3VtZW50cyIsInNoaWZ0IiwiYXBwbHkiLCJfZ2V0Q3VycmVudFRpbWUiLCJfYXBwbHlCZ09wYWNpdHkiLCJvcGFjaXR5IiwiX2JnT3BhY2l0eSIsImJnIiwiX2FwcGx5Wm9vbVRyYW5zZm9ybSIsInN0eWxlT2JqIiwiem9vbSIsImN1cnJJdGVtIiwiZml0UmF0aW8iLCJfYXBwbHlDdXJyZW50Wm9vbVBhbiIsImFsbG93UmVuZGVyUmVzb2x1dGlvbiIsIl9jdXJyWm9vbUVsZW1lbnRTdHlsZSIsIl9zZXRJbWFnZVNpemUiLCJfYXBwbHlab29tUGFuVG9JdGVtIiwiY29udGFpbmVyIiwiaW5pdGlhbFBvc2l0aW9uIiwiX3NldFRyYW5zbGF0ZVgiLCJlbFN0eWxlIiwiX21vdmVNYWluU2Nyb2xsIiwiZHJhZ2dpbmciLCJuZXdTbGlkZUluZGV4T2Zmc2V0IiwiZGVsdGEiLCJyb3VuZCIsIl9tYWluU2Nyb2xsUG9zIiwiX2NhbGN1bGF0ZVBhbk9mZnNldCIsImF4aXMiLCJ6b29tTGV2ZWwiLCJtIiwiX21pZFpvb21Qb2ludCIsIl9lcXVhbGl6ZVBvaW50cyIsInAxIiwicDIiLCJfcm91bmRQb2ludCIsInAiLCJfbW91c2VNb3ZlVGltZW91dCIsIl9vbkZpcnN0TW91c2VNb3ZlIiwiX2JpbmRFdmVudHMiLCJ0cmFuc2Zvcm0iLCJzY3JvbGxXcmFwIiwiX3VuYmluZEV2ZW50cyIsInNjcm9sbCIsIl9pc0RyYWdnaW5nIiwiX2NhbGN1bGF0ZVBhbkJvdW5kcyIsInVwZGF0ZSIsImJvdW5kcyIsIl9jYWxjdWxhdGVJdGVtU2l6ZSIsIl9jdXJyUGFuQm91bmRzIiwiX2dldE1pblpvb21MZXZlbCIsIl9nZXRNYXhab29tTGV2ZWwiLCJ3IiwiX21vZGlmeURlc3RQYW5PZmZzZXQiLCJkZXN0UGFuQm91bmRzIiwiZGVzdFBhbk9mZnNldCIsImRlc3Rab29tTGV2ZWwiLCJtaW4iLCJfc2V0dXBUcmFuc2Zvcm1zIiwiYWxsb3czZFRyYW5zZm9ybSIsInBlcnNwZWN0aXZlIiwibGVmdCIsInpvb21SYXRpbyIsInMiLCJoIiwid2lkdGgiLCJoZWlnaHQiLCJ0b3AiLCJfb25LZXlEb3duIiwiZSIsImtleWRvd25BY3Rpb24iLCJrZXlDb2RlIiwiY3RybEtleSIsImFsdEtleSIsInNoaWZ0S2V5IiwibWV0YUtleSIsInByZXZlbnREZWZhdWx0IiwicmV0dXJuVmFsdWUiLCJfb25HbG9iYWxDbGljayIsIl9tb3ZlZCIsIl96b29tU3RhcnRlZCIsIl9tYWluU2Nyb2xsQW5pbWF0aW5nIiwiX3ZlcnRpY2FsRHJhZ0luaXRpYXRlZCIsInN0b3BQcm9wYWdhdGlvbiIsIl91cGRhdGVQYWdlU2Nyb2xsT2Zmc2V0Iiwic2V0U2Nyb2xsT2Zmc2V0IiwiX2FuaW1hdGlvbnMiLCJfbnVtQW5pbWF0aW9ucyIsIl9zdG9wQW5pbWF0aW9uIiwiX3JlZ2lzdGVyU3RhcnRBbmltYXRpb24iLCJfc3RvcEFsbEFuaW1hdGlvbnMiLCJfYW5pbWF0ZVByb3AiLCJiIiwiZW5kUHJvcCIsImQiLCJlYXNpbmdGbiIsIm9uVXBkYXRlIiwib25Db21wbGV0ZSIsInN0YXJ0QW5pbVRpbWUiLCJ0IiwiYW5pbWxvb3AiLCJzaG91dCIsImxpc3RlbiIsInZpZXdwb3J0U2l6ZSIsImlzTWFpblNjcm9sbEFuaW1hdGluZyIsImdldFpvb21MZXZlbCIsImdldEN1cnJlbnRJbmRleCIsImlzRHJhZ2dpbmciLCJpc1pvb21pbmciLCJfaXNab29taW5nIiwiYXBwbHlab29tUGFuIiwicGFuWCIsInBhblkiLCJpbml0IiwiaXRlbUhvbGRlcnMiLCJjaGlsZHJlbiIsIndyYXAiLCJkaXNwbGF5IiwicmVzaXplIiwidXBkYXRlU2l6ZSIsIm9yaWVudGF0aW9uY2hhbmdlIiwiY2xpZW50V2lkdGgiLCJrZXlkb3duIiwiY2xpY2siLCJvbGRQaG9uZSIsImFuaW1hdGlvbk5hbWUiLCJ1aSIsImlzTmFOIiwiX2dldEl0ZW1BdCIsInNldEF0dHJpYnV0ZSIsInBvc2l0aW9uIiwicm9vdENsYXNzZXMiLCJtYWluQ2xhc3MiLCJzZXRDb250ZW50IiwidXBkYXRlQ3Vyckl0ZW0iLCJzZXRJbnRlcnZhbCIsImNsb3NlIiwiX3Nob3dPckhpZGUiLCJkZXN0cm95IiwiX3Nob3dPckhpZGVUaW1lb3V0IiwiY2xlYXJJbnRlcnZhbCIsIl9zdG9wRHJhZ1VwZGF0ZUxvb3AiLCJwYW5UbyIsImZvcmNlIiwiZXZlbnQiLCJnb1RvIiwiZGlmZiIsIm5leHQiLCJwcmV2IiwidXBkYXRlQ3Vyclpvb21JdGVtIiwiZW11bGF0ZVNldENvbnRlbnQiLCJ6b29tRWxlbWVudCIsImNlbnRlciIsImludmFsaWRhdGVDdXJySXRlbXMiLCJuZWVkc1VwZGF0ZSIsImJlZm9yZUFuaW1hdGlvbiIsImRpZmZBYnMiLCJhYnMiLCJ0ZW1wSG9sZGVyIiwicG9wIiwidW5zaGlmdCIsInByZXZJdGVtIiwid2luZG93U2Nyb2xsWSIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsImNsaWVudEhlaWdodCIsImhvbGRlciIsImhJbmRleCIsImNsZWFuU2xpZGUiLCJ6b29tVG8iLCJjZW50ZXJQb2ludCIsInNwZWVkIiwidXBkYXRlRm4iLCJpbml0aWFsUGFuT2Zmc2V0Iiwibm93IiwiTUlOX1NXSVBFX0RJU1RBTkNFIiwiRElSRUNUSU9OX0NIRUNLX09GRlNFVCIsIl9nZXN0dXJlU3RhcnRUaW1lIiwiX2dlc3R1cmVDaGVja1NwZWVkVGltZSIsIl9jdXJyUG9pbnQiLCJfc3RhcnRQb2ludCIsIl9jdXJyUG9pbnRlcnMiLCJfc3RhcnRNYWluU2Nyb2xsUG9zIiwiX3JlbGVhc2VBbmltRGF0YSIsIl9wb3NQb2ludHMiLCJfdGVtcFBvaW50IiwiX2lzWm9vbWluZ0luIiwiX29sZEFuZHJvaWRUb3VjaEVuZFRpbWVvdXQiLCJfY3Vyclpvb21lZEl0ZW1JbmRleCIsIl9jZW50ZXJQb2ludCIsIl9sYXN0UmVsZWFzZVRpbWUiLCJfaXNNdWx0aXRvdWNoIiwiX2RyYWdBbmltRnJhbWUiLCJfbWFpblNjcm9sbFNoaWZ0ZWQiLCJfY3VycmVudFBvaW50cyIsIl9jdXJyUG9pbnRzRGlzdGFuY2UiLCJfc3RhcnRQb2ludHNEaXN0YW5jZSIsIl9jdXJyQ2VudGVyUG9pbnQiLCJfZGlyZWN0aW9uIiwiX2lzRmlyc3RNb3ZlIiwiX29wYWNpdHlDaGFuZ2VkIiwiX3dhc092ZXJJbml0aWFsWm9vbSIsIl9pc0VxdWFsUG9pbnRzIiwiX2lzTmVhcmJ5UG9pbnRzIiwidG91Y2gwIiwidG91Y2gxIiwiX2NhbGN1bGF0ZVBvaW50c0Rpc3RhbmNlIiwic3FydCIsIl9kcmFnVXBkYXRlTG9vcCIsIl9yZW5kZXJNb3ZlbWVudCIsIl9jYW5QYW4iLCJfY2xvc2VzdEVsZW1lbnQiLCJnZXRBdHRyaWJ1dGUiLCJpbmRleE9mIiwicGFyZW50Tm9kZSIsIl9wcmV2ZW50T2JqIiwiX3ByZXZlbnREZWZhdWx0RXZlbnRCZWhhdmlvdXIiLCJpc0Rvd24iLCJwcmV2ZW50IiwiX2NvbnZlcnRUb3VjaFRvUG9pbnQiLCJwYWdlWCIsInBhZ2VZIiwiaWRlbnRpZmllciIsIl9maW5kQ2VudGVyT2ZQb2ludHMiLCJwQ2VudGVyIiwiX3B1c2hQb3NQb2ludCIsInRpbWUiLCJvIiwiX2NhbGN1bGF0ZVZlcnRpY2FsRHJhZ09wYWNpdHlSYXRpbyIsIl9lUG9pbnQxIiwiX2VQb2ludDIiLCJfdGVtcFBvaW50c0FyciIsIl90ZW1wQ291bnRlciIsIl9nZXRUb3VjaFBvaW50cyIsInRvdWNoZXMiLCJmb3JFYWNoIiwiX3Bhbk9yTW92ZU1haW5TY3JvbGwiLCJwYW5GcmljdGlvbiIsIm92ZXJEaWZmIiwibmV3T2Zmc2V0Iiwic3RhcnRPdmVyRGlmZiIsImRpciIsIm5ld01haW5TY3JvbGxQb3NpdGlvbiIsIm1haW5TY3JvbGxEaWZmIiwibmV3UGFuUG9zIiwibmV3TWFpblNjcm9sbFBvcyIsIl9vbkRyYWdTdGFydCIsImJ1dHRvbiIsIl9pbml0aWFsWm9vbVJ1bm5pbmciLCJwb2ludGVySW5kZXgiLCJwb2ludGVySWQiLCJzdGFydFBvaW50c0xpc3QiLCJudW1Qb2ludHMiLCJfb25EcmFnTW92ZSIsInRvdWNoZXNMaXN0IiwicG9pbnRzRGlzdGFuY2UiLCJfY2FsY3VsYXRlWm9vbUxldmVsIiwiem9vbUZyaWN0aW9uIiwibWluWm9vbUxldmVsIiwibWF4Wm9vbUxldmVsIiwibWludXNEaWZmIiwicGVyY2VudCIsIm9wYWNpdHlSYXRpbyIsIm1haW5TY3JvbGxDaGFuZ2VkIiwiX29uRHJhZ1JlbGVhc2UiLCJyZWxlYXNlUG9pbnQiLCJzcGxpY2UiLCJNU1BPSU5URVJfVFlQRVMiLCJwb2ludGVyVHlwZSIsInRvdWNoTGlzdCIsImdlc3R1cmVUeXBlIiwiY2hhbmdlZFRvdWNoZXMiLCJyZWxlYXNlVGltZURpZmYiLCJfaW5pdERyYWdSZWxlYXNlQW5pbWF0aW9uRGF0YSIsImNhbGN1bGF0ZVN3aXBlU3BlZWQiLCJpbml0YWxQYW5ZIiwiaW5pdGlhbEJnT3BhY2l0eSIsIml0ZW1DaGFuZ2VkIiwiX2ZpbmlzaFN3aXBlTWFpblNjcm9sbEdlc3R1cmUiLCJfY29tcGxldGVab29tR2VzdHVyZSIsIl9jb21wbGV0ZVBhbkdlc3R1cmUiLCJsYXN0RmxpY2tEdXJhdGlvbiIsInRlbXBSZWxlYXNlUG9zIiwibGFzdEZsaWNrT2Zmc2V0IiwibGFzdEZsaWNrRGlzdCIsImxhc3RGbGlja1NwZWVkIiwic2xvd0Rvd25SYXRpbyIsInNsb3dEb3duUmF0aW9SZXZlcnNlIiwic3BlZWREZWNlbGVyYXRpb25SYXRpbyIsInNwZWVkRGVjZWxlcmF0aW9uUmF0aW9BYnMiLCJkaXN0YW5jZU9mZnNldCIsImJhY2tBbmltRGVzdGluYXRpb24iLCJiYWNrQW5pbVN0YXJ0ZWQiLCJjYWxjdWxhdGVPdmVyQm91bmRzQW5pbU9mZnNldCIsInBvcyIsImNhbGN1bGF0ZUFuaW1PZmZzZXQiLCJ0aW1lRGlmZiIsInBhbkFuaW1Mb29wIiwiem9vbVBhbiIsImxhc3ROb3ciLCJhbmltRGF0YSIsIml0ZW1zRGlmZiIsInRvdGFsU2hpZnREaXN0IiwiaXNGYXN0TGFzdEZsaWNrIiwibmV4dENpcmNsZSIsImFuaW1hdGVUb1giLCJhbmltYXRlVG9EaXN0IiwiZmluaXNoQW5pbUR1cmF0aW9uIiwidG91Y2hlc0Rpc3RhbmNlIiwiZGVzdE9wYWNpdHkiLCJpbml0aWFsT3BhY2l0eSIsImluaXRHZXN0dXJlcyIsImFkZEV2ZW50TmFtZXMiLCJwcmVmIiwiZG93biIsIm1vdmUiLCJ1cCIsImNhbmNlbCIsIm1heFRvdWNoUG9pbnRzIiwibXNNYXhUb3VjaFBvaW50cyIsImxpa2VseVRvdWNoRGV2aWNlIiwibW91c2Vkb3duIiwibW91c2Vtb3ZlIiwibW91c2V1cCIsImltZyIsImNvbXBsZXRlRm4iLCJfaW5pdGlhbENvbnRlbnRTZXQiLCJ0aHVtYkJvdW5kcyIsImluaXRpYWxMYXlvdXQiLCJnZXRUaHVtYkJvdW5kc0ZuIiwiZHVyYXRpb24iLCJyZW1vdmVBdHRyaWJ1dGUiLCJzdGFydEFuaW1hdGlvbiIsImNsb3NlV2l0aFJhZiIsImZhZGVFdmVyeXRoaW5nIiwic3JjIiwibG9hZEVycm9yIiwibWluaUltZyIsIndlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSIsImluaXRhbEJnT3BhY2l0eSIsIl9pdGVtcyIsIl90ZW1wUGFuQXJlYVNpemUiLCJfaW1hZ2VzVG9BcHBlbmRQb29sIiwiX2NvbnRyb2xsZXJEZWZhdWx0T3B0aW9ucyIsImVycm9yTXNnIiwiZm9yY2VQcm9ncmVzc2l2ZUxvYWRpbmciLCJwcmVsb2FkIiwiZ2V0TnVtSXRlbXNGbiIsIl9pbml0aWFsSXNMb29wIiwiX2dldFplcm9Cb3VuZHMiLCJfY2FsY3VsYXRlU2luZ2xlSXRlbVBhbkJvdW5kcyIsInJlYWxQYW5FbGVtZW50VyIsInJlYWxQYW5FbGVtZW50SCIsInZHYXAiLCJpc0luaXRpYWwiLCJib3R0b20iLCJoUmF0aW8iLCJ2UmF0aW8iLCJfYXBwZW5kSW1hZ2UiLCJiYXNlRGl2IiwicHJldmVudEFuaW1hdGlvbiIsImtlZXBQbGFjZWhvbGRlciIsImltYWdlQXBwZW5kZWQiLCJhcHBlbmRDaGlsZCIsImxvYWRlZCIsInBsYWNlaG9sZGVyIiwiX3ByZWxvYWRJbWFnZSIsImxvYWRpbmciLCJsb2FkQ29tcGxldGUiLCJvbmxvYWQiLCJvbmVycm9yIiwiX2NoZWNrRm9yRXJyb3IiLCJjbGVhblVwIiwiaW5uZXJIVE1MIiwibWF4UmVzIiwibGFzdENoaWxkIiwiX2FwcGVuZEltYWdlc1Bvb2wiLCJwb29sSXRlbSIsImNsZWFyUGxhY2Vob2xkZXIiLCJsYXp5TG9hZEl0ZW0iLCJpbml0Q29udHJvbGxlciIsImdldEl0ZW1BdCIsImlzTmV4dCIsInByZWxvYWRCZWZvcmUiLCJwcmVsb2FkQWZ0ZXIiLCJwcmVsb2FkZXIiLCJhbGxvd1Byb2dyZXNzaXZlSW1nIiwic2NyZWVuIiwiaHRtbCIsInBsYWNlaG9sZGVyQ2xhc3NOYW1lIiwibXNyYyIsInRhcFRpbWVyIiwidGFwUmVsZWFzZVBvaW50IiwiX2Rpc3BhdGNoVGFwRXZlbnQiLCJvcmlnRXZlbnQiLCJjcmVhdGVFdmVudCIsImVEZXRhaWwiLCJpbml0Q3VzdG9tRXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiaW5pdFRhcCIsIm9uVGFwU3RhcnQiLCJvblRhcFJlbGVhc2UiLCJwMCIsImNsaWNrZWRUYWdOYW1lIiwiX3doZWVsRGVsdGEiLCJpbml0RGVza3RvcFpvb20iLCJzZXR1cERlc2t0b3Bab29tIiwib25Jbml0IiwiZXZlbnRzIiwiaGFuZGxlTW91c2VXaGVlbCIsIm1vdXNlWm9vbWVkSW4iLCJoYXNEcmFnZ2luZ0NsYXNzIiwidXBkYXRlWm9vbWFibGUiLCJyZW1vdmVEcmFnZ2luZ0NsYXNzIiwiZGVsdGFZIiwiZGVsdGFNb2RlIiwiZGVsdGFYIiwid2hlZWxEZWx0YVgiLCJ3aGVlbERlbHRhWSIsIndoZWVsRGVsdGEiLCJkZXRhaWwiLCJuZXdQYW5YIiwibmV3UGFuWSIsInRvZ2dsZURlc2t0b3Bab29tIiwiZG91YmxlVGFwWm9vbUxldmVsIiwiem9vbU91dCIsIl9oaXN0b3J5RGVmYXVsdE9wdGlvbnMiLCJoaXN0b3J5IiwiZ2FsbGVyeVVJRCIsIl9oaXN0b3J5VXBkYXRlVGltZW91dCIsIl9oYXNoQ2hhbmdlVGltZW91dCIsIl9oYXNoQW5pbUNoZWNrVGltZW91dCIsIl9oYXNoQ2hhbmdlZEJ5U2NyaXB0IiwiX2hhc2hDaGFuZ2VkQnlIaXN0b3J5IiwiX2hhc2hSZXNldGVkIiwiX2luaXRpYWxIYXNoIiwiX2hpc3RvcnlDaGFuZ2VkIiwiX2Nsb3NlZEZyb21VUkwiLCJfdXJsQ2hhbmdlZE9uY2UiLCJfd2luZG93TG9jIiwiX3N1cHBvcnRzUHVzaFN0YXRlIiwiX2dldEhhc2giLCJoYXNoIiwic3Vic3RyaW5nIiwiX2NsZWFuSGlzdG9yeVRpbWVvdXRzIiwiX3BhcnNlSXRlbUluZGV4RnJvbVVSTCIsInBhcmFtcyIsInZhcnMiLCJwYWlyIiwiZ2FsbGVyeVBJRHMiLCJzZWFyY2hmb3IiLCJwaWQiLCJfdXBkYXRlSGFzaCIsIm5ld0hhc2giLCJuZXdVUkwiLCJocmVmIiwibG9jYXRpb24iLCJ0aXRsZSIsImluaXRIaXN0b3J5IiwidXBkYXRlVVJMIiwib25IYXNoQ2hhbmdlIiwicmV0dXJuVG9PcmlnaW5hbCIsImJhY2siLCJwdXNoU3RhdGUiLCJwYXRobmFtZSIsInNlYXJjaCJdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBLENBQUMsVUFBVUEsSUFBVixFQUFnQkMsT0FBaEIsRUFBeUI7QUFDekIsTUFBSSxJQUFKLEVBQWdEO0FBQy9DQyx3Q0FBT0QsT0FBRDtBQUFBO0FBQUE7QUFBQTtBQUFBLG9HQUFOO0FBQ0EsR0FGRCxNQUVPLEVBSU47QUFDRCxDQVJELEVBUUcsSUFSSCxFQVFTLFlBQVk7QUFFcEI7O0FBQ0EsTUFBSUUsVUFBVSxHQUFHLFVBQVNDLFFBQVQsRUFBbUJDLE9BQW5CLEVBQTRCQyxLQUE1QixFQUFtQ0MsT0FBbkMsRUFBMkM7QUFFN0Q7O0FBQ0E7Ozs7Ozs7QUFPQSxRQUFJQyxTQUFTLEdBQUc7QUFDZkMsY0FBUSxFQUFFLElBREs7QUFFZkMsVUFB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QUFWLENBQWVxQixNQUFmLEVBQXVCLFlBQXZCLEVBQXFDOEYsSUFBSSxDQUFDeWlCLFlBQTFDO0FBQ0E7QUFDRCxXQUpTLEVBSVAsRUFKTyxDQUFWO0FBTUEsU0EzRmE7QUE0RmRBLG9CQUFZLEVBQUUsWUFBVztBQUV4QixjQUFHbkIsUUFBUSxPQUFPTixZQUFsQixFQUFnQztBQUUvQkUsMEJBQWMsR0FBRyxJQUFqQjtBQUNBbGhCLGdCQUFJLENBQUNxTyxLQUFMO0FBQ0E7QUFDQTs7QUFDRCxjQUFHLENBQUN3UyxvQkFBSixFQUEwQjtBQUV6QkMsaUNBQXFCLEdBQUcsSUFBeEI7QUFDQTlnQixnQkFBSSxDQUFDOE8sSUFBTCxDQUFXNFMsc0JBQXNCLEdBQUdNLEdBQXBDO0FBQ0FsQixpQ0FBcUIsR0FBRyxLQUF4QjtBQUNBO0FBRUQsU0EzR2E7QUE0R2QwQixpQkFBUyxFQUFFLFlBQVc7QUFFckI7QUFDQTtBQUVBZiwrQkFBcUI7O0FBR3JCLGNBQUdYLHFCQUFILEVBQTBCO0FBQ3pCO0FBQ0E7O0FBRUQsY0FBRyxDQUFDRyxlQUFKLEVBQXFCO0FBQ3BCZ0IsdUJBQVcsR0FEUyxDQUNMOztBQUNmLFdBRkQsTUFFTztBQUNOdkIsaUNBQXFCLEdBQUduaEIsVUFBVSxDQUFDMGlCLFdBQUQsRUFBYyxHQUFkLENBQWxDO0FBQ0E7QUFDRDtBQTdIYTtBQUpXLEtBQVosQ0FBZjtBQXVJQTs7O0FBQ0N0cEIsYUFBUyxDQUFDNkMsTUFBVixDQUFpQndFLElBQWpCLEVBQXVCZ0YsYUFBdkI7QUFBd0MsR0Fyb0h4Qzs7QUFzb0hBLFNBQU8xTSxVQUFQO0FBQ0EsQ0FscEhEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Bob3Rvc3dpcGUvZGlzdC9waG90b3N3aXBlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohIFBob3RvU3dpcGUgLSB2NC4xLjMgLSAyMDE5LTAxLTA4XG4qIGh0dHA6Ly9waG90b3N3aXBlLmNvbVxuKiBDb3B5cmlnaHQgKGMpIDIwMTkgRG1pdHJ5IFNlbWVub3Y7ICovXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHsgXG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0XHRkZWZpbmUoZmFjdG9yeSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH0gZWxzZSB7XG5cdFx0cm9vdC5QaG90b1N3aXBlID0gZmFjdG9yeSgpO1xuXHR9XG59KSh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHR2YXIgUGhvdG9Td2lwZSA9IGZ1bmN0aW9uKHRlbXBsYXRlLCBVaUNsYXNzLCBpdGVtcywgb3B0aW9ucyl7XG5cbi8qPj5mcmFtZXdvcmstYnJpZGdlKi9cbi8qKlxuICpcbiAqIFNldCBvZiBnZW5lcmljIGZ1bmN0aW9ucyB1c2VkIGJ5IGdhbGxlcnkuXG4gKiBcbiAqIFlvdSdyZSBmcmVlIHRvIG1vZGlmeSBhbnl0aGluZyBoZXJlIGFzIGxvbmcgYXMgZnVuY3Rpb25hbGl0eSBpcyBrZXB0LlxuICogXG4gKi9cbnZhciBmcmFtZXdvcmsgPSB7XG5cdGZlYXR1cmVzOiBudWxsLFxuXHRiaW5kOiBmdW5jdGlvbih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCB1bmJpbmQpIHtcblx0XHR2YXIgbWV0aG9kTmFtZSA9ICh1bmJpbmQgPyAncmVtb3ZlJyA6ICdhZGQnKSArICdFdmVudExpc3RlbmVyJztcblx0XHR0eXBlID0gdHlwZS5zcGxpdCgnICcpO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZih0eXBlW2ldKSB7XG5cdFx0XHRcdHRhcmdldFttZXRob2ROYW1lXSggdHlwZVtpXSwgbGlzdGVuZXIsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGlzQXJyYXk6IGZ1bmN0aW9uKG9iaikge1xuXHRcdHJldHVybiAob2JqIGluc3RhbmNlb2YgQXJyYXkpO1xuXHR9LFxuXHRjcmVhdGVFbDogZnVuY3Rpb24oY2xhc3NlcywgdGFnKSB7XG5cdFx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcgfHwgJ2RpdicpO1xuXHRcdGlmKGNsYXNzZXMpIHtcblx0XHRcdGVsLmNsYXNzTmFtZSA9IGNsYXNzZXM7XG5cdFx0fVxuXHRcdHJldHVybiBlbDtcblx0fSxcblx0Z2V0U2Nyb2xsWTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHlPZmZzZXQgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG5cdFx0cmV0dXJuIHlPZmZzZXQgIT09IHVuZGVmaW5lZCA/IHlPZmZzZXQgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcblx0XHRmcmFtZXdvcmsuYmluZCh0YXJnZXQsdHlwZSxsaXN0ZW5lcix0cnVlKTtcblx0fSxcblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKGVsLCBjbGFzc05hbWUpIHtcblx0XHR2YXIgcmVnID0gbmV3IFJlZ0V4cCgnKFxcXFxzfF4pJyArIGNsYXNzTmFtZSArICcoXFxcXHN8JCknKTtcblx0XHRlbC5jbGFzc05hbWUgPSBlbC5jbGFzc05hbWUucmVwbGFjZShyZWcsICcgJykucmVwbGFjZSgvXlxcc1xccyovLCAnJykucmVwbGFjZSgvXFxzXFxzKiQvLCAnJyk7IFxuXHR9LFxuXHRhZGRDbGFzczogZnVuY3Rpb24oZWwsIGNsYXNzTmFtZSkge1xuXHRcdGlmKCAhZnJhbWV3b3JrLmhhc0NsYXNzKGVsLGNsYXNzTmFtZSkgKSB7XG5cdFx0XHRlbC5jbGFzc05hbWUgKz0gKGVsLmNsYXNzTmFtZSA/ICcgJyA6ICcnKSArIGNsYXNzTmFtZTtcblx0XHR9XG5cdH0sXG5cdGhhc0NsYXNzOiBmdW5jdGlvbihlbCwgY2xhc3NOYW1lKSB7XG5cdFx0cmV0dXJuIGVsLmNsYXNzTmFtZSAmJiBuZXcgUmVnRXhwKCcoXnxcXFxccyknICsgY2xhc3NOYW1lICsgJyhcXFxcc3wkKScpLnRlc3QoZWwuY2xhc3NOYW1lKTtcblx0fSxcblx0Z2V0Q2hpbGRCeUNsYXNzOiBmdW5jdGlvbihwYXJlbnRFbCwgY2hpbGRDbGFzc05hbWUpIHtcblx0XHR2YXIgbm9kZSA9IHBhcmVudEVsLmZpcnN0Q2hpbGQ7XG5cdFx0d2hpbGUobm9kZSkge1xuXHRcdFx0aWYoIGZyYW1ld29yay5oYXNDbGFzcyhub2RlLCBjaGlsZENsYXNzTmFtZSkgKSB7XG5cdFx0XHRcdHJldHVybiBub2RlO1xuXHRcdFx0fVxuXHRcdFx0bm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG5cdFx0fVxuXHR9LFxuXHRhcnJheVNlYXJjaDogZnVuY3Rpb24oYXJyYXksIHZhbHVlLCBrZXkpIHtcblx0XHR2YXIgaSA9IGFycmF5Lmxlbmd0aDtcblx0XHR3aGlsZShpLS0pIHtcblx0XHRcdGlmKGFycmF5W2ldW2tleV0gPT09IHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fSBcblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXHRleHRlbmQ6IGZ1bmN0aW9uKG8xLCBvMiwgcHJldmVudE92ZXJ3cml0ZSkge1xuXHRcdGZvciAodmFyIHByb3AgaW4gbzIpIHtcblx0XHRcdGlmIChvMi5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuXHRcdFx0XHRpZihwcmV2ZW50T3ZlcndyaXRlICYmIG8xLmhhc093blByb3BlcnR5KHByb3ApKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0bzFbcHJvcF0gPSBvMltwcm9wXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGVhc2luZzoge1xuXHRcdHNpbmU6IHtcblx0XHRcdG91dDogZnVuY3Rpb24oaykge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5zaW4oayAqIChNYXRoLlBJIC8gMikpO1xuXHRcdFx0fSxcblx0XHRcdGluT3V0OiBmdW5jdGlvbihrKSB7XG5cdFx0XHRcdHJldHVybiAtIChNYXRoLmNvcyhNYXRoLlBJICogaykgLSAxKSAvIDI7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRjdWJpYzoge1xuXHRcdFx0b3V0OiBmdW5jdGlvbihrKSB7XG5cdFx0XHRcdHJldHVybiAtLWsgKiBrICogayArIDE7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8qXG5cdFx0XHRlbGFzdGljOiB7XG5cdFx0XHRcdG91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRcdFx0dmFyIHMsIGEgPSAwLjEsIHAgPSAwLjQ7XG5cdFx0XHRcdFx0aWYgKCBrID09PSAwICkgcmV0dXJuIDA7XG5cdFx0XHRcdFx0aWYgKCBrID09PSAxICkgcmV0dXJuIDE7XG5cdFx0XHRcdFx0aWYgKCAhYSB8fCBhIDwgMSApIHsgYSA9IDE7IHMgPSBwIC8gNDsgfVxuXHRcdFx0XHRcdGVsc2UgcyA9IHAgKiBNYXRoLmFzaW4oIDEgLyBhICkgLyAoIDIgKiBNYXRoLlBJICk7XG5cdFx0XHRcdFx0cmV0dXJuICggYSAqIE1hdGgucG93KCAyLCAtIDEwICogaykgKiBNYXRoLnNpbiggKCBrIC0gcyApICogKCAyICogTWF0aC5QSSApIC8gcCApICsgMSApO1xuXG5cdFx0XHRcdH0sXG5cdFx0XHR9LFxuXHRcdFx0YmFjazoge1xuXHRcdFx0XHRvdXQ6IGZ1bmN0aW9uICggayApIHtcblx0XHRcdFx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0XHRcdFx0cmV0dXJuIC0tayAqIGsgKiAoICggcyArIDEgKSAqIGsgKyBzICkgKyAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0Ki9cblx0fSxcblxuXHQvKipcblx0ICogXG5cdCAqIEByZXR1cm4ge29iamVjdH1cblx0ICogXG5cdCAqIHtcblx0ICogIHJhZiA6IHJlcXVlc3QgYW5pbWF0aW9uIGZyYW1lIGZ1bmN0aW9uXG5cdCAqICBjYWYgOiBjYW5jZWwgYW5pbWF0aW9uIGZyYW1lIGZ1bmN0aW9uXG5cdCAqICB0cmFuc2Zyb20gOiB0cmFuc2Zvcm0gcHJvcGVydHkga2V5ICh3aXRoIHZlbmRvciksIG9yIG51bGwgaWYgbm90IHN1cHBvcnRlZFxuXHQgKiAgb2xkSUUgOiBJRTggb3IgYmVsb3dcblx0ICogfVxuXHQgKiBcblx0ICovXG5cdGRldGVjdEZlYXR1cmVzOiBmdW5jdGlvbigpIHtcblx0XHRpZihmcmFtZXdvcmsuZmVhdHVyZXMpIHtcblx0XHRcdHJldHVybiBmcmFtZXdvcmsuZmVhdHVyZXM7XG5cdFx0fVxuXHRcdHZhciBoZWxwZXJFbCA9IGZyYW1ld29yay5jcmVhdGVFbCgpLFxuXHRcdFx0aGVscGVyU3R5bGUgPSBoZWxwZXJFbC5zdHlsZSxcblx0XHRcdHZlbmRvciA9ICcnLFxuXHRcdFx0ZmVhdHVyZXMgPSB7fTtcblxuXHRcdC8vIElFOCBhbmQgYmVsb3dcblx0XHRmZWF0dXJlcy5vbGRJRSA9IGRvY3VtZW50LmFsbCAmJiAhZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcjtcblxuXHRcdGZlYXR1cmVzLnRvdWNoID0gJ29udG91Y2hzdGFydCcgaW4gd2luZG93O1xuXG5cdFx0aWYod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuXHRcdFx0ZmVhdHVyZXMucmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcblx0XHRcdGZlYXR1cmVzLmNhZiA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZTtcblx0XHR9XG5cblx0XHRmZWF0dXJlcy5wb2ludGVyRXZlbnQgPSAhISh3aW5kb3cuUG9pbnRlckV2ZW50KSB8fCBuYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZDtcblxuXHRcdC8vIGZpeCBmYWxzZS1wb3NpdGl2ZSBkZXRlY3Rpb24gb2Ygb2xkIEFuZHJvaWQgaW4gbmV3IElFXG5cdFx0Ly8gKElFMTEgdWEgc3RyaW5nIGNvbnRhaW5zIFwiQW5kcm9pZCA0LjBcIilcblx0XHRcblx0XHRpZighZmVhdHVyZXMucG9pbnRlckV2ZW50KSB7IFxuXG5cdFx0XHR2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuXG5cdFx0XHQvLyBEZXRlY3QgaWYgZGV2aWNlIGlzIGlQaG9uZSBvciBpUG9kIGFuZCBpZiBpdCdzIG9sZGVyIHRoYW4gaU9TIDhcblx0XHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE0MjIzOTIwXG5cdFx0XHQvLyBcblx0XHRcdC8vIFRoaXMgZGV0ZWN0aW9uIGlzIG1hZGUgYmVjYXVzZSBvZiBidWdneSB0b3AvYm90dG9tIHRvb2xiYXJzXG5cdFx0XHQvLyB0aGF0IGRvbid0IHRyaWdnZXIgd2luZG93LnJlc2l6ZSBldmVudC5cblx0XHRcdC8vIEZvciBtb3JlIGluZm8gcmVmZXIgdG8gX2lzRml4ZWRQb3NpdGlvbiB2YXJpYWJsZSBpbiBjb3JlLmpzXG5cblx0XHRcdGlmICgvaVAoaG9uZXxvZCkvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKSkge1xuXHRcdFx0XHR2YXIgdiA9IChuYXZpZ2F0b3IuYXBwVmVyc2lvbikubWF0Y2goL09TIChcXGQrKV8oXFxkKylfPyhcXGQrKT8vKTtcblx0XHRcdFx0aWYodiAmJiB2Lmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHR2ID0gcGFyc2VJbnQodlsxXSwgMTApO1xuXHRcdFx0XHRcdGlmKHYgPj0gMSAmJiB2IDwgOCApIHtcblx0XHRcdFx0XHRcdGZlYXR1cmVzLmlzT2xkSU9TUGhvbmUgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXRlY3Qgb2xkIEFuZHJvaWQgKGJlZm9yZSBLaXRLYXQpXG5cdFx0XHQvLyBkdWUgdG8gYnVncyByZWxhdGVkIHRvIHBvc2l0aW9uOmZpeGVkXG5cdFx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzcxODQ1NzMvcGljay11cC10aGUtYW5kcm9pZC12ZXJzaW9uLWluLXRoZS1icm93c2VyLWJ5LWphdmFzY3JpcHRcblx0XHRcdFxuXHRcdFx0dmFyIG1hdGNoID0gdWEubWF0Y2goL0FuZHJvaWRcXHMoWzAtOVxcLl0qKS8pO1xuXHRcdFx0dmFyIGFuZHJvaWR2ZXJzaW9uID0gIG1hdGNoID8gbWF0Y2hbMV0gOiAwO1xuXHRcdFx0YW5kcm9pZHZlcnNpb24gPSBwYXJzZUZsb2F0KGFuZHJvaWR2ZXJzaW9uKTtcblx0XHRcdGlmKGFuZHJvaWR2ZXJzaW9uID49IDEgKSB7XG5cdFx0XHRcdGlmKGFuZHJvaWR2ZXJzaW9uIDwgNC40KSB7XG5cdFx0XHRcdFx0ZmVhdHVyZXMuaXNPbGRBbmRyb2lkID0gdHJ1ZTsgLy8gZm9yIGZpeGVkIHBvc2l0aW9uIGJ1ZyAmIHBlcmZvcm1hbmNlXG5cdFx0XHRcdH1cblx0XHRcdFx0ZmVhdHVyZXMuYW5kcm9pZFZlcnNpb24gPSBhbmRyb2lkdmVyc2lvbjsgLy8gZm9yIHRvdWNoZW5kIGJ1Z1xuXHRcdFx0fVx0XG5cdFx0XHRmZWF0dXJlcy5pc01vYmlsZU9wZXJhID0gL29wZXJhIG1pbml8b3BlcmEgbW9iaS9pLnRlc3QodWEpO1xuXG5cdFx0XHQvLyBwLnMuIHllcywgeWVzLCBVQSBzbmlmZmluZyBpcyBiYWQsIHByb3Bvc2UgeW91ciBzb2x1dGlvbiBmb3IgYWJvdmUgYnVncy5cblx0XHR9XG5cdFx0XG5cdFx0dmFyIHN0eWxlQ2hlY2tzID0gWyd0cmFuc2Zvcm0nLCAncGVyc3BlY3RpdmUnLCAnYW5pbWF0aW9uTmFtZSddLFxuXHRcdFx0dmVuZG9ycyA9IFsnJywgJ3dlYmtpdCcsJ01veicsJ21zJywnTyddLFxuXHRcdFx0c3R5bGVDaGVja0l0ZW0sXG5cdFx0XHRzdHlsZU5hbWU7XG5cblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdFx0XHR2ZW5kb3IgPSB2ZW5kb3JzW2ldO1xuXG5cdFx0XHRmb3IodmFyIGEgPSAwOyBhIDwgMzsgYSsrKSB7XG5cdFx0XHRcdHN0eWxlQ2hlY2tJdGVtID0gc3R5bGVDaGVja3NbYV07XG5cblx0XHRcdFx0Ly8gdXBwZXJjYXNlIGZpcnN0IGxldHRlciBvZiBwcm9wZXJ0eSBuYW1lLCBpZiB2ZW5kb3IgaXMgcHJlc2VudFxuXHRcdFx0XHRzdHlsZU5hbWUgPSB2ZW5kb3IgKyAodmVuZG9yID8gXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHN0eWxlQ2hlY2tJdGVtLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3R5bGVDaGVja0l0ZW0uc2xpY2UoMSkgOiBcblx0XHRcdFx0XHRcdFx0XHRcdFx0c3R5bGVDaGVja0l0ZW0pO1xuXHRcdFx0XG5cdFx0XHRcdGlmKCFmZWF0dXJlc1tzdHlsZUNoZWNrSXRlbV0gJiYgc3R5bGVOYW1lIGluIGhlbHBlclN0eWxlICkge1xuXHRcdFx0XHRcdGZlYXR1cmVzW3N0eWxlQ2hlY2tJdGVtXSA9IHN0eWxlTmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZih2ZW5kb3IgJiYgIWZlYXR1cmVzLnJhZikge1xuXHRcdFx0XHR2ZW5kb3IgPSB2ZW5kb3IudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0ZmVhdHVyZXMucmFmID0gd2luZG93W3ZlbmRvcisnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG5cdFx0XHRcdGlmKGZlYXR1cmVzLnJhZikge1xuXHRcdFx0XHRcdGZlYXR1cmVzLmNhZiA9IHdpbmRvd1t2ZW5kb3IrJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ10gfHwgXG5cdFx0XHRcdFx0XHRcdFx0XHR3aW5kb3dbdmVuZG9yKydDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcdFxuXHRcdGlmKCFmZWF0dXJlcy5yYWYpIHtcblx0XHRcdHZhciBsYXN0VGltZSA9IDA7XG5cdFx0XHRmZWF0dXJlcy5yYWYgPSBmdW5jdGlvbihmbikge1xuXHRcdFx0XHR2YXIgY3VyclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0XHRcdFx0dmFyIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyVGltZSAtIGxhc3RUaW1lKSk7XG5cdFx0XHRcdHZhciBpZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmbihjdXJyVGltZSArIHRpbWVUb0NhbGwpOyB9LCB0aW1lVG9DYWxsKTtcblx0XHRcdFx0bGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG5cdFx0XHRcdHJldHVybiBpZDtcblx0XHRcdH07XG5cdFx0XHRmZWF0dXJlcy5jYWYgPSBmdW5jdGlvbihpZCkgeyBjbGVhclRpbWVvdXQoaWQpOyB9O1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBTVkcgc3VwcG9ydFxuXHRcdGZlYXR1cmVzLnN2ZyA9ICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmIFxuXHRcdFx0XHRcdFx0ISFkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3N2ZycpLmNyZWF0ZVNWR1JlY3Q7XG5cblx0XHRmcmFtZXdvcmsuZmVhdHVyZXMgPSBmZWF0dXJlcztcblxuXHRcdHJldHVybiBmZWF0dXJlcztcblx0fVxufTtcblxuZnJhbWV3b3JrLmRldGVjdEZlYXR1cmVzKCk7XG5cbi8vIE92ZXJyaWRlIGFkZEV2ZW50TGlzdGVuZXIgZm9yIG9sZCB2ZXJzaW9ucyBvZiBJRVxuaWYoZnJhbWV3b3JrLmZlYXR1cmVzLm9sZElFKSB7XG5cblx0ZnJhbWV3b3JrLmJpbmQgPSBmdW5jdGlvbih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCB1bmJpbmQpIHtcblx0XHRcblx0XHR0eXBlID0gdHlwZS5zcGxpdCgnICcpO1xuXG5cdFx0dmFyIG1ldGhvZE5hbWUgPSAodW5iaW5kID8gJ2RldGFjaCcgOiAnYXR0YWNoJykgKyAnRXZlbnQnLFxuXHRcdFx0ZXZOYW1lLFxuXHRcdFx0X2hhbmRsZUV2ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxpc3RlbmVyLmhhbmRsZUV2ZW50LmNhbGwobGlzdGVuZXIpO1xuXHRcdFx0fTtcblxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRldk5hbWUgPSB0eXBlW2ldO1xuXHRcdFx0aWYoZXZOYW1lKSB7XG5cblx0XHRcdFx0aWYodHlwZW9mIGxpc3RlbmVyID09PSAnb2JqZWN0JyAmJiBsaXN0ZW5lci5oYW5kbGVFdmVudCkge1xuXHRcdFx0XHRcdGlmKCF1bmJpbmQpIHtcblx0XHRcdFx0XHRcdGxpc3RlbmVyWydvbGRJRScgKyBldk5hbWVdID0gX2hhbmRsZUV2O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZighbGlzdGVuZXJbJ29sZElFJyArIGV2TmFtZV0pIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRhcmdldFttZXRob2ROYW1lXSggJ29uJyArIGV2TmFtZSwgbGlzdGVuZXJbJ29sZElFJyArIGV2TmFtZV0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRhcmdldFttZXRob2ROYW1lXSggJ29uJyArIGV2TmFtZSwgbGlzdGVuZXIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdFxufVxuXG4vKj4+ZnJhbWV3b3JrLWJyaWRnZSovXG5cbi8qPj5jb3JlKi9cbi8vZnVuY3Rpb24odGVtcGxhdGUsIFVpQ2xhc3MsIGl0ZW1zLCBvcHRpb25zKVxuXG52YXIgc2VsZiA9IHRoaXM7XG5cbi8qKlxuICogU3RhdGljIHZhcnMsIGRvbid0IGNoYW5nZSB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcuXG4gKi9cbnZhciBET1VCTEVfVEFQX1JBRElVUyA9IDI1LCBcblx0TlVNX0hPTERFUlMgPSAzO1xuXG4vKipcbiAqIE9wdGlvbnNcbiAqL1xudmFyIF9vcHRpb25zID0ge1xuXHRhbGxvd1BhblRvTmV4dDp0cnVlLFxuXHRzcGFjaW5nOiAwLjEyLFxuXHRiZ09wYWNpdHk6IDEsXG5cdG1vdXNlVXNlZDogZmFsc2UsXG5cdGxvb3A6IHRydWUsXG5cdHBpbmNoVG9DbG9zZTogdHJ1ZSxcblx0Y2xvc2VPblNjcm9sbDogdHJ1ZSxcblx0Y2xvc2VPblZlcnRpY2FsRHJhZzogdHJ1ZSxcblx0dmVydGljYWxEcmFnUmFuZ2U6IDAuNzUsXG5cdGhpZGVBbmltYXRpb25EdXJhdGlvbjogMzMzLFxuXHRzaG93QW5pbWF0aW9uRHVyYXRpb246IDMzMyxcblx0c2hvd0hpZGVPcGFjaXR5OiBmYWxzZSxcblx0Zm9jdXM6IHRydWUsXG5cdGVzY0tleTogdHJ1ZSxcblx0YXJyb3dLZXlzOiB0cnVlLFxuXHRtYWluU2Nyb2xsRW5kRnJpY3Rpb246IDAuMzUsXG5cdHBhbkVuZEZyaWN0aW9uOiAwLjM1LFxuXHRpc0NsaWNrYWJsZUVsZW1lbnQ6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHJldHVybiBlbC50YWdOYW1lID09PSAnQSc7XG4gICAgfSxcbiAgICBnZXREb3VibGVUYXBab29tOiBmdW5jdGlvbihpc01vdXNlQ2xpY2ssIGl0ZW0pIHtcbiAgICBcdGlmKGlzTW91c2VDbGljaykge1xuICAgIFx0XHRyZXR1cm4gMTtcbiAgICBcdH0gZWxzZSB7XG4gICAgXHRcdHJldHVybiBpdGVtLmluaXRpYWxab29tTGV2ZWwgPCAwLjcgPyAxIDogMS4zMztcbiAgICBcdH1cbiAgICB9LFxuICAgIG1heFNwcmVhZFpvb206IDEuMzMsXG5cdG1vZGFsOiB0cnVlLFxuXG5cdC8vIG5vdCBmdWxseSBpbXBsZW1lbnRlZCB5ZXRcblx0c2NhbGVNb2RlOiAnZml0JyAvLyBUT0RPXG59O1xuZnJhbWV3b3JrLmV4dGVuZChfb3B0aW9ucywgb3B0aW9ucyk7XG5cblxuLyoqXG4gKiBQcml2YXRlIGhlbHBlciB2YXJpYWJsZXMgJiBmdW5jdGlvbnNcbiAqL1xuXG52YXIgX2dldEVtcHR5UG9pbnQgPSBmdW5jdGlvbigpIHsgXG5cdFx0cmV0dXJuIHt4OjAseTowfTsgXG5cdH07XG5cbnZhciBfaXNPcGVuLFxuXHRfaXNEZXN0cm95aW5nLFxuXHRfY2xvc2VkQnlTY3JvbGwsXG5cdF9jdXJyZW50SXRlbUluZGV4LFxuXHRfY29udGFpbmVyU3R5bGUsXG5cdF9jb250YWluZXJTaGlmdEluZGV4LFxuXHRfY3VyclBhbkRpc3QgPSBfZ2V0RW1wdHlQb2ludCgpLFxuXHRfc3RhcnRQYW5PZmZzZXQgPSBfZ2V0RW1wdHlQb2ludCgpLFxuXHRfcGFuT2Zmc2V0ID0gX2dldEVtcHR5UG9pbnQoKSxcblx0X3VwTW92ZUV2ZW50cywgLy8gZHJhZyBtb3ZlLCBkcmFnIGVuZCAmIGRyYWcgY2FuY2VsIGV2ZW50cyBhcnJheVxuXHRfZG93bkV2ZW50cywgLy8gZHJhZyBzdGFydCBldmVudHMgYXJyYXlcblx0X2dsb2JhbEV2ZW50SGFuZGxlcnMsXG5cdF92aWV3cG9ydFNpemUgPSB7fSxcblx0X2N1cnJab29tTGV2ZWwsXG5cdF9zdGFydFpvb21MZXZlbCxcblx0X3RyYW5zbGF0ZVByZWZpeCxcblx0X3RyYW5zbGF0ZVN1Zml4LFxuXHRfdXBkYXRlU2l6ZUludGVydmFsLFxuXHRfaXRlbXNOZWVkVXBkYXRlLFxuXHRfY3VyclBvc2l0aW9uSW5kZXggPSAwLFxuXHRfb2Zmc2V0ID0ge30sXG5cdF9zbGlkZVNpemUgPSBfZ2V0RW1wdHlQb2ludCgpLCAvLyBzaXplIG9mIHNsaWRlIGFyZWEsIGluY2x1ZGluZyBzcGFjaW5nXG5cdF9pdGVtSG9sZGVycyxcblx0X3ByZXZJdGVtSW5kZXgsXG5cdF9pbmRleERpZmYgPSAwLCAvLyBkaWZmZXJlbmNlIG9mIGluZGV4ZXMgc2luY2UgbGFzdCBjb250ZW50IHVwZGF0ZVxuXHRfZHJhZ1N0YXJ0RXZlbnQsXG5cdF9kcmFnTW92ZUV2ZW50LFxuXHRfZHJhZ0VuZEV2ZW50LFxuXHRfZHJhZ0NhbmNlbEV2ZW50LFxuXHRfdHJhbnNmb3JtS2V5LFxuXHRfcG9pbnRlckV2ZW50RW5hYmxlZCxcblx0X2lzRml4ZWRQb3NpdGlvbiA9IHRydWUsXG5cdF9saWtlbHlUb3VjaERldmljZSxcblx0X21vZHVsZXMgPSBbXSxcblx0X3JlcXVlc3RBRixcblx0X2NhbmNlbEFGLFxuXHRfaW5pdGFsQ2xhc3NOYW1lLFxuXHRfaW5pdGFsV2luZG93U2Nyb2xsWSxcblx0X29sZElFLFxuXHRfY3VycmVudFdpbmRvd1Njcm9sbFksXG5cdF9mZWF0dXJlcyxcblx0X3dpbmRvd1Zpc2libGVTaXplID0ge30sXG5cdF9yZW5kZXJNYXhSZXNvbHV0aW9uID0gZmFsc2UsXG5cdF9vcmllbnRhdGlvbkNoYW5nZVRpbWVvdXQsXG5cblxuXHQvLyBSZWdpc3RlcnMgUGhvdG9TV2lwZSBtb2R1bGUgKEhpc3RvcnksIENvbnRyb2xsZXIgLi4uKVxuXHRfcmVnaXN0ZXJNb2R1bGUgPSBmdW5jdGlvbihuYW1lLCBtb2R1bGUpIHtcblx0XHRmcmFtZXdvcmsuZXh0ZW5kKHNlbGYsIG1vZHVsZS5wdWJsaWNNZXRob2RzKTtcblx0XHRfbW9kdWxlcy5wdXNoKG5hbWUpO1xuXHR9LFxuXG5cdF9nZXRMb29wZWRJZCA9IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0dmFyIG51bVNsaWRlcyA9IF9nZXROdW1JdGVtcygpO1xuXHRcdGlmKGluZGV4ID4gbnVtU2xpZGVzIC0gMSkge1xuXHRcdFx0cmV0dXJuIGluZGV4IC0gbnVtU2xpZGVzO1xuXHRcdH0gZWxzZSAgaWYoaW5kZXggPCAwKSB7XG5cdFx0XHRyZXR1cm4gbnVtU2xpZGVzICsgaW5kZXg7XG5cdFx0fVxuXHRcdHJldHVybiBpbmRleDtcblx0fSxcblx0XG5cdC8vIE1pY3JvIGJpbmQvdHJpZ2dlclxuXHRfbGlzdGVuZXJzID0ge30sXG5cdF9saXN0ZW4gPSBmdW5jdGlvbihuYW1lLCBmbikge1xuXHRcdGlmKCFfbGlzdGVuZXJzW25hbWVdKSB7XG5cdFx0XHRfbGlzdGVuZXJzW25hbWVdID0gW107XG5cdFx0fVxuXHRcdHJldHVybiBfbGlzdGVuZXJzW25hbWVdLnB1c2goZm4pO1xuXHR9LFxuXHRfc2hvdXQgPSBmdW5jdGlvbihuYW1lKSB7XG5cdFx0dmFyIGxpc3RlbmVycyA9IF9saXN0ZW5lcnNbbmFtZV07XG5cblx0XHRpZihsaXN0ZW5lcnMpIHtcblx0XHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHRcdGFyZ3Muc2hpZnQoKTtcblxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRsaXN0ZW5lcnNbaV0uYXBwbHkoc2VsZiwgYXJncyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRDdXJyZW50VGltZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0fSxcblx0X2FwcGx5QmdPcGFjaXR5ID0gZnVuY3Rpb24ob3BhY2l0eSkge1xuXHRcdF9iZ09wYWNpdHkgPSBvcGFjaXR5O1xuXHRcdHNlbGYuYmcuc3R5bGUub3BhY2l0eSA9IG9wYWNpdHkgKiBfb3B0aW9ucy5iZ09wYWNpdHk7XG5cdH0sXG5cblx0X2FwcGx5Wm9vbVRyYW5zZm9ybSA9IGZ1bmN0aW9uKHN0eWxlT2JqLHgseSx6b29tLGl0ZW0pIHtcblx0XHRpZighX3JlbmRlck1heFJlc29sdXRpb24gfHwgKGl0ZW0gJiYgaXRlbSAhPT0gc2VsZi5jdXJySXRlbSkgKSB7XG5cdFx0XHR6b29tID0gem9vbSAvIChpdGVtID8gaXRlbS5maXRSYXRpbyA6IHNlbGYuY3Vyckl0ZW0uZml0UmF0aW8pO1x0XG5cdFx0fVxuXHRcdFx0XG5cdFx0c3R5bGVPYmpbX3RyYW5zZm9ybUtleV0gPSBfdHJhbnNsYXRlUHJlZml4ICsgeCArICdweCwgJyArIHkgKyAncHgnICsgX3RyYW5zbGF0ZVN1Zml4ICsgJyBzY2FsZSgnICsgem9vbSArICcpJztcblx0fSxcblx0X2FwcGx5Q3VycmVudFpvb21QYW4gPSBmdW5jdGlvbiggYWxsb3dSZW5kZXJSZXNvbHV0aW9uICkge1xuXHRcdGlmKF9jdXJyWm9vbUVsZW1lbnRTdHlsZSkge1xuXG5cdFx0XHRpZihhbGxvd1JlbmRlclJlc29sdXRpb24pIHtcblx0XHRcdFx0aWYoX2N1cnJab29tTGV2ZWwgPiBzZWxmLmN1cnJJdGVtLmZpdFJhdGlvKSB7XG5cdFx0XHRcdFx0aWYoIV9yZW5kZXJNYXhSZXNvbHV0aW9uKSB7XG5cdFx0XHRcdFx0XHRfc2V0SW1hZ2VTaXplKHNlbGYuY3Vyckl0ZW0sIGZhbHNlLCB0cnVlKTtcblx0XHRcdFx0XHRcdF9yZW5kZXJNYXhSZXNvbHV0aW9uID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYoX3JlbmRlck1heFJlc29sdXRpb24pIHtcblx0XHRcdFx0XHRcdF9zZXRJbWFnZVNpemUoc2VsZi5jdXJySXRlbSk7XG5cdFx0XHRcdFx0XHRfcmVuZGVyTWF4UmVzb2x1dGlvbiA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cblx0XHRcdF9hcHBseVpvb21UcmFuc2Zvcm0oX2N1cnJab29tRWxlbWVudFN0eWxlLCBfcGFuT2Zmc2V0LngsIF9wYW5PZmZzZXQueSwgX2N1cnJab29tTGV2ZWwpO1xuXHRcdH1cblx0fSxcblx0X2FwcGx5Wm9vbVBhblRvSXRlbSA9IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRpZihpdGVtLmNvbnRhaW5lcikge1xuXG5cdFx0XHRfYXBwbHlab29tVHJhbnNmb3JtKGl0ZW0uY29udGFpbmVyLnN0eWxlLCBcblx0XHRcdFx0XHRcdFx0XHRpdGVtLmluaXRpYWxQb3NpdGlvbi54LCBcblx0XHRcdFx0XHRcdFx0XHRpdGVtLmluaXRpYWxQb3NpdGlvbi55LCBcblx0XHRcdFx0XHRcdFx0XHRpdGVtLmluaXRpYWxab29tTGV2ZWwsXG5cdFx0XHRcdFx0XHRcdFx0aXRlbSk7XG5cdFx0fVxuXHR9LFxuXHRfc2V0VHJhbnNsYXRlWCA9IGZ1bmN0aW9uKHgsIGVsU3R5bGUpIHtcblx0XHRlbFN0eWxlW190cmFuc2Zvcm1LZXldID0gX3RyYW5zbGF0ZVByZWZpeCArIHggKyAncHgsIDBweCcgKyBfdHJhbnNsYXRlU3VmaXg7XG5cdH0sXG5cdF9tb3ZlTWFpblNjcm9sbCA9IGZ1bmN0aW9uKHgsIGRyYWdnaW5nKSB7XG5cblx0XHRpZighX29wdGlvbnMubG9vcCAmJiBkcmFnZ2luZykge1xuXHRcdFx0dmFyIG5ld1NsaWRlSW5kZXhPZmZzZXQgPSBfY3VycmVudEl0ZW1JbmRleCArIChfc2xpZGVTaXplLnggKiBfY3VyclBvc2l0aW9uSW5kZXggLSB4KSAvIF9zbGlkZVNpemUueCxcblx0XHRcdFx0ZGVsdGEgPSBNYXRoLnJvdW5kKHggLSBfbWFpblNjcm9sbFBvcy54KTtcblxuXHRcdFx0aWYoIChuZXdTbGlkZUluZGV4T2Zmc2V0IDwgMCAmJiBkZWx0YSA+IDApIHx8IFxuXHRcdFx0XHQobmV3U2xpZGVJbmRleE9mZnNldCA+PSBfZ2V0TnVtSXRlbXMoKSAtIDEgJiYgZGVsdGEgPCAwKSApIHtcblx0XHRcdFx0eCA9IF9tYWluU2Nyb2xsUG9zLnggKyBkZWx0YSAqIF9vcHRpb25zLm1haW5TY3JvbGxFbmRGcmljdGlvbjtcblx0XHRcdH0gXG5cdFx0fVxuXHRcdFxuXHRcdF9tYWluU2Nyb2xsUG9zLnggPSB4O1xuXHRcdF9zZXRUcmFuc2xhdGVYKHgsIF9jb250YWluZXJTdHlsZSk7XG5cdH0sXG5cdF9jYWxjdWxhdGVQYW5PZmZzZXQgPSBmdW5jdGlvbihheGlzLCB6b29tTGV2ZWwpIHtcblx0XHR2YXIgbSA9IF9taWRab29tUG9pbnRbYXhpc10gLSBfb2Zmc2V0W2F4aXNdO1xuXHRcdHJldHVybiBfc3RhcnRQYW5PZmZzZXRbYXhpc10gKyBfY3VyclBhbkRpc3RbYXhpc10gKyBtIC0gbSAqICggem9vbUxldmVsIC8gX3N0YXJ0Wm9vbUxldmVsICk7XG5cdH0sXG5cdFxuXHRfZXF1YWxpemVQb2ludHMgPSBmdW5jdGlvbihwMSwgcDIpIHtcblx0XHRwMS54ID0gcDIueDtcblx0XHRwMS55ID0gcDIueTtcblx0XHRpZihwMi5pZCkge1xuXHRcdFx0cDEuaWQgPSBwMi5pZDtcblx0XHR9XG5cdH0sXG5cdF9yb3VuZFBvaW50ID0gZnVuY3Rpb24ocCkge1xuXHRcdHAueCA9IE1hdGgucm91bmQocC54KTtcblx0XHRwLnkgPSBNYXRoLnJvdW5kKHAueSk7XG5cdH0sXG5cblx0X21vdXNlTW92ZVRpbWVvdXQgPSBudWxsLFxuXHRfb25GaXJzdE1vdXNlTW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFdhaXQgdW50aWwgbW91c2UgbW92ZSBldmVudCBpcyBmaXJlZCBhdCBsZWFzdCB0d2ljZSBkdXJpbmcgMTAwbXNcblx0XHQvLyBXZSBkbyB0aGlzLCBiZWNhdXNlIHNvbWUgbW9iaWxlIGJyb3dzZXJzIHRyaWdnZXIgaXQgb24gdG91Y2hzdGFydFxuXHRcdGlmKF9tb3VzZU1vdmVUaW1lb3V0ICkgeyBcblx0XHRcdGZyYW1ld29yay51bmJpbmQoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCBfb25GaXJzdE1vdXNlTW92ZSk7XG5cdFx0XHRmcmFtZXdvcmsuYWRkQ2xhc3ModGVtcGxhdGUsICdwc3dwLS1oYXNfbW91c2UnKTtcblx0XHRcdF9vcHRpb25zLm1vdXNlVXNlZCA9IHRydWU7XG5cdFx0XHRfc2hvdXQoJ21vdXNlVXNlZCcpO1xuXHRcdH1cblx0XHRfbW91c2VNb3ZlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRfbW91c2VNb3ZlVGltZW91dCA9IG51bGw7XG5cdFx0fSwgMTAwKTtcblx0fSxcblxuXHRfYmluZEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuXHRcdGZyYW1ld29yay5iaW5kKGRvY3VtZW50LCAna2V5ZG93bicsIHNlbGYpO1xuXG5cdFx0aWYoX2ZlYXR1cmVzLnRyYW5zZm9ybSkge1xuXHRcdFx0Ly8gZG9uJ3QgYmluZCBjbGljayBldmVudCBpbiBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdHJhbnNmb3JtIChtb3N0bHkgSUU4KVxuXHRcdFx0ZnJhbWV3b3JrLmJpbmQoc2VsZi5zY3JvbGxXcmFwLCAnY2xpY2snLCBzZWxmKTtcblx0XHR9XG5cdFx0XG5cblx0XHRpZighX29wdGlvbnMubW91c2VVc2VkKSB7XG5cdFx0XHRmcmFtZXdvcmsuYmluZChkb2N1bWVudCwgJ21vdXNlbW92ZScsIF9vbkZpcnN0TW91c2VNb3ZlKTtcblx0XHR9XG5cblx0XHRmcmFtZXdvcmsuYmluZCh3aW5kb3csICdyZXNpemUgc2Nyb2xsIG9yaWVudGF0aW9uY2hhbmdlJywgc2VsZik7XG5cblx0XHRfc2hvdXQoJ2JpbmRFdmVudHMnKTtcblx0fSxcblxuXHRfdW5iaW5kRXZlbnRzID0gZnVuY3Rpb24oKSB7XG5cdFx0ZnJhbWV3b3JrLnVuYmluZCh3aW5kb3csICdyZXNpemUgc2Nyb2xsIG9yaWVudGF0aW9uY2hhbmdlJywgc2VsZik7XG5cdFx0ZnJhbWV3b3JrLnVuYmluZCh3aW5kb3csICdzY3JvbGwnLCBfZ2xvYmFsRXZlbnRIYW5kbGVycy5zY3JvbGwpO1xuXHRcdGZyYW1ld29yay51bmJpbmQoZG9jdW1lbnQsICdrZXlkb3duJywgc2VsZik7XG5cdFx0ZnJhbWV3b3JrLnVuYmluZChkb2N1bWVudCwgJ21vdXNlbW92ZScsIF9vbkZpcnN0TW91c2VNb3ZlKTtcblxuXHRcdGlmKF9mZWF0dXJlcy50cmFuc2Zvcm0pIHtcblx0XHRcdGZyYW1ld29yay51bmJpbmQoc2VsZi5zY3JvbGxXcmFwLCAnY2xpY2snLCBzZWxmKTtcblx0XHR9XG5cblx0XHRpZihfaXNEcmFnZ2luZykge1xuXHRcdFx0ZnJhbWV3b3JrLnVuYmluZCh3aW5kb3csIF91cE1vdmVFdmVudHMsIHNlbGYpO1xuXHRcdH1cblxuXHRcdGNsZWFyVGltZW91dChfb3JpZW50YXRpb25DaGFuZ2VUaW1lb3V0KTtcblxuXHRcdF9zaG91dCgndW5iaW5kRXZlbnRzJyk7XG5cdH0sXG5cdFxuXHRfY2FsY3VsYXRlUGFuQm91bmRzID0gZnVuY3Rpb24oem9vbUxldmVsLCB1cGRhdGUpIHtcblx0XHR2YXIgYm91bmRzID0gX2NhbGN1bGF0ZUl0ZW1TaXplKCBzZWxmLmN1cnJJdGVtLCBfdmlld3BvcnRTaXplLCB6b29tTGV2ZWwgKTtcblx0XHRpZih1cGRhdGUpIHtcblx0XHRcdF9jdXJyUGFuQm91bmRzID0gYm91bmRzO1xuXHRcdH1cblx0XHRyZXR1cm4gYm91bmRzO1xuXHR9LFxuXHRcblx0X2dldE1pblpvb21MZXZlbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRpZighaXRlbSkge1xuXHRcdFx0aXRlbSA9IHNlbGYuY3Vyckl0ZW07XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtLmluaXRpYWxab29tTGV2ZWw7XG5cdH0sXG5cdF9nZXRNYXhab29tTGV2ZWwgPSBmdW5jdGlvbihpdGVtKSB7XG5cdFx0aWYoIWl0ZW0pIHtcblx0XHRcdGl0ZW0gPSBzZWxmLmN1cnJJdGVtO1xuXHRcdH1cblx0XHRyZXR1cm4gaXRlbS53ID4gMCA/IF9vcHRpb25zLm1heFNwcmVhZFpvb20gOiAxO1xuXHR9LFxuXG5cdC8vIFJldHVybiB0cnVlIGlmIG9mZnNldCBpcyBvdXQgb2YgdGhlIGJvdW5kc1xuXHRfbW9kaWZ5RGVzdFBhbk9mZnNldCA9IGZ1bmN0aW9uKGF4aXMsIGRlc3RQYW5Cb3VuZHMsIGRlc3RQYW5PZmZzZXQsIGRlc3Rab29tTGV2ZWwpIHtcblx0XHRpZihkZXN0Wm9vbUxldmVsID09PSBzZWxmLmN1cnJJdGVtLmluaXRpYWxab29tTGV2ZWwpIHtcblx0XHRcdGRlc3RQYW5PZmZzZXRbYXhpc10gPSBzZWxmLmN1cnJJdGVtLmluaXRpYWxQb3NpdGlvbltheGlzXTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZXN0UGFuT2Zmc2V0W2F4aXNdID0gX2NhbGN1bGF0ZVBhbk9mZnNldChheGlzLCBkZXN0Wm9vbUxldmVsKTsgXG5cblx0XHRcdGlmKGRlc3RQYW5PZmZzZXRbYXhpc10gPiBkZXN0UGFuQm91bmRzLm1pbltheGlzXSkge1xuXHRcdFx0XHRkZXN0UGFuT2Zmc2V0W2F4aXNdID0gZGVzdFBhbkJvdW5kcy5taW5bYXhpc107XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSBlbHNlIGlmKGRlc3RQYW5PZmZzZXRbYXhpc10gPCBkZXN0UGFuQm91bmRzLm1heFtheGlzXSApIHtcblx0XHRcdFx0ZGVzdFBhbk9mZnNldFtheGlzXSA9IGRlc3RQYW5Cb3VuZHMubWF4W2F4aXNdO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9zZXR1cFRyYW5zZm9ybXMgPSBmdW5jdGlvbigpIHtcblxuXHRcdGlmKF90cmFuc2Zvcm1LZXkpIHtcblx0XHRcdC8vIHNldHVwIDNkIHRyYW5zZm9ybXNcblx0XHRcdHZhciBhbGxvdzNkVHJhbnNmb3JtID0gX2ZlYXR1cmVzLnBlcnNwZWN0aXZlICYmICFfbGlrZWx5VG91Y2hEZXZpY2U7XG5cdFx0XHRfdHJhbnNsYXRlUHJlZml4ID0gJ3RyYW5zbGF0ZScgKyAoYWxsb3czZFRyYW5zZm9ybSA/ICczZCgnIDogJygnKTtcblx0XHRcdF90cmFuc2xhdGVTdWZpeCA9IF9mZWF0dXJlcy5wZXJzcGVjdGl2ZSA/ICcsIDBweCknIDogJyknO1x0XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT3ZlcnJpZGUgem9vbS9wYW4vbW92ZSBmdW5jdGlvbnMgaW4gY2FzZSBvbGQgYnJvd3NlciBpcyB1c2VkIChtb3N0IGxpa2VseSBJRSlcblx0XHQvLyAoc28gdGhleSB1c2UgbGVmdC90b3Avd2lkdGgvaGVpZ2h0LCBpbnN0ZWFkIG9mIENTUyB0cmFuc2Zvcm0pXG5cdFxuXHRcdF90cmFuc2Zvcm1LZXkgPSAnbGVmdCc7XG5cdFx0ZnJhbWV3b3JrLmFkZENsYXNzKHRlbXBsYXRlLCAncHN3cC0taWUnKTtcblxuXHRcdF9zZXRUcmFuc2xhdGVYID0gZnVuY3Rpb24oeCwgZWxTdHlsZSkge1xuXHRcdFx0ZWxTdHlsZS5sZWZ0ID0geCArICdweCc7XG5cdFx0fTtcblx0XHRfYXBwbHlab29tUGFuVG9JdGVtID0gZnVuY3Rpb24oaXRlbSkge1xuXG5cdFx0XHR2YXIgem9vbVJhdGlvID0gaXRlbS5maXRSYXRpbyA+IDEgPyAxIDogaXRlbS5maXRSYXRpbyxcblx0XHRcdFx0cyA9IGl0ZW0uY29udGFpbmVyLnN0eWxlLFxuXHRcdFx0XHR3ID0gem9vbVJhdGlvICogaXRlbS53LFxuXHRcdFx0XHRoID0gem9vbVJhdGlvICogaXRlbS5oO1xuXG5cdFx0XHRzLndpZHRoID0gdyArICdweCc7XG5cdFx0XHRzLmhlaWdodCA9IGggKyAncHgnO1xuXHRcdFx0cy5sZWZ0ID0gaXRlbS5pbml0aWFsUG9zaXRpb24ueCArICdweCc7XG5cdFx0XHRzLnRvcCA9IGl0ZW0uaW5pdGlhbFBvc2l0aW9uLnkgKyAncHgnO1xuXG5cdFx0fTtcblx0XHRfYXBwbHlDdXJyZW50Wm9vbVBhbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYoX2N1cnJab29tRWxlbWVudFN0eWxlKSB7XG5cblx0XHRcdFx0dmFyIHMgPSBfY3Vyclpvb21FbGVtZW50U3R5bGUsXG5cdFx0XHRcdFx0aXRlbSA9IHNlbGYuY3Vyckl0ZW0sXG5cdFx0XHRcdFx0em9vbVJhdGlvID0gaXRlbS5maXRSYXRpbyA+IDEgPyAxIDogaXRlbS5maXRSYXRpbyxcblx0XHRcdFx0XHR3ID0gem9vbVJhdGlvICogaXRlbS53LFxuXHRcdFx0XHRcdGggPSB6b29tUmF0aW8gKiBpdGVtLmg7XG5cblx0XHRcdFx0cy53aWR0aCA9IHcgKyAncHgnO1xuXHRcdFx0XHRzLmhlaWdodCA9IGggKyAncHgnO1xuXG5cblx0XHRcdFx0cy5sZWZ0ID0gX3Bhbk9mZnNldC54ICsgJ3B4Jztcblx0XHRcdFx0cy50b3AgPSBfcGFuT2Zmc2V0LnkgKyAncHgnO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0fTtcblx0fSxcblxuXHRfb25LZXlEb3duID0gZnVuY3Rpb24oZSkge1xuXHRcdHZhciBrZXlkb3duQWN0aW9uID0gJyc7XG5cdFx0aWYoX29wdGlvbnMuZXNjS2V5ICYmIGUua2V5Q29kZSA9PT0gMjcpIHsgXG5cdFx0XHRrZXlkb3duQWN0aW9uID0gJ2Nsb3NlJztcblx0XHR9IGVsc2UgaWYoX29wdGlvbnMuYXJyb3dLZXlzKSB7XG5cdFx0XHRpZihlLmtleUNvZGUgPT09IDM3KSB7XG5cdFx0XHRcdGtleWRvd25BY3Rpb24gPSAncHJldic7XG5cdFx0XHR9IGVsc2UgaWYoZS5rZXlDb2RlID09PSAzOSkgeyBcblx0XHRcdFx0a2V5ZG93bkFjdGlvbiA9ICduZXh0Jztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZihrZXlkb3duQWN0aW9uKSB7XG5cdFx0XHQvLyBkb24ndCBkbyBhbnl0aGluZyBpZiBzcGVjaWFsIGtleSBwcmVzc2VkIHRvIHByZXZlbnQgZnJvbSBvdmVycmlkaW5nIGRlZmF1bHQgYnJvd3NlciBhY3Rpb25zXG5cdFx0XHQvLyBlLmcuIGluIENocm9tZSBvbiBNYWMgY21kK2Fycm93LWxlZnQgcmV0dXJucyB0byBwcmV2aW91cyBwYWdlXG5cdFx0XHRpZiggIWUuY3RybEtleSAmJiAhZS5hbHRLZXkgJiYgIWUuc2hpZnRLZXkgJiYgIWUubWV0YUtleSApIHtcblx0XHRcdFx0aWYoZS5wcmV2ZW50RGVmYXVsdCkge1xuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlLnJldHVyblZhbHVlID0gZmFsc2U7XG5cdFx0XHRcdH0gXG5cdFx0XHRcdHNlbGZba2V5ZG93bkFjdGlvbl0oKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X29uR2xvYmFsQ2xpY2sgPSBmdW5jdGlvbihlKSB7XG5cdFx0aWYoIWUpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBkb24ndCBhbGxvdyBjbGljayBldmVudCB0byBwYXNzIHRocm91Z2ggd2hlbiB0cmlnZ2VyaW5nIGFmdGVyIGRyYWcgb3Igc29tZSBvdGhlciBnZXN0dXJlXG5cdFx0aWYoX21vdmVkIHx8IF96b29tU3RhcnRlZCB8fCBfbWFpblNjcm9sbEFuaW1hdGluZyB8fCBfdmVydGljYWxEcmFnSW5pdGlhdGVkKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlUGFnZVNjcm9sbE9mZnNldCA9IGZ1bmN0aW9uKCkge1xuXHRcdHNlbGYuc2V0U2Nyb2xsT2Zmc2V0KDAsIGZyYW1ld29yay5nZXRTY3JvbGxZKCkpO1x0XHRcblx0fTtcblx0XG5cblxuXHRcblxuXG5cbi8vIE1pY3JvIGFuaW1hdGlvbiBlbmdpbmVcbnZhciBfYW5pbWF0aW9ucyA9IHt9LFxuXHRfbnVtQW5pbWF0aW9ucyA9IDAsXG5cdF9zdG9wQW5pbWF0aW9uID0gZnVuY3Rpb24obmFtZSkge1xuXHRcdGlmKF9hbmltYXRpb25zW25hbWVdKSB7XG5cdFx0XHRpZihfYW5pbWF0aW9uc1tuYW1lXS5yYWYpIHtcblx0XHRcdFx0X2NhbmNlbEFGKCBfYW5pbWF0aW9uc1tuYW1lXS5yYWYgKTtcblx0XHRcdH1cblx0XHRcdF9udW1BbmltYXRpb25zLS07XG5cdFx0XHRkZWxldGUgX2FuaW1hdGlvbnNbbmFtZV07XG5cdFx0fVxuXHR9LFxuXHRfcmVnaXN0ZXJTdGFydEFuaW1hdGlvbiA9IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRpZihfYW5pbWF0aW9uc1tuYW1lXSkge1xuXHRcdFx0X3N0b3BBbmltYXRpb24obmFtZSk7XG5cdFx0fVxuXHRcdGlmKCFfYW5pbWF0aW9uc1tuYW1lXSkge1xuXHRcdFx0X251bUFuaW1hdGlvbnMrKztcblx0XHRcdF9hbmltYXRpb25zW25hbWVdID0ge307XG5cdFx0fVxuXHR9LFxuXHRfc3RvcEFsbEFuaW1hdGlvbnMgPSBmdW5jdGlvbigpIHtcblx0XHRmb3IgKHZhciBwcm9wIGluIF9hbmltYXRpb25zKSB7XG5cblx0XHRcdGlmKCBfYW5pbWF0aW9ucy5oYXNPd25Qcm9wZXJ0eSggcHJvcCApICkge1xuXHRcdFx0XHRfc3RvcEFuaW1hdGlvbihwcm9wKTtcblx0XHRcdH0gXG5cdFx0XHRcblx0XHR9XG5cdH0sXG5cdF9hbmltYXRlUHJvcCA9IGZ1bmN0aW9uKG5hbWUsIGIsIGVuZFByb3AsIGQsIGVhc2luZ0ZuLCBvblVwZGF0ZSwgb25Db21wbGV0ZSkge1xuXHRcdHZhciBzdGFydEFuaW1UaW1lID0gX2dldEN1cnJlbnRUaW1lKCksIHQ7XG5cdFx0X3JlZ2lzdGVyU3RhcnRBbmltYXRpb24obmFtZSk7XG5cblx0XHR2YXIgYW5pbWxvb3AgPSBmdW5jdGlvbigpe1xuXHRcdFx0aWYgKCBfYW5pbWF0aW9uc1tuYW1lXSApIHtcblx0XHRcdFx0XG5cdFx0XHRcdHQgPSBfZ2V0Q3VycmVudFRpbWUoKSAtIHN0YXJ0QW5pbVRpbWU7IC8vIHRpbWUgZGlmZlxuXHRcdFx0XHQvL2IgLSBiZWdpbm5pbmcgKHN0YXJ0IHByb3ApXG5cdFx0XHRcdC8vZCAtIGFuaW0gZHVyYXRpb25cblxuXHRcdFx0XHRpZiAoIHQgPj0gZCApIHtcblx0XHRcdFx0XHRfc3RvcEFuaW1hdGlvbihuYW1lKTtcblx0XHRcdFx0XHRvblVwZGF0ZShlbmRQcm9wKTtcblx0XHRcdFx0XHRpZihvbkNvbXBsZXRlKSB7XG5cdFx0XHRcdFx0XHRvbkNvbXBsZXRlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRvblVwZGF0ZSggKGVuZFByb3AgLSBiKSAqIGVhc2luZ0ZuKHQvZCkgKyBiICk7XG5cblx0XHRcdFx0X2FuaW1hdGlvbnNbbmFtZV0ucmFmID0gX3JlcXVlc3RBRihhbmltbG9vcCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRhbmltbG9vcCgpO1xuXHR9O1xuXHRcblxuXG52YXIgcHVibGljTWV0aG9kcyA9IHtcblxuXHQvLyBtYWtlIGEgZmV3IGxvY2FsIHZhcmlhYmxlcyBhbmQgZnVuY3Rpb25zIHB1YmxpY1xuXHRzaG91dDogX3Nob3V0LFxuXHRsaXN0ZW46IF9saXN0ZW4sXG5cdHZpZXdwb3J0U2l6ZTogX3ZpZXdwb3J0U2l6ZSxcblx0b3B0aW9uczogX29wdGlvbnMsXG5cblx0aXNNYWluU2Nyb2xsQW5pbWF0aW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gX21haW5TY3JvbGxBbmltYXRpbmc7XG5cdH0sXG5cdGdldFpvb21MZXZlbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIF9jdXJyWm9vbUxldmVsO1xuXHR9LFxuXHRnZXRDdXJyZW50SW5kZXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBfY3VycmVudEl0ZW1JbmRleDtcblx0fSxcblx0aXNEcmFnZ2luZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIF9pc0RyYWdnaW5nO1xuXHR9LFx0XG5cdGlzWm9vbWluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIF9pc1pvb21pbmc7XG5cdH0sXG5cdHNldFNjcm9sbE9mZnNldDogZnVuY3Rpb24oeCx5KSB7XG5cdFx0X29mZnNldC54ID0geDtcblx0XHRfY3VycmVudFdpbmRvd1Njcm9sbFkgPSBfb2Zmc2V0LnkgPSB5O1xuXHRcdF9zaG91dCgndXBkYXRlU2Nyb2xsT2Zmc2V0JywgX29mZnNldCk7XG5cdH0sXG5cdGFwcGx5Wm9vbVBhbjogZnVuY3Rpb24oem9vbUxldmVsLHBhblgscGFuWSxhbGxvd1JlbmRlclJlc29sdXRpb24pIHtcblx0XHRfcGFuT2Zmc2V0LnggPSBwYW5YO1xuXHRcdF9wYW5PZmZzZXQueSA9IHBhblk7XG5cdFx0X2N1cnJab29tTGV2ZWwgPSB6b29tTGV2ZWw7XG5cdFx0X2FwcGx5Q3VycmVudFpvb21QYW4oIGFsbG93UmVuZGVyUmVzb2x1dGlvbiApO1xuXHR9LFxuXG5cdGluaXQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0aWYoX2lzT3BlbiB8fCBfaXNEZXN0cm95aW5nKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGk7XG5cblx0XHRzZWxmLmZyYW1ld29yayA9IGZyYW1ld29yazsgLy8gYmFzaWMgZnVuY3Rpb25hbGl0eVxuXHRcdHNlbGYudGVtcGxhdGUgPSB0ZW1wbGF0ZTsgLy8gcm9vdCBET00gZWxlbWVudCBvZiBQaG90b1N3aXBlXG5cdFx0c2VsZi5iZyA9IGZyYW1ld29yay5nZXRDaGlsZEJ5Q2xhc3ModGVtcGxhdGUsICdwc3dwX19iZycpO1xuXG5cdFx0X2luaXRhbENsYXNzTmFtZSA9IHRlbXBsYXRlLmNsYXNzTmFtZTtcblx0XHRfaXNPcGVuID0gdHJ1ZTtcblx0XHRcdFx0XG5cdFx0X2ZlYXR1cmVzID0gZnJhbWV3b3JrLmRldGVjdEZlYXR1cmVzKCk7XG5cdFx0X3JlcXVlc3RBRiA9IF9mZWF0dXJlcy5yYWY7XG5cdFx0X2NhbmNlbEFGID0gX2ZlYXR1cmVzLmNhZjtcblx0XHRfdHJhbnNmb3JtS2V5ID0gX2ZlYXR1cmVzLnRyYW5zZm9ybTtcblx0XHRfb2xkSUUgPSBfZmVhdHVyZXMub2xkSUU7XG5cdFx0XG5cdFx0c2VsZi5zY3JvbGxXcmFwID0gZnJhbWV3b3JrLmdldENoaWxkQnlDbGFzcyh0ZW1wbGF0ZSwgJ3Bzd3BfX3Njcm9sbC13cmFwJyk7XG5cdFx0c2VsZi5jb250YWluZXIgPSBmcmFtZXdvcmsuZ2V0Q2hpbGRCeUNsYXNzKHNlbGYuc2Nyb2xsV3JhcCwgJ3Bzd3BfX2NvbnRhaW5lcicpO1xuXG5cdFx0X2NvbnRhaW5lclN0eWxlID0gc2VsZi5jb250YWluZXIuc3R5bGU7IC8vIGZvciBmYXN0IGFjY2Vzc1xuXG5cdFx0Ly8gT2JqZWN0cyB0aGF0IGhvbGQgc2xpZGVzICh0aGVyZSBhcmUgb25seSAzIGluIERPTSlcblx0XHRzZWxmLml0ZW1Ib2xkZXJzID0gX2l0ZW1Ib2xkZXJzID0gW1xuXHRcdFx0e2VsOnNlbGYuY29udGFpbmVyLmNoaWxkcmVuWzBdICwgd3JhcDowLCBpbmRleDogLTF9LFxuXHRcdFx0e2VsOnNlbGYuY29udGFpbmVyLmNoaWxkcmVuWzFdICwgd3JhcDowLCBpbmRleDogLTF9LFxuXHRcdFx0e2VsOnNlbGYuY29udGFpbmVyLmNoaWxkcmVuWzJdICwgd3JhcDowLCBpbmRleDogLTF9XG5cdFx0XTtcblxuXHRcdC8vIGhpZGUgbmVhcmJ5IGl0ZW0gaG9sZGVycyB1bnRpbCBpbml0aWFsIHpvb20gYW5pbWF0aW9uIGZpbmlzaGVzICh0byBhdm9pZCBleHRyYSBQYWludHMpXG5cdFx0X2l0ZW1Ib2xkZXJzWzBdLmVsLnN0eWxlLmRpc3BsYXkgPSBfaXRlbUhvbGRlcnNbMl0uZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuXHRcdF9zZXR1cFRyYW5zZm9ybXMoKTtcblxuXHRcdC8vIFNldHVwIGdsb2JhbCBldmVudHNcblx0XHRfZ2xvYmFsRXZlbnRIYW5kbGVycyA9IHtcblx0XHRcdHJlc2l6ZTogc2VsZi51cGRhdGVTaXplLFxuXG5cdFx0XHQvLyBGaXhlczogaU9TIDEwLjMgcmVzaXplIGV2ZW50XG5cdFx0XHQvLyBkb2VzIG5vdCB1cGRhdGUgc2Nyb2xsV3JhcC5jbGllbnRXaWR0aCBpbnN0YW50bHkgYWZ0ZXIgcmVzaXplXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vZGltc2VtZW5vdi9QaG90b1N3aXBlL2lzc3Vlcy8xMzE1XG5cdFx0XHRvcmllbnRhdGlvbmNoYW5nZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNsZWFyVGltZW91dChfb3JpZW50YXRpb25DaGFuZ2VUaW1lb3V0KTtcblx0XHRcdFx0X29yaWVudGF0aW9uQ2hhbmdlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYoX3ZpZXdwb3J0U2l6ZS54ICE9PSBzZWxmLnNjcm9sbFdyYXAuY2xpZW50V2lkdGgpIHtcblx0XHRcdFx0XHRcdHNlbGYudXBkYXRlU2l6ZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgNTAwKTtcblx0XHRcdH0sXG5cdFx0XHRzY3JvbGw6IF91cGRhdGVQYWdlU2Nyb2xsT2Zmc2V0LFxuXHRcdFx0a2V5ZG93bjogX29uS2V5RG93bixcblx0XHRcdGNsaWNrOiBfb25HbG9iYWxDbGlja1xuXHRcdH07XG5cblx0XHQvLyBkaXNhYmxlIHNob3cvaGlkZSBlZmZlY3RzIG9uIG9sZCBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgQ1NTIGFuaW1hdGlvbnMgb3IgdHJhbnNmb3JtcywgXG5cdFx0Ly8gb2xkIElPUywgQW5kcm9pZCBhbmQgT3BlcmEgbW9iaWxlLiBCbGFja2JlcnJ5IHNlZW1zIHRvIHdvcmsgZmluZSwgZXZlbiBvbGRlciBtb2RlbHMuXG5cdFx0dmFyIG9sZFBob25lID0gX2ZlYXR1cmVzLmlzT2xkSU9TUGhvbmUgfHwgX2ZlYXR1cmVzLmlzT2xkQW5kcm9pZCB8fCBfZmVhdHVyZXMuaXNNb2JpbGVPcGVyYTtcblx0XHRpZighX2ZlYXR1cmVzLmFuaW1hdGlvbk5hbWUgfHwgIV9mZWF0dXJlcy50cmFuc2Zvcm0gfHwgb2xkUGhvbmUpIHtcblx0XHRcdF9vcHRpb25zLnNob3dBbmltYXRpb25EdXJhdGlvbiA9IF9vcHRpb25zLmhpZGVBbmltYXRpb25EdXJhdGlvbiA9IDA7XG5cdFx0fVxuXG5cdFx0Ly8gaW5pdCBtb2R1bGVzXG5cdFx0Zm9yKGkgPSAwOyBpIDwgX21vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHNlbGZbJ2luaXQnICsgX21vZHVsZXNbaV1dKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIGluaXRcblx0XHRpZihVaUNsYXNzKSB7XG5cdFx0XHR2YXIgdWkgPSBzZWxmLnVpID0gbmV3IFVpQ2xhc3Moc2VsZiwgZnJhbWV3b3JrKTtcblx0XHRcdHVpLmluaXQoKTtcblx0XHR9XG5cblx0XHRfc2hvdXQoJ2ZpcnN0VXBkYXRlJyk7XG5cdFx0X2N1cnJlbnRJdGVtSW5kZXggPSBfY3VycmVudEl0ZW1JbmRleCB8fCBfb3B0aW9ucy5pbmRleCB8fCAwO1xuXHRcdC8vIHZhbGlkYXRlIGluZGV4XG5cdFx0aWYoIGlzTmFOKF9jdXJyZW50SXRlbUluZGV4KSB8fCBfY3VycmVudEl0ZW1JbmRleCA8IDAgfHwgX2N1cnJlbnRJdGVtSW5kZXggPj0gX2dldE51bUl0ZW1zKCkgKSB7XG5cdFx0XHRfY3VycmVudEl0ZW1JbmRleCA9IDA7XG5cdFx0fVxuXHRcdHNlbGYuY3Vyckl0ZW0gPSBfZ2V0SXRlbUF0KCBfY3VycmVudEl0ZW1JbmRleCApO1xuXG5cdFx0XG5cdFx0aWYoX2ZlYXR1cmVzLmlzT2xkSU9TUGhvbmUgfHwgX2ZlYXR1cmVzLmlzT2xkQW5kcm9pZCkge1xuXHRcdFx0X2lzRml4ZWRQb3NpdGlvbiA9IGZhbHNlO1xuXHRcdH1cblx0XHRcblx0XHR0ZW1wbGF0ZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ2ZhbHNlJyk7XG5cdFx0aWYoX29wdGlvbnMubW9kYWwpIHtcblx0XHRcdGlmKCFfaXNGaXhlZFBvc2l0aW9uKSB7XG5cdFx0XHRcdHRlbXBsYXRlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblx0XHRcdFx0dGVtcGxhdGUuc3R5bGUudG9wID0gZnJhbWV3b3JrLmdldFNjcm9sbFkoKSArICdweCc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0ZW1wbGF0ZS5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYoX2N1cnJlbnRXaW5kb3dTY3JvbGxZID09PSB1bmRlZmluZWQpIHtcblx0XHRcdF9zaG91dCgnaW5pdGlhbExheW91dCcpO1xuXHRcdFx0X2N1cnJlbnRXaW5kb3dTY3JvbGxZID0gX2luaXRhbFdpbmRvd1Njcm9sbFkgPSBmcmFtZXdvcmsuZ2V0U2Nyb2xsWSgpO1xuXHRcdH1cblx0XHRcblx0XHQvLyBhZGQgY2xhc3NlcyB0byByb290IGVsZW1lbnQgb2YgUGhvdG9Td2lwZVxuXHRcdHZhciByb290Q2xhc3NlcyA9ICdwc3dwLS1vcGVuICc7XG5cdFx0aWYoX29wdGlvbnMubWFpbkNsYXNzKSB7XG5cdFx0XHRyb290Q2xhc3NlcyArPSBfb3B0aW9ucy5tYWluQ2xhc3MgKyAnICc7XG5cdFx0fVxuXHRcdGlmKF9vcHRpb25zLnNob3dIaWRlT3BhY2l0eSkge1xuXHRcdFx0cm9vdENsYXNzZXMgKz0gJ3Bzd3AtLWFuaW1hdGVfb3BhY2l0eSAnO1xuXHRcdH1cblx0XHRyb290Q2xhc3NlcyArPSBfbGlrZWx5VG91Y2hEZXZpY2UgPyAncHN3cC0tdG91Y2gnIDogJ3Bzd3AtLW5vdG91Y2gnO1xuXHRcdHJvb3RDbGFzc2VzICs9IF9mZWF0dXJlcy5hbmltYXRpb25OYW1lID8gJyBwc3dwLS1jc3NfYW5pbWF0aW9uJyA6ICcnO1xuXHRcdHJvb3RDbGFzc2VzICs9IF9mZWF0dXJlcy5zdmcgPyAnIHBzd3AtLXN2ZycgOiAnJztcblx0XHRmcmFtZXdvcmsuYWRkQ2xhc3ModGVtcGxhdGUsIHJvb3RDbGFzc2VzKTtcblxuXHRcdHNlbGYudXBkYXRlU2l6ZSgpO1xuXG5cdFx0Ly8gaW5pdGlhbCB1cGRhdGVcblx0XHRfY29udGFpbmVyU2hpZnRJbmRleCA9IC0xO1xuXHRcdF9pbmRleERpZmYgPSBudWxsO1xuXHRcdGZvcihpID0gMDsgaSA8IE5VTV9IT0xERVJTOyBpKyspIHtcblx0XHRcdF9zZXRUcmFuc2xhdGVYKCAoaStfY29udGFpbmVyU2hpZnRJbmRleCkgKiBfc2xpZGVTaXplLngsIF9pdGVtSG9sZGVyc1tpXS5lbC5zdHlsZSk7XG5cdFx0fVxuXG5cdFx0aWYoIV9vbGRJRSkge1xuXHRcdFx0ZnJhbWV3b3JrLmJpbmQoc2VsZi5zY3JvbGxXcmFwLCBfZG93bkV2ZW50cywgc2VsZik7IC8vIG5vIGRyYWdnaW5nIGZvciBvbGQgSUVcblx0XHR9XHRcblxuXHRcdF9saXN0ZW4oJ2luaXRpYWxab29tSW5FbmQnLCBmdW5jdGlvbigpIHtcblx0XHRcdHNlbGYuc2V0Q29udGVudChfaXRlbUhvbGRlcnNbMF0sIF9jdXJyZW50SXRlbUluZGV4LTEpO1xuXHRcdFx0c2VsZi5zZXRDb250ZW50KF9pdGVtSG9sZGVyc1syXSwgX2N1cnJlbnRJdGVtSW5kZXgrMSk7XG5cblx0XHRcdF9pdGVtSG9sZGVyc1swXS5lbC5zdHlsZS5kaXNwbGF5ID0gX2l0ZW1Ib2xkZXJzWzJdLmVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG5cdFx0XHRpZihfb3B0aW9ucy5mb2N1cykge1xuXHRcdFx0XHQvLyBmb2N1cyBjYXVzZXMgbGF5b3V0LCBcblx0XHRcdFx0Ly8gd2hpY2ggY2F1c2VzIGxhZyBkdXJpbmcgdGhlIGFuaW1hdGlvbiwgXG5cdFx0XHRcdC8vIHRoYXQncyB3aHkgd2UgZGVsYXkgaXQgdW50aWxsIHRoZSBpbml0aWFsIHpvb20gdHJhbnNpdGlvbiBlbmRzXG5cdFx0XHRcdHRlbXBsYXRlLmZvY3VzKCk7XG5cdFx0XHR9XG5cdFx0XHQgXG5cblx0XHRcdF9iaW5kRXZlbnRzKCk7XG5cdFx0fSk7XG5cblx0XHQvLyBzZXQgY29udGVudCBmb3IgY2VudGVyIHNsaWRlIChmaXJzdCB0aW1lKVxuXHRcdHNlbGYuc2V0Q29udGVudChfaXRlbUhvbGRlcnNbMV0sIF9jdXJyZW50SXRlbUluZGV4KTtcblx0XHRcblx0XHRzZWxmLnVwZGF0ZUN1cnJJdGVtKCk7XG5cblx0XHRfc2hvdXQoJ2FmdGVySW5pdCcpO1xuXG5cdFx0aWYoIV9pc0ZpeGVkUG9zaXRpb24pIHtcblxuXHRcdFx0Ly8gT24gYWxsIHZlcnNpb25zIG9mIGlPUyBsb3dlciB0aGFuIDguMCwgd2UgY2hlY2sgc2l6ZSBvZiB2aWV3cG9ydCBldmVyeSBzZWNvbmQuXG5cdFx0XHQvLyBcblx0XHRcdC8vIFRoaXMgaXMgZG9uZSB0byBkZXRlY3Qgd2hlbiBTYWZhcmkgdG9wICYgYm90dG9tIGJhcnMgYXBwZWFyLCBcblx0XHRcdC8vIGFzIHRoaXMgYWN0aW9uIGRvZXNuJ3QgdHJpZ2dlciBhbnkgZXZlbnRzIChsaWtlIHJlc2l6ZSkuIFxuXHRcdFx0Ly8gXG5cdFx0XHQvLyBPbiBpT1M4IHRoZXkgZml4ZWQgdGhpcy5cblx0XHRcdC8vIFxuXHRcdFx0Ly8gMTAgTm92IDIwMTQ6IGlPUyA3IHVzYWdlIH40MCUuIGlPUyA4IHVzYWdlIDU2JS5cblx0XHRcdFxuXHRcdFx0X3VwZGF0ZVNpemVJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZighX251bUFuaW1hdGlvbnMgJiYgIV9pc0RyYWdnaW5nICYmICFfaXNab29taW5nICYmIChfY3Vyclpvb21MZXZlbCA9PT0gc2VsZi5jdXJySXRlbS5pbml0aWFsWm9vbUxldmVsKSAgKSB7XG5cdFx0XHRcdFx0c2VsZi51cGRhdGVTaXplKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIDEwMDApO1xuXHRcdH1cblxuXHRcdGZyYW1ld29yay5hZGRDbGFzcyh0ZW1wbGF0ZSwgJ3Bzd3AtLXZpc2libGUnKTtcblx0fSxcblxuXHQvLyBDbG9zZSB0aGUgZ2FsbGVyeSwgdGhlbiBkZXN0cm95IGl0XG5cdGNsb3NlOiBmdW5jdGlvbigpIHtcblx0XHRpZighX2lzT3Blbikge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdF9pc09wZW4gPSBmYWxzZTtcblx0XHRfaXNEZXN0cm95aW5nID0gdHJ1ZTtcblx0XHRfc2hvdXQoJ2Nsb3NlJyk7XG5cdFx0X3VuYmluZEV2ZW50cygpO1xuXG5cdFx0X3Nob3dPckhpZGUoc2VsZi5jdXJySXRlbSwgbnVsbCwgdHJ1ZSwgc2VsZi5kZXN0cm95KTtcblx0fSxcblxuXHQvLyBkZXN0cm95cyB0aGUgZ2FsbGVyeSAodW5iaW5kcyBldmVudHMsIGNsZWFucyB1cCBpbnRlcnZhbHMgYW5kIHRpbWVvdXRzIHRvIGF2b2lkIG1lbW9yeSBsZWFrcylcblx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0X3Nob3V0KCdkZXN0cm95Jyk7XG5cblx0XHRpZihfc2hvd09ySGlkZVRpbWVvdXQpIHtcblx0XHRcdGNsZWFyVGltZW91dChfc2hvd09ySGlkZVRpbWVvdXQpO1xuXHRcdH1cblx0XHRcblx0XHR0ZW1wbGF0ZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblx0XHR0ZW1wbGF0ZS5jbGFzc05hbWUgPSBfaW5pdGFsQ2xhc3NOYW1lO1xuXG5cdFx0aWYoX3VwZGF0ZVNpemVJbnRlcnZhbCkge1xuXHRcdFx0Y2xlYXJJbnRlcnZhbChfdXBkYXRlU2l6ZUludGVydmFsKTtcblx0XHR9XG5cblx0XHRmcmFtZXdvcmsudW5iaW5kKHNlbGYuc2Nyb2xsV3JhcCwgX2Rvd25FdmVudHMsIHNlbGYpO1xuXG5cdFx0Ly8gd2UgdW5iaW5kIHNjcm9sbCBldmVudCBhdCB0aGUgZW5kLCBhcyBjbG9zaW5nIGFuaW1hdGlvbiBtYXkgZGVwZW5kIG9uIGl0XG5cdFx0ZnJhbWV3b3JrLnVuYmluZCh3aW5kb3csICdzY3JvbGwnLCBzZWxmKTtcblxuXHRcdF9zdG9wRHJhZ1VwZGF0ZUxvb3AoKTtcblxuXHRcdF9zdG9wQWxsQW5pbWF0aW9ucygpO1xuXG5cdFx0X2xpc3RlbmVycyA9IG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFBhbiBpbWFnZSB0byBwb3NpdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0geCAgICAgXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5ICAgICBcblx0ICogQHBhcmFtIHtCb29sZWFufSBmb3JjZSBXaWxsIGlnbm9yZSBib3VuZHMgaWYgc2V0IHRvIHRydWUuXG5cdCAqL1xuXHRwYW5UbzogZnVuY3Rpb24oeCx5LGZvcmNlKSB7XG5cdFx0aWYoIWZvcmNlKSB7XG5cdFx0XHRpZih4ID4gX2N1cnJQYW5Cb3VuZHMubWluLngpIHtcblx0XHRcdFx0eCA9IF9jdXJyUGFuQm91bmRzLm1pbi54O1xuXHRcdFx0fSBlbHNlIGlmKHggPCBfY3VyclBhbkJvdW5kcy5tYXgueCkge1xuXHRcdFx0XHR4ID0gX2N1cnJQYW5Cb3VuZHMubWF4Lng7XG5cdFx0XHR9XG5cblx0XHRcdGlmKHkgPiBfY3VyclBhbkJvdW5kcy5taW4ueSkge1xuXHRcdFx0XHR5ID0gX2N1cnJQYW5Cb3VuZHMubWluLnk7XG5cdFx0XHR9IGVsc2UgaWYoeSA8IF9jdXJyUGFuQm91bmRzLm1heC55KSB7XG5cdFx0XHRcdHkgPSBfY3VyclBhbkJvdW5kcy5tYXgueTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0X3Bhbk9mZnNldC54ID0geDtcblx0XHRfcGFuT2Zmc2V0LnkgPSB5O1xuXHRcdF9hcHBseUN1cnJlbnRab29tUGFuKCk7XG5cdH0sXG5cdFxuXHRoYW5kbGVFdmVudDogZnVuY3Rpb24gKGUpIHtcblx0XHRlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG5cdFx0aWYoX2dsb2JhbEV2ZW50SGFuZGxlcnNbZS50eXBlXSkge1xuXHRcdFx0X2dsb2JhbEV2ZW50SGFuZGxlcnNbZS50eXBlXShlKTtcblx0XHR9XG5cdH0sXG5cblxuXHRnb1RvOiBmdW5jdGlvbihpbmRleCkge1xuXG5cdFx0aW5kZXggPSBfZ2V0TG9vcGVkSWQoaW5kZXgpO1xuXG5cdFx0dmFyIGRpZmYgPSBpbmRleCAtIF9jdXJyZW50SXRlbUluZGV4O1xuXHRcdF9pbmRleERpZmYgPSBkaWZmO1xuXG5cdFx0X2N1cnJlbnRJdGVtSW5kZXggPSBpbmRleDtcblx0XHRzZWxmLmN1cnJJdGVtID0gX2dldEl0ZW1BdCggX2N1cnJlbnRJdGVtSW5kZXggKTtcblx0XHRfY3VyclBvc2l0aW9uSW5kZXggLT0gZGlmZjtcblx0XHRcblx0XHRfbW92ZU1haW5TY3JvbGwoX3NsaWRlU2l6ZS54ICogX2N1cnJQb3NpdGlvbkluZGV4KTtcblx0XHRcblxuXHRcdF9zdG9wQWxsQW5pbWF0aW9ucygpO1xuXHRcdF9tYWluU2Nyb2xsQW5pbWF0aW5nID0gZmFsc2U7XG5cblx0XHRzZWxmLnVwZGF0ZUN1cnJJdGVtKCk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHNlbGYuZ29UbyggX2N1cnJlbnRJdGVtSW5kZXggKyAxKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oKSB7XG5cdFx0c2VsZi5nb1RvKCBfY3VycmVudEl0ZW1JbmRleCAtIDEpO1xuXHR9LFxuXG5cdC8vIHVwZGF0ZSBjdXJyZW50IHpvb20vcGFuIG9iamVjdHNcblx0dXBkYXRlQ3Vyclpvb21JdGVtOiBmdW5jdGlvbihlbXVsYXRlU2V0Q29udGVudCkge1xuXHRcdGlmKGVtdWxhdGVTZXRDb250ZW50KSB7XG5cdFx0XHRfc2hvdXQoJ2JlZm9yZUNoYW5nZScsIDApO1xuXHRcdH1cblxuXHRcdC8vIGl0ZW1Ib2xkZXJbMV0gaXMgbWlkZGxlIChjdXJyZW50KSBpdGVtXG5cdFx0aWYoX2l0ZW1Ib2xkZXJzWzFdLmVsLmNoaWxkcmVuLmxlbmd0aCkge1xuXHRcdFx0dmFyIHpvb21FbGVtZW50ID0gX2l0ZW1Ib2xkZXJzWzFdLmVsLmNoaWxkcmVuWzBdO1xuXHRcdFx0aWYoIGZyYW1ld29yay5oYXNDbGFzcyh6b29tRWxlbWVudCwgJ3Bzd3BfX3pvb20td3JhcCcpICkge1xuXHRcdFx0XHRfY3Vyclpvb21FbGVtZW50U3R5bGUgPSB6b29tRWxlbWVudC5zdHlsZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdF9jdXJyWm9vbUVsZW1lbnRTdHlsZSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdF9jdXJyWm9vbUVsZW1lbnRTdHlsZSA9IG51bGw7XG5cdFx0fVxuXHRcdFxuXHRcdF9jdXJyUGFuQm91bmRzID0gc2VsZi5jdXJySXRlbS5ib3VuZHM7XHRcblx0XHRfc3RhcnRab29tTGV2ZWwgPSBfY3Vyclpvb21MZXZlbCA9IHNlbGYuY3Vyckl0ZW0uaW5pdGlhbFpvb21MZXZlbDtcblxuXHRcdF9wYW5PZmZzZXQueCA9IF9jdXJyUGFuQm91bmRzLmNlbnRlci54O1xuXHRcdF9wYW5PZmZzZXQueSA9IF9jdXJyUGFuQm91bmRzLmNlbnRlci55O1xuXG5cdFx0aWYoZW11bGF0ZVNldENvbnRlbnQpIHtcblx0XHRcdF9zaG91dCgnYWZ0ZXJDaGFuZ2UnKTtcblx0XHR9XG5cdH0sXG5cblxuXHRpbnZhbGlkYXRlQ3Vyckl0ZW1zOiBmdW5jdGlvbigpIHtcblx0XHRfaXRlbXNOZWVkVXBkYXRlID0gdHJ1ZTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgTlVNX0hPTERFUlM7IGkrKykge1xuXHRcdFx0aWYoIF9pdGVtSG9sZGVyc1tpXS5pdGVtICkge1xuXHRcdFx0XHRfaXRlbUhvbGRlcnNbaV0uaXRlbS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHVwZGF0ZUN1cnJJdGVtOiBmdW5jdGlvbihiZWZvcmVBbmltYXRpb24pIHtcblxuXHRcdGlmKF9pbmRleERpZmYgPT09IDApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgZGlmZkFicyA9IE1hdGguYWJzKF9pbmRleERpZmYpLFxuXHRcdFx0dGVtcEhvbGRlcjtcblxuXHRcdGlmKGJlZm9yZUFuaW1hdGlvbiAmJiBkaWZmQWJzIDwgMikge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXG5cdFx0c2VsZi5jdXJySXRlbSA9IF9nZXRJdGVtQXQoIF9jdXJyZW50SXRlbUluZGV4ICk7XG5cdFx0X3JlbmRlck1heFJlc29sdXRpb24gPSBmYWxzZTtcblx0XHRcblx0XHRfc2hvdXQoJ2JlZm9yZUNoYW5nZScsIF9pbmRleERpZmYpO1xuXG5cdFx0aWYoZGlmZkFicyA+PSBOVU1fSE9MREVSUykge1xuXHRcdFx0X2NvbnRhaW5lclNoaWZ0SW5kZXggKz0gX2luZGV4RGlmZiArIChfaW5kZXhEaWZmID4gMCA/IC1OVU1fSE9MREVSUyA6IE5VTV9IT0xERVJTKTtcblx0XHRcdGRpZmZBYnMgPSBOVU1fSE9MREVSUztcblx0XHR9XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGRpZmZBYnM7IGkrKykge1xuXHRcdFx0aWYoX2luZGV4RGlmZiA+IDApIHtcblx0XHRcdFx0dGVtcEhvbGRlciA9IF9pdGVtSG9sZGVycy5zaGlmdCgpO1xuXHRcdFx0XHRfaXRlbUhvbGRlcnNbTlVNX0hPTERFUlMtMV0gPSB0ZW1wSG9sZGVyOyAvLyBtb3ZlIGZpcnN0IHRvIGxhc3RcblxuXHRcdFx0XHRfY29udGFpbmVyU2hpZnRJbmRleCsrO1xuXHRcdFx0XHRfc2V0VHJhbnNsYXRlWCggKF9jb250YWluZXJTaGlmdEluZGV4KzIpICogX3NsaWRlU2l6ZS54LCB0ZW1wSG9sZGVyLmVsLnN0eWxlKTtcblx0XHRcdFx0c2VsZi5zZXRDb250ZW50KHRlbXBIb2xkZXIsIF9jdXJyZW50SXRlbUluZGV4IC0gZGlmZkFicyArIGkgKyAxICsgMSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0ZW1wSG9sZGVyID0gX2l0ZW1Ib2xkZXJzLnBvcCgpO1xuXHRcdFx0XHRfaXRlbUhvbGRlcnMudW5zaGlmdCggdGVtcEhvbGRlciApOyAvLyBtb3ZlIGxhc3QgdG8gZmlyc3RcblxuXHRcdFx0XHRfY29udGFpbmVyU2hpZnRJbmRleC0tO1xuXHRcdFx0XHRfc2V0VHJhbnNsYXRlWCggX2NvbnRhaW5lclNoaWZ0SW5kZXggKiBfc2xpZGVTaXplLngsIHRlbXBIb2xkZXIuZWwuc3R5bGUpO1xuXHRcdFx0XHRzZWxmLnNldENvbnRlbnQodGVtcEhvbGRlciwgX2N1cnJlbnRJdGVtSW5kZXggKyBkaWZmQWJzIC0gaSAtIDEgLSAxKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdH1cblxuXHRcdC8vIHJlc2V0IHpvb20vcGFuIG9uIHByZXZpb3VzIGl0ZW1cblx0XHRpZihfY3Vyclpvb21FbGVtZW50U3R5bGUgJiYgTWF0aC5hYnMoX2luZGV4RGlmZikgPT09IDEpIHtcblxuXHRcdFx0dmFyIHByZXZJdGVtID0gX2dldEl0ZW1BdChfcHJldkl0ZW1JbmRleCk7XG5cdFx0XHRpZihwcmV2SXRlbS5pbml0aWFsWm9vbUxldmVsICE9PSBfY3Vyclpvb21MZXZlbCkge1xuXHRcdFx0XHRfY2FsY3VsYXRlSXRlbVNpemUocHJldkl0ZW0gLCBfdmlld3BvcnRTaXplICk7XG5cdFx0XHRcdF9zZXRJbWFnZVNpemUocHJldkl0ZW0pO1xuXHRcdFx0XHRfYXBwbHlab29tUGFuVG9JdGVtKCBwcmV2SXRlbSApOyBcdFx0XHRcdFxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gcmVzZXQgZGlmZiBhZnRlciB1cGRhdGVcblx0XHRfaW5kZXhEaWZmID0gMDtcblxuXHRcdHNlbGYudXBkYXRlQ3Vyclpvb21JdGVtKCk7XG5cblx0XHRfcHJldkl0ZW1JbmRleCA9IF9jdXJyZW50SXRlbUluZGV4O1xuXG5cdFx0X3Nob3V0KCdhZnRlckNoYW5nZScpO1xuXHRcdFxuXHR9LFxuXG5cblxuXHR1cGRhdGVTaXplOiBmdW5jdGlvbihmb3JjZSkge1xuXHRcdFxuXHRcdGlmKCFfaXNGaXhlZFBvc2l0aW9uICYmIF9vcHRpb25zLm1vZGFsKSB7XG5cdFx0XHR2YXIgd2luZG93U2Nyb2xsWSA9IGZyYW1ld29yay5nZXRTY3JvbGxZKCk7XG5cdFx0XHRpZihfY3VycmVudFdpbmRvd1Njcm9sbFkgIT09IHdpbmRvd1Njcm9sbFkpIHtcblx0XHRcdFx0dGVtcGxhdGUuc3R5bGUudG9wID0gd2luZG93U2Nyb2xsWSArICdweCc7XG5cdFx0XHRcdF9jdXJyZW50V2luZG93U2Nyb2xsWSA9IHdpbmRvd1Njcm9sbFk7XG5cdFx0XHR9XG5cdFx0XHRpZighZm9yY2UgJiYgX3dpbmRvd1Zpc2libGVTaXplLnggPT09IHdpbmRvdy5pbm5lcldpZHRoICYmIF93aW5kb3dWaXNpYmxlU2l6ZS55ID09PSB3aW5kb3cuaW5uZXJIZWlnaHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0X3dpbmRvd1Zpc2libGVTaXplLnggPSB3aW5kb3cuaW5uZXJXaWR0aDtcblx0XHRcdF93aW5kb3dWaXNpYmxlU2l6ZS55ID0gd2luZG93LmlubmVySGVpZ2h0O1xuXG5cdFx0XHQvL3RlbXBsYXRlLnN0eWxlLndpZHRoID0gX3dpbmRvd1Zpc2libGVTaXplLnggKyAncHgnO1xuXHRcdFx0dGVtcGxhdGUuc3R5bGUuaGVpZ2h0ID0gX3dpbmRvd1Zpc2libGVTaXplLnkgKyAncHgnO1xuXHRcdH1cblxuXG5cblx0XHRfdmlld3BvcnRTaXplLnggPSBzZWxmLnNjcm9sbFdyYXAuY2xpZW50V2lkdGg7XG5cdFx0X3ZpZXdwb3J0U2l6ZS55ID0gc2VsZi5zY3JvbGxXcmFwLmNsaWVudEhlaWdodDtcblxuXHRcdF91cGRhdGVQYWdlU2Nyb2xsT2Zmc2V0KCk7XG5cblx0XHRfc2xpZGVTaXplLnggPSBfdmlld3BvcnRTaXplLnggKyBNYXRoLnJvdW5kKF92aWV3cG9ydFNpemUueCAqIF9vcHRpb25zLnNwYWNpbmcpO1xuXHRcdF9zbGlkZVNpemUueSA9IF92aWV3cG9ydFNpemUueTtcblxuXHRcdF9tb3ZlTWFpblNjcm9sbChfc2xpZGVTaXplLnggKiBfY3VyclBvc2l0aW9uSW5kZXgpO1xuXG5cdFx0X3Nob3V0KCdiZWZvcmVSZXNpemUnKTsgLy8gZXZlbiBtYXkgYmUgdXNlZCBmb3IgZXhhbXBsZSB0byBzd2l0Y2ggaW1hZ2Ugc291cmNlc1xuXG5cblx0XHQvLyBkb24ndCByZS1jYWxjdWxhdGUgc2l6ZSBvbiBpbml0YWwgc2l6ZSB1cGRhdGVcblx0XHRpZihfY29udGFpbmVyU2hpZnRJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG5cblx0XHRcdHZhciBob2xkZXIsXG5cdFx0XHRcdGl0ZW0sXG5cdFx0XHRcdGhJbmRleDtcblxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IE5VTV9IT0xERVJTOyBpKyspIHtcblx0XHRcdFx0aG9sZGVyID0gX2l0ZW1Ib2xkZXJzW2ldO1xuXHRcdFx0XHRfc2V0VHJhbnNsYXRlWCggKGkrX2NvbnRhaW5lclNoaWZ0SW5kZXgpICogX3NsaWRlU2l6ZS54LCBob2xkZXIuZWwuc3R5bGUpO1xuXG5cdFx0XHRcdGhJbmRleCA9IF9jdXJyZW50SXRlbUluZGV4K2ktMTtcblxuXHRcdFx0XHRpZihfb3B0aW9ucy5sb29wICYmIF9nZXROdW1JdGVtcygpID4gMikge1xuXHRcdFx0XHRcdGhJbmRleCA9IF9nZXRMb29wZWRJZChoSW5kZXgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdXBkYXRlIHpvb20gbGV2ZWwgb24gaXRlbXMgYW5kIHJlZnJlc2ggc291cmNlIChpZiBuZWVkc1VwZGF0ZSlcblx0XHRcdFx0aXRlbSA9IF9nZXRJdGVtQXQoIGhJbmRleCApO1xuXG5cdFx0XHRcdC8vIHJlLXJlbmRlciBnYWxsZXJ5IGl0ZW0gaWYgYG5lZWRzVXBkYXRlYCxcblx0XHRcdFx0Ly8gb3IgZG9lc24ndCBoYXZlIGBib3VuZHNgIChlbnRpcmVseSBuZXcgc2xpZGUgb2JqZWN0KVxuXHRcdFx0XHRpZiggaXRlbSAmJiAoX2l0ZW1zTmVlZFVwZGF0ZSB8fCBpdGVtLm5lZWRzVXBkYXRlIHx8ICFpdGVtLmJvdW5kcykgKSB7XG5cblx0XHRcdFx0XHRzZWxmLmNsZWFuU2xpZGUoIGl0ZW0gKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRzZWxmLnNldENvbnRlbnQoIGhvbGRlciwgaEluZGV4ICk7XG5cblx0XHRcdFx0XHQvLyBpZiBcImNlbnRlclwiIHNsaWRlXG5cdFx0XHRcdFx0aWYoaSA9PT0gMSkge1xuXHRcdFx0XHRcdFx0c2VsZi5jdXJySXRlbSA9IGl0ZW07XG5cdFx0XHRcdFx0XHRzZWxmLnVwZGF0ZUN1cnJab29tSXRlbSh0cnVlKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpdGVtLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdFx0fSBlbHNlIGlmKGhvbGRlci5pbmRleCA9PT0gLTEgJiYgaEluZGV4ID49IDApIHtcblx0XHRcdFx0XHQvLyBhZGQgY29udGVudCBmaXJzdCB0aW1lXG5cdFx0XHRcdFx0c2VsZi5zZXRDb250ZW50KCBob2xkZXIsIGhJbmRleCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGl0ZW0gJiYgaXRlbS5jb250YWluZXIpIHtcblx0XHRcdFx0XHRfY2FsY3VsYXRlSXRlbVNpemUoaXRlbSwgX3ZpZXdwb3J0U2l6ZSk7XG5cdFx0XHRcdFx0X3NldEltYWdlU2l6ZShpdGVtKTtcblx0XHRcdFx0XHRfYXBwbHlab29tUGFuVG9JdGVtKCBpdGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHR9XG5cdFx0XHRfaXRlbXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0fVx0XG5cblx0XHRfc3RhcnRab29tTGV2ZWwgPSBfY3Vyclpvb21MZXZlbCA9IHNlbGYuY3Vyckl0ZW0uaW5pdGlhbFpvb21MZXZlbDtcblx0XHRfY3VyclBhbkJvdW5kcyA9IHNlbGYuY3Vyckl0ZW0uYm91bmRzO1xuXG5cdFx0aWYoX2N1cnJQYW5Cb3VuZHMpIHtcblx0XHRcdF9wYW5PZmZzZXQueCA9IF9jdXJyUGFuQm91bmRzLmNlbnRlci54O1xuXHRcdFx0X3Bhbk9mZnNldC55ID0gX2N1cnJQYW5Cb3VuZHMuY2VudGVyLnk7XG5cdFx0XHRfYXBwbHlDdXJyZW50Wm9vbVBhbiggdHJ1ZSApO1xuXHRcdH1cblx0XHRcblx0XHRfc2hvdXQoJ3Jlc2l6ZScpO1xuXHR9LFxuXHRcblx0Ly8gWm9vbSBjdXJyZW50IGl0ZW0gdG9cblx0em9vbVRvOiBmdW5jdGlvbihkZXN0Wm9vbUxldmVsLCBjZW50ZXJQb2ludCwgc3BlZWQsIGVhc2luZ0ZuLCB1cGRhdGVGbikge1xuXHRcdC8qXG5cdFx0XHRpZihkZXN0Wm9vbUxldmVsID09PSAnZml0Jykge1xuXHRcdFx0XHRkZXN0Wm9vbUxldmVsID0gc2VsZi5jdXJySXRlbS5maXRSYXRpbztcblx0XHRcdH0gZWxzZSBpZihkZXN0Wm9vbUxldmVsID09PSAnZmlsbCcpIHtcblx0XHRcdFx0ZGVzdFpvb21MZXZlbCA9IHNlbGYuY3Vyckl0ZW0uZmlsbFJhdGlvO1xuXHRcdFx0fVxuXHRcdCovXG5cblx0XHRpZihjZW50ZXJQb2ludCkge1xuXHRcdFx0X3N0YXJ0Wm9vbUxldmVsID0gX2N1cnJab29tTGV2ZWw7XG5cdFx0XHRfbWlkWm9vbVBvaW50LnggPSBNYXRoLmFicyhjZW50ZXJQb2ludC54KSAtIF9wYW5PZmZzZXQueCA7XG5cdFx0XHRfbWlkWm9vbVBvaW50LnkgPSBNYXRoLmFicyhjZW50ZXJQb2ludC55KSAtIF9wYW5PZmZzZXQueSA7XG5cdFx0XHRfZXF1YWxpemVQb2ludHMoX3N0YXJ0UGFuT2Zmc2V0LCBfcGFuT2Zmc2V0KTtcblx0XHR9XG5cblx0XHR2YXIgZGVzdFBhbkJvdW5kcyA9IF9jYWxjdWxhdGVQYW5Cb3VuZHMoZGVzdFpvb21MZXZlbCwgZmFsc2UpLFxuXHRcdFx0ZGVzdFBhbk9mZnNldCA9IHt9O1xuXG5cdFx0X21vZGlmeURlc3RQYW5PZmZzZXQoJ3gnLCBkZXN0UGFuQm91bmRzLCBkZXN0UGFuT2Zmc2V0LCBkZXN0Wm9vbUxldmVsKTtcblx0XHRfbW9kaWZ5RGVzdFBhbk9mZnNldCgneScsIGRlc3RQYW5Cb3VuZHMsIGRlc3RQYW5PZmZzZXQsIGRlc3Rab29tTGV2ZWwpO1xuXG5cdFx0dmFyIGluaXRpYWxab29tTGV2ZWwgPSBfY3Vyclpvb21MZXZlbDtcblx0XHR2YXIgaW5pdGlhbFBhbk9mZnNldCA9IHtcblx0XHRcdHg6IF9wYW5PZmZzZXQueCxcblx0XHRcdHk6IF9wYW5PZmZzZXQueVxuXHRcdH07XG5cblx0XHRfcm91bmRQb2ludChkZXN0UGFuT2Zmc2V0KTtcblxuXHRcdHZhciBvblVwZGF0ZSA9IGZ1bmN0aW9uKG5vdykge1xuXHRcdFx0aWYobm93ID09PSAxKSB7XG5cdFx0XHRcdF9jdXJyWm9vbUxldmVsID0gZGVzdFpvb21MZXZlbDtcblx0XHRcdFx0X3Bhbk9mZnNldC54ID0gZGVzdFBhbk9mZnNldC54O1xuXHRcdFx0XHRfcGFuT2Zmc2V0LnkgPSBkZXN0UGFuT2Zmc2V0Lnk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRfY3Vyclpvb21MZXZlbCA9IChkZXN0Wm9vbUxldmVsIC0gaW5pdGlhbFpvb21MZXZlbCkgKiBub3cgKyBpbml0aWFsWm9vbUxldmVsO1xuXHRcdFx0XHRfcGFuT2Zmc2V0LnggPSAoZGVzdFBhbk9mZnNldC54IC0gaW5pdGlhbFBhbk9mZnNldC54KSAqIG5vdyArIGluaXRpYWxQYW5PZmZzZXQueDtcblx0XHRcdFx0X3Bhbk9mZnNldC55ID0gKGRlc3RQYW5PZmZzZXQueSAtIGluaXRpYWxQYW5PZmZzZXQueSkgKiBub3cgKyBpbml0aWFsUGFuT2Zmc2V0Lnk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKHVwZGF0ZUZuKSB7XG5cdFx0XHRcdHVwZGF0ZUZuKG5vdyk7XG5cdFx0XHR9XG5cblx0XHRcdF9hcHBseUN1cnJlbnRab29tUGFuKCBub3cgPT09IDEgKTtcblx0XHR9O1xuXG5cdFx0aWYoc3BlZWQpIHtcblx0XHRcdF9hbmltYXRlUHJvcCgnY3VzdG9tWm9vbVRvJywgMCwgMSwgc3BlZWQsIGVhc2luZ0ZuIHx8IGZyYW1ld29yay5lYXNpbmcuc2luZS5pbk91dCwgb25VcGRhdGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvblVwZGF0ZSgxKTtcblx0XHR9XG5cdH1cblxuXG59O1xuXG5cbi8qPj5jb3JlKi9cblxuLyo+Pmdlc3R1cmVzKi9cbi8qKlxuICogTW91c2UvdG91Y2gvcG9pbnRlciBldmVudCBoYW5kbGVycy5cbiAqIFxuICogc2VwYXJhdGVkIGZyb20gQGNvcmUuanMgZm9yIHJlYWRhYmlsaXR5XG4gKi9cblxudmFyIE1JTl9TV0lQRV9ESVNUQU5DRSA9IDMwLFxuXHRESVJFQ1RJT05fQ0hFQ0tfT0ZGU0VUID0gMTA7IC8vIGFtb3VudCBvZiBwaXhlbHMgdG8gZHJhZyB0byBkZXRlcm1pbmUgZGlyZWN0aW9uIG9mIHN3aXBlXG5cbnZhciBfZ2VzdHVyZVN0YXJ0VGltZSxcblx0X2dlc3R1cmVDaGVja1NwZWVkVGltZSxcblxuXHQvLyBwb29sIG9mIG9iamVjdHMgdGhhdCBhcmUgdXNlZCBkdXJpbmcgZHJhZ2dpbmcgb2Ygem9vbWluZ1xuXHRwID0ge30sIC8vIGZpcnN0IHBvaW50XG5cdHAyID0ge30sIC8vIHNlY29uZCBwb2ludCAoZm9yIHpvb20gZ2VzdHVyZSlcblx0ZGVsdGEgPSB7fSxcblx0X2N1cnJQb2ludCA9IHt9LFxuXHRfc3RhcnRQb2ludCA9IHt9LFxuXHRfY3VyclBvaW50ZXJzID0gW10sXG5cdF9zdGFydE1haW5TY3JvbGxQb3MgPSB7fSxcblx0X3JlbGVhc2VBbmltRGF0YSxcblx0X3Bvc1BvaW50cyA9IFtdLCAvLyBhcnJheSBvZiBwb2ludHMgZHVyaW5nIGRyYWdnaW5nLCB1c2VkIHRvIGRldGVybWluZSB0eXBlIG9mIGdlc3R1cmVcblx0X3RlbXBQb2ludCA9IHt9LFxuXG5cdF9pc1pvb21pbmdJbixcblx0X3ZlcnRpY2FsRHJhZ0luaXRpYXRlZCxcblx0X29sZEFuZHJvaWRUb3VjaEVuZFRpbWVvdXQsXG5cdF9jdXJyWm9vbWVkSXRlbUluZGV4ID0gMCxcblx0X2NlbnRlclBvaW50ID0gX2dldEVtcHR5UG9pbnQoKSxcblx0X2xhc3RSZWxlYXNlVGltZSA9IDAsXG5cdF9pc0RyYWdnaW5nLCAvLyBhdCBsZWFzdCBvbmUgcG9pbnRlciBpcyBkb3duXG5cdF9pc011bHRpdG91Y2gsIC8vIGF0IGxlYXN0IHR3byBfcG9pbnRlcnMgYXJlIGRvd25cblx0X3pvb21TdGFydGVkLCAvLyB6b29tIGxldmVsIGNoYW5nZWQgZHVyaW5nIHpvb20gZ2VzdHVyZVxuXHRfbW92ZWQsXG5cdF9kcmFnQW5pbUZyYW1lLFxuXHRfbWFpblNjcm9sbFNoaWZ0ZWQsXG5cdF9jdXJyZW50UG9pbnRzLCAvLyBhcnJheSBvZiBjdXJyZW50IHRvdWNoIHBvaW50c1xuXHRfaXNab29taW5nLFxuXHRfY3VyclBvaW50c0Rpc3RhbmNlLFxuXHRfc3RhcnRQb2ludHNEaXN0YW5jZSxcblx0X2N1cnJQYW5Cb3VuZHMsXG5cdF9tYWluU2Nyb2xsUG9zID0gX2dldEVtcHR5UG9pbnQoKSxcblx0X2N1cnJab29tRWxlbWVudFN0eWxlLFxuXHRfbWFpblNjcm9sbEFuaW1hdGluZywgLy8gdHJ1ZSwgaWYgYW5pbWF0aW9uIGFmdGVyIHN3aXBlIGdlc3R1cmUgaXMgcnVubmluZ1xuXHRfbWlkWm9vbVBvaW50ID0gX2dldEVtcHR5UG9pbnQoKSxcblx0X2N1cnJDZW50ZXJQb2ludCA9IF9nZXRFbXB0eVBvaW50KCksXG5cdF9kaXJlY3Rpb24sXG5cdF9pc0ZpcnN0TW92ZSxcblx0X29wYWNpdHlDaGFuZ2VkLFxuXHRfYmdPcGFjaXR5LFxuXHRfd2FzT3ZlckluaXRpYWxab29tLFxuXG5cdF9pc0VxdWFsUG9pbnRzID0gZnVuY3Rpb24ocDEsIHAyKSB7XG5cdFx0cmV0dXJuIHAxLnggPT09IHAyLnggJiYgcDEueSA9PT0gcDIueTtcblx0fSxcblx0X2lzTmVhcmJ5UG9pbnRzID0gZnVuY3Rpb24odG91Y2gwLCB0b3VjaDEpIHtcblx0XHRyZXR1cm4gTWF0aC5hYnModG91Y2gwLnggLSB0b3VjaDEueCkgPCBET1VCTEVfVEFQX1JBRElVUyAmJiBNYXRoLmFicyh0b3VjaDAueSAtIHRvdWNoMS55KSA8IERPVUJMRV9UQVBfUkFESVVTO1xuXHR9LFxuXHRfY2FsY3VsYXRlUG9pbnRzRGlzdGFuY2UgPSBmdW5jdGlvbihwMSwgcDIpIHtcblx0XHRfdGVtcFBvaW50LnggPSBNYXRoLmFicyggcDEueCAtIHAyLnggKTtcblx0XHRfdGVtcFBvaW50LnkgPSBNYXRoLmFicyggcDEueSAtIHAyLnkgKTtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KF90ZW1wUG9pbnQueCAqIF90ZW1wUG9pbnQueCArIF90ZW1wUG9pbnQueSAqIF90ZW1wUG9pbnQueSk7XG5cdH0sXG5cdF9zdG9wRHJhZ1VwZGF0ZUxvb3AgPSBmdW5jdGlvbigpIHtcblx0XHRpZihfZHJhZ0FuaW1GcmFtZSkge1xuXHRcdFx0X2NhbmNlbEFGKF9kcmFnQW5pbUZyYW1lKTtcblx0XHRcdF9kcmFnQW5pbUZyYW1lID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cdF9kcmFnVXBkYXRlTG9vcCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmKF9pc0RyYWdnaW5nKSB7XG5cdFx0XHRfZHJhZ0FuaW1GcmFtZSA9IF9yZXF1ZXN0QUYoX2RyYWdVcGRhdGVMb29wKTtcblx0XHRcdF9yZW5kZXJNb3ZlbWVudCgpO1xuXHRcdH1cblx0fSxcblx0X2NhblBhbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhKF9vcHRpb25zLnNjYWxlTW9kZSA9PT0gJ2ZpdCcgJiYgX2N1cnJab29tTGV2ZWwgPT09ICBzZWxmLmN1cnJJdGVtLmluaXRpYWxab29tTGV2ZWwpO1xuXHR9LFxuXHRcblx0Ly8gZmluZCB0aGUgY2xvc2VzdCBwYXJlbnQgRE9NIGVsZW1lbnRcblx0X2Nsb3Nlc3RFbGVtZW50ID0gZnVuY3Rpb24oZWwsIGZuKSB7XG5cdCAgXHRpZighZWwgfHwgZWwgPT09IGRvY3VtZW50KSB7XG5cdCAgXHRcdHJldHVybiBmYWxzZTtcblx0ICBcdH1cblxuXHQgIFx0Ly8gZG9uJ3Qgc2VhcmNoIGVsZW1lbnRzIGFib3ZlIHBzd3BfX3Njcm9sbC13cmFwXG5cdCAgXHRpZihlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgJiYgZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpLmluZGV4T2YoJ3Bzd3BfX3Njcm9sbC13cmFwJykgPiAtMSApIHtcblx0ICBcdFx0cmV0dXJuIGZhbHNlO1xuXHQgIFx0fVxuXG5cdCAgXHRpZiggZm4oZWwpICkge1xuXHQgIFx0XHRyZXR1cm4gZWw7XG5cdCAgXHR9XG5cblx0ICBcdHJldHVybiBfY2xvc2VzdEVsZW1lbnQoZWwucGFyZW50Tm9kZSwgZm4pO1xuXHR9LFxuXG5cdF9wcmV2ZW50T2JqID0ge30sXG5cdF9wcmV2ZW50RGVmYXVsdEV2ZW50QmVoYXZpb3VyID0gZnVuY3Rpb24oZSwgaXNEb3duKSB7XG5cdCAgICBfcHJldmVudE9iai5wcmV2ZW50ID0gIV9jbG9zZXN0RWxlbWVudChlLnRhcmdldCwgX29wdGlvbnMuaXNDbGlja2FibGVFbGVtZW50KTtcblxuXHRcdF9zaG91dCgncHJldmVudERyYWdFdmVudCcsIGUsIGlzRG93biwgX3ByZXZlbnRPYmopO1xuXHRcdHJldHVybiBfcHJldmVudE9iai5wcmV2ZW50O1xuXG5cdH0sXG5cdF9jb252ZXJ0VG91Y2hUb1BvaW50ID0gZnVuY3Rpb24odG91Y2gsIHApIHtcblx0XHRwLnggPSB0b3VjaC5wYWdlWDtcblx0XHRwLnkgPSB0b3VjaC5wYWdlWTtcblx0XHRwLmlkID0gdG91Y2guaWRlbnRpZmllcjtcblx0XHRyZXR1cm4gcDtcblx0fSxcblx0X2ZpbmRDZW50ZXJPZlBvaW50cyA9IGZ1bmN0aW9uKHAxLCBwMiwgcENlbnRlcikge1xuXHRcdHBDZW50ZXIueCA9IChwMS54ICsgcDIueCkgKiAwLjU7XG5cdFx0cENlbnRlci55ID0gKHAxLnkgKyBwMi55KSAqIDAuNTtcblx0fSxcblx0X3B1c2hQb3NQb2ludCA9IGZ1bmN0aW9uKHRpbWUsIHgsIHkpIHtcblx0XHRpZih0aW1lIC0gX2dlc3R1cmVDaGVja1NwZWVkVGltZSA+IDUwKSB7XG5cdFx0XHR2YXIgbyA9IF9wb3NQb2ludHMubGVuZ3RoID4gMiA/IF9wb3NQb2ludHMuc2hpZnQoKSA6IHt9O1xuXHRcdFx0by54ID0geDtcblx0XHRcdG8ueSA9IHk7IFxuXHRcdFx0X3Bvc1BvaW50cy5wdXNoKG8pO1xuXHRcdFx0X2dlc3R1cmVDaGVja1NwZWVkVGltZSA9IHRpbWU7XG5cdFx0fVxuXHR9LFxuXG5cdF9jYWxjdWxhdGVWZXJ0aWNhbERyYWdPcGFjaXR5UmF0aW8gPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgeU9mZnNldCA9IF9wYW5PZmZzZXQueSAtIHNlbGYuY3Vyckl0ZW0uaW5pdGlhbFBvc2l0aW9uLnk7IC8vIGRpZmZlcmVuY2UgYmV0d2VlbiBpbml0aWFsIGFuZCBjdXJyZW50IHBvc2l0aW9uXG5cdFx0cmV0dXJuIDEgLSAgTWF0aC5hYnMoIHlPZmZzZXQgLyAoX3ZpZXdwb3J0U2l6ZS55IC8gMikgICk7XG5cdH0sXG5cblx0XG5cdC8vIHBvaW50cyBwb29sLCByZXVzZWQgZHVyaW5nIHRvdWNoIGV2ZW50c1xuXHRfZVBvaW50MSA9IHt9LFxuXHRfZVBvaW50MiA9IHt9LFxuXHRfdGVtcFBvaW50c0FyciA9IFtdLFxuXHRfdGVtcENvdW50ZXIsXG5cdF9nZXRUb3VjaFBvaW50cyA9IGZ1bmN0aW9uKGUpIHtcblx0XHQvLyBjbGVhbiB1cCBwcmV2aW91cyBwb2ludHMsIHdpdGhvdXQgcmVjcmVhdGluZyBhcnJheVxuXHRcdHdoaWxlKF90ZW1wUG9pbnRzQXJyLmxlbmd0aCA+IDApIHtcblx0XHRcdF90ZW1wUG9pbnRzQXJyLnBvcCgpO1xuXHRcdH1cblxuXHRcdGlmKCFfcG9pbnRlckV2ZW50RW5hYmxlZCkge1xuXHRcdFx0aWYoZS50eXBlLmluZGV4T2YoJ3RvdWNoJykgPiAtMSkge1xuXG5cdFx0XHRcdGlmKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdF90ZW1wUG9pbnRzQXJyWzBdID0gX2NvbnZlcnRUb3VjaFRvUG9pbnQoZS50b3VjaGVzWzBdLCBfZVBvaW50MSk7XG5cdFx0XHRcdFx0aWYoZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRcdF90ZW1wUG9pbnRzQXJyWzFdID0gX2NvbnZlcnRUb3VjaFRvUG9pbnQoZS50b3VjaGVzWzFdLCBfZVBvaW50Mik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X2VQb2ludDEueCA9IGUucGFnZVg7XG5cdFx0XHRcdF9lUG9pbnQxLnkgPSBlLnBhZ2VZO1xuXHRcdFx0XHRfZVBvaW50MS5pZCA9ICcnO1xuXHRcdFx0XHRfdGVtcFBvaW50c0FyclswXSA9IF9lUG9pbnQxOy8vX2VQb2ludDE7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdF90ZW1wQ291bnRlciA9IDA7XG5cdFx0XHQvLyB3ZSBjYW4gdXNlIGZvckVhY2gsIGFzIHBvaW50ZXIgZXZlbnRzIGFyZSBzdXBwb3J0ZWQgb25seSBpbiBtb2Rlcm4gYnJvd3NlcnNcblx0XHRcdF9jdXJyUG9pbnRlcnMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG5cdFx0XHRcdGlmKF90ZW1wQ291bnRlciA9PT0gMCkge1xuXHRcdFx0XHRcdF90ZW1wUG9pbnRzQXJyWzBdID0gcDtcblx0XHRcdFx0fSBlbHNlIGlmKF90ZW1wQ291bnRlciA9PT0gMSkge1xuXHRcdFx0XHRcdF90ZW1wUG9pbnRzQXJyWzFdID0gcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRfdGVtcENvdW50ZXIrKztcblxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiBfdGVtcFBvaW50c0Fycjtcblx0fSxcblxuXHRfcGFuT3JNb3ZlTWFpblNjcm9sbCA9IGZ1bmN0aW9uKGF4aXMsIGRlbHRhKSB7XG5cblx0XHR2YXIgcGFuRnJpY3Rpb24sXG5cdFx0XHRvdmVyRGlmZiA9IDAsXG5cdFx0XHRuZXdPZmZzZXQgPSBfcGFuT2Zmc2V0W2F4aXNdICsgZGVsdGFbYXhpc10sXG5cdFx0XHRzdGFydE92ZXJEaWZmLFxuXHRcdFx0ZGlyID0gZGVsdGFbYXhpc10gPiAwLFxuXHRcdFx0bmV3TWFpblNjcm9sbFBvc2l0aW9uID0gX21haW5TY3JvbGxQb3MueCArIGRlbHRhLngsXG5cdFx0XHRtYWluU2Nyb2xsRGlmZiA9IF9tYWluU2Nyb2xsUG9zLnggLSBfc3RhcnRNYWluU2Nyb2xsUG9zLngsXG5cdFx0XHRuZXdQYW5Qb3MsXG5cdFx0XHRuZXdNYWluU2Nyb2xsUG9zO1xuXG5cdFx0Ly8gY2FsY3VsYXRlIGZkaXN0YW5jZSBvdmVyIHRoZSBib3VuZHMgYW5kIGZyaWN0aW9uXG5cdFx0aWYobmV3T2Zmc2V0ID4gX2N1cnJQYW5Cb3VuZHMubWluW2F4aXNdIHx8IG5ld09mZnNldCA8IF9jdXJyUGFuQm91bmRzLm1heFtheGlzXSkge1xuXHRcdFx0cGFuRnJpY3Rpb24gPSBfb3B0aW9ucy5wYW5FbmRGcmljdGlvbjtcblx0XHRcdC8vIExpbmVhciBpbmNyZWFzaW5nIG9mIGZyaWN0aW9uLCBzbyBhdCAxLzQgb2Ygdmlld3BvcnQgaXQncyBhdCBtYXggdmFsdWUuIFxuXHRcdFx0Ly8gTG9va3Mgbm90IGFzIG5pY2UgYXMgd2FzIGV4cGVjdGVkLiBMZWZ0IGZvciBoaXN0b3J5LlxuXHRcdFx0Ly8gcGFuRnJpY3Rpb24gPSAoMSAtIChfcGFuT2Zmc2V0W2F4aXNdICsgZGVsdGFbYXhpc10gKyBwYW5Cb3VuZHMubWluW2F4aXNdKSAvIChfdmlld3BvcnRTaXplW2F4aXNdIC8gNCkgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGFuRnJpY3Rpb24gPSAxO1xuXHRcdH1cblx0XHRcblx0XHRuZXdPZmZzZXQgPSBfcGFuT2Zmc2V0W2F4aXNdICsgZGVsdGFbYXhpc10gKiBwYW5GcmljdGlvbjtcblxuXHRcdC8vIG1vdmUgbWFpbiBzY3JvbGwgb3Igc3RhcnQgcGFubmluZ1xuXHRcdGlmKF9vcHRpb25zLmFsbG93UGFuVG9OZXh0IHx8IF9jdXJyWm9vbUxldmVsID09PSBzZWxmLmN1cnJJdGVtLmluaXRpYWxab29tTGV2ZWwpIHtcblxuXG5cdFx0XHRpZighX2N1cnJab29tRWxlbWVudFN0eWxlKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHRuZXdNYWluU2Nyb2xsUG9zID0gbmV3TWFpblNjcm9sbFBvc2l0aW9uO1xuXG5cdFx0XHR9IGVsc2UgaWYoX2RpcmVjdGlvbiA9PT0gJ2gnICYmIGF4aXMgPT09ICd4JyAmJiAhX3pvb21TdGFydGVkICkge1xuXHRcdFx0XHRcblx0XHRcdFx0aWYoZGlyKSB7XG5cdFx0XHRcdFx0aWYobmV3T2Zmc2V0ID4gX2N1cnJQYW5Cb3VuZHMubWluW2F4aXNdKSB7XG5cdFx0XHRcdFx0XHRwYW5GcmljdGlvbiA9IF9vcHRpb25zLnBhbkVuZEZyaWN0aW9uO1xuXHRcdFx0XHRcdFx0b3ZlckRpZmYgPSBfY3VyclBhbkJvdW5kcy5taW5bYXhpc10gLSBuZXdPZmZzZXQ7XG5cdFx0XHRcdFx0XHRzdGFydE92ZXJEaWZmID0gX2N1cnJQYW5Cb3VuZHMubWluW2F4aXNdIC0gX3N0YXJ0UGFuT2Zmc2V0W2F4aXNdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBkcmFnIHJpZ2h0XG5cdFx0XHRcdFx0aWYoIChzdGFydE92ZXJEaWZmIDw9IDAgfHwgbWFpblNjcm9sbERpZmYgPCAwKSAmJiBfZ2V0TnVtSXRlbXMoKSA+IDEgKSB7XG5cdFx0XHRcdFx0XHRuZXdNYWluU2Nyb2xsUG9zID0gbmV3TWFpblNjcm9sbFBvc2l0aW9uO1xuXHRcdFx0XHRcdFx0aWYobWFpblNjcm9sbERpZmYgPCAwICYmIG5ld01haW5TY3JvbGxQb3NpdGlvbiA+IF9zdGFydE1haW5TY3JvbGxQb3MueCkge1xuXHRcdFx0XHRcdFx0XHRuZXdNYWluU2Nyb2xsUG9zID0gX3N0YXJ0TWFpblNjcm9sbFBvcy54O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZihfY3VyclBhbkJvdW5kcy5taW4ueCAhPT0gX2N1cnJQYW5Cb3VuZHMubWF4LngpIHtcblx0XHRcdFx0XHRcdFx0bmV3UGFuUG9zID0gbmV3T2Zmc2V0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpZihuZXdPZmZzZXQgPCBfY3VyclBhbkJvdW5kcy5tYXhbYXhpc10gKSB7XG5cdFx0XHRcdFx0XHRwYW5GcmljdGlvbiA9X29wdGlvbnMucGFuRW5kRnJpY3Rpb247XG5cdFx0XHRcdFx0XHRvdmVyRGlmZiA9IG5ld09mZnNldCAtIF9jdXJyUGFuQm91bmRzLm1heFtheGlzXTtcblx0XHRcdFx0XHRcdHN0YXJ0T3ZlckRpZmYgPSBfc3RhcnRQYW5PZmZzZXRbYXhpc10gLSBfY3VyclBhbkJvdW5kcy5tYXhbYXhpc107XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYoIChzdGFydE92ZXJEaWZmIDw9IDAgfHwgbWFpblNjcm9sbERpZmYgPiAwKSAmJiBfZ2V0TnVtSXRlbXMoKSA+IDEgKSB7XG5cdFx0XHRcdFx0XHRuZXdNYWluU2Nyb2xsUG9zID0gbmV3TWFpblNjcm9sbFBvc2l0aW9uO1xuXG5cdFx0XHRcdFx0XHRpZihtYWluU2Nyb2xsRGlmZiA+IDAgJiYgbmV3TWFpblNjcm9sbFBvc2l0aW9uIDwgX3N0YXJ0TWFpblNjcm9sbFBvcy54KSB7XG5cdFx0XHRcdFx0XHRcdG5ld01haW5TY3JvbGxQb3MgPSBfc3RhcnRNYWluU2Nyb2xsUG9zLng7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYoX2N1cnJQYW5Cb3VuZHMubWluLnggIT09IF9jdXJyUGFuQm91bmRzLm1heC54KSB7XG5cdFx0XHRcdFx0XHRcdG5ld1BhblBvcyA9IG5ld09mZnNldDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cblx0XHRcdFx0Ly9cblx0XHRcdH1cblxuXHRcdFx0aWYoYXhpcyA9PT0gJ3gnKSB7XG5cblx0XHRcdFx0aWYobmV3TWFpblNjcm9sbFBvcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0X21vdmVNYWluU2Nyb2xsKG5ld01haW5TY3JvbGxQb3MsIHRydWUpO1xuXHRcdFx0XHRcdGlmKG5ld01haW5TY3JvbGxQb3MgPT09IF9zdGFydE1haW5TY3JvbGxQb3MueCkge1xuXHRcdFx0XHRcdFx0X21haW5TY3JvbGxTaGlmdGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdF9tYWluU2Nyb2xsU2hpZnRlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYoX2N1cnJQYW5Cb3VuZHMubWluLnggIT09IF9jdXJyUGFuQm91bmRzLm1heC54KSB7XG5cdFx0XHRcdFx0aWYobmV3UGFuUG9zICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdF9wYW5PZmZzZXQueCA9IG5ld1BhblBvcztcblx0XHRcdFx0XHR9IGVsc2UgaWYoIV9tYWluU2Nyb2xsU2hpZnRlZCkge1xuXHRcdFx0XHRcdFx0X3Bhbk9mZnNldC54ICs9IGRlbHRhLnggKiBwYW5GcmljdGlvbjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbmV3TWFpblNjcm9sbFBvcyAhPT0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYoIV9tYWluU2Nyb2xsQW5pbWF0aW5nKSB7XG5cdFx0XHRcblx0XHRcdGlmKCFfbWFpblNjcm9sbFNoaWZ0ZWQpIHtcblx0XHRcdFx0aWYoX2N1cnJab29tTGV2ZWwgPiBzZWxmLmN1cnJJdGVtLmZpdFJhdGlvKSB7XG5cdFx0XHRcdFx0X3Bhbk9mZnNldFtheGlzXSArPSBkZWx0YVtheGlzXSAqIHBhbkZyaWN0aW9uO1xuXHRcdFx0XHRcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRcblx0XHR9XG5cdFx0XG5cdH0sXG5cblx0Ly8gUG9pbnRlcmRvd24vdG91Y2hzdGFydC9tb3VzZWRvd24gaGFuZGxlclxuXHRfb25EcmFnU3RhcnQgPSBmdW5jdGlvbihlKSB7XG5cblx0XHQvLyBBbGxvdyBkcmFnZ2luZyBvbmx5IHZpYSBsZWZ0IG1vdXNlIGJ1dHRvbi5cblx0XHQvLyBBcyB0aGlzIGhhbmRsZXIgaXMgbm90IGFkZGVkIGluIElFOCAtIHdlIGlnbm9yZSBlLndoaWNoXG5cdFx0Ly8gXG5cdFx0Ly8gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy9ldmVudHNfcHJvcGVydGllcy5odG1sXG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL2V2ZW50LmJ1dHRvblxuXHRcdGlmKGUudHlwZSA9PT0gJ21vdXNlZG93bicgJiYgZS5idXR0b24gPiAwICApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZihfaW5pdGlhbFpvb21SdW5uaW5nKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYoX29sZEFuZHJvaWRUb3VjaEVuZFRpbWVvdXQgJiYgZS50eXBlID09PSAnbW91c2Vkb3duJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKF9wcmV2ZW50RGVmYXVsdEV2ZW50QmVoYXZpb3VyKGUsIHRydWUpKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cblxuXHRcdF9zaG91dCgncG9pbnRlckRvd24nKTtcblxuXHRcdGlmKF9wb2ludGVyRXZlbnRFbmFibGVkKSB7XG5cdFx0XHR2YXIgcG9pbnRlckluZGV4ID0gZnJhbWV3b3JrLmFycmF5U2VhcmNoKF9jdXJyUG9pbnRlcnMsIGUucG9pbnRlcklkLCAnaWQnKTtcblx0XHRcdGlmKHBvaW50ZXJJbmRleCA8IDApIHtcblx0XHRcdFx0cG9pbnRlckluZGV4ID0gX2N1cnJQb2ludGVycy5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHRfY3VyclBvaW50ZXJzW3BvaW50ZXJJbmRleF0gPSB7eDplLnBhZ2VYLCB5OmUucGFnZVksIGlkOiBlLnBvaW50ZXJJZH07XG5cdFx0fVxuXHRcdFxuXG5cblx0XHR2YXIgc3RhcnRQb2ludHNMaXN0ID0gX2dldFRvdWNoUG9pbnRzKGUpLFxuXHRcdFx0bnVtUG9pbnRzID0gc3RhcnRQb2ludHNMaXN0Lmxlbmd0aDtcblxuXHRcdF9jdXJyZW50UG9pbnRzID0gbnVsbDtcblxuXHRcdF9zdG9wQWxsQW5pbWF0aW9ucygpO1xuXG5cdFx0Ly8gaW5pdCBkcmFnXG5cdFx0aWYoIV9pc0RyYWdnaW5nIHx8IG51bVBvaW50cyA9PT0gMSkge1xuXG5cdFx0XHRcblxuXHRcdFx0X2lzRHJhZ2dpbmcgPSBfaXNGaXJzdE1vdmUgPSB0cnVlO1xuXHRcdFx0ZnJhbWV3b3JrLmJpbmQod2luZG93LCBfdXBNb3ZlRXZlbnRzLCBzZWxmKTtcblxuXHRcdFx0X2lzWm9vbWluZ0luID0gXG5cdFx0XHRcdF93YXNPdmVySW5pdGlhbFpvb20gPSBcblx0XHRcdFx0X29wYWNpdHlDaGFuZ2VkID0gXG5cdFx0XHRcdF92ZXJ0aWNhbERyYWdJbml0aWF0ZWQgPSBcblx0XHRcdFx0X21haW5TY3JvbGxTaGlmdGVkID0gXG5cdFx0XHRcdF9tb3ZlZCA9IFxuXHRcdFx0XHRfaXNNdWx0aXRvdWNoID0gXG5cdFx0XHRcdF96b29tU3RhcnRlZCA9IGZhbHNlO1xuXG5cdFx0XHRfZGlyZWN0aW9uID0gbnVsbDtcblxuXHRcdFx0X3Nob3V0KCdmaXJzdFRvdWNoU3RhcnQnLCBzdGFydFBvaW50c0xpc3QpO1xuXG5cdFx0XHRfZXF1YWxpemVQb2ludHMoX3N0YXJ0UGFuT2Zmc2V0LCBfcGFuT2Zmc2V0KTtcblxuXHRcdFx0X2N1cnJQYW5EaXN0LnggPSBfY3VyclBhbkRpc3QueSA9IDA7XG5cdFx0XHRfZXF1YWxpemVQb2ludHMoX2N1cnJQb2ludCwgc3RhcnRQb2ludHNMaXN0WzBdKTtcblx0XHRcdF9lcXVhbGl6ZVBvaW50cyhfc3RhcnRQb2ludCwgX2N1cnJQb2ludCk7XG5cblx0XHRcdC8vX2VxdWFsaXplUG9pbnRzKF9zdGFydE1haW5TY3JvbGxQb3MsIF9tYWluU2Nyb2xsUG9zKTtcblx0XHRcdF9zdGFydE1haW5TY3JvbGxQb3MueCA9IF9zbGlkZVNpemUueCAqIF9jdXJyUG9zaXRpb25JbmRleDtcblxuXHRcdFx0X3Bvc1BvaW50cyA9IFt7XG5cdFx0XHRcdHg6IF9jdXJyUG9pbnQueCxcblx0XHRcdFx0eTogX2N1cnJQb2ludC55XG5cdFx0XHR9XTtcblxuXHRcdFx0X2dlc3R1cmVDaGVja1NwZWVkVGltZSA9IF9nZXN0dXJlU3RhcnRUaW1lID0gX2dldEN1cnJlbnRUaW1lKCk7XG5cblx0XHRcdC8vX21haW5TY3JvbGxBbmltYXRpb25FbmQodHJ1ZSk7XG5cdFx0XHRfY2FsY3VsYXRlUGFuQm91bmRzKCBfY3Vyclpvb21MZXZlbCwgdHJ1ZSApO1xuXHRcdFx0XG5cdFx0XHQvLyBTdGFydCByZW5kZXJpbmdcblx0XHRcdF9zdG9wRHJhZ1VwZGF0ZUxvb3AoKTtcblx0XHRcdF9kcmFnVXBkYXRlTG9vcCgpO1xuXHRcdFx0XG5cdFx0fVxuXG5cdFx0Ly8gaW5pdCB6b29tXG5cdFx0aWYoIV9pc1pvb21pbmcgJiYgbnVtUG9pbnRzID4gMSAmJiAhX21haW5TY3JvbGxBbmltYXRpbmcgJiYgIV9tYWluU2Nyb2xsU2hpZnRlZCkge1xuXHRcdFx0X3N0YXJ0Wm9vbUxldmVsID0gX2N1cnJab29tTGV2ZWw7XG5cdFx0XHRfem9vbVN0YXJ0ZWQgPSBmYWxzZTsgLy8gdHJ1ZSBpZiB6b29tIGNoYW5nZWQgYXQgbGVhc3Qgb25jZVxuXG5cdFx0XHRfaXNab29taW5nID0gX2lzTXVsdGl0b3VjaCA9IHRydWU7XG5cdFx0XHRfY3VyclBhbkRpc3QueSA9IF9jdXJyUGFuRGlzdC54ID0gMDtcblxuXHRcdFx0X2VxdWFsaXplUG9pbnRzKF9zdGFydFBhbk9mZnNldCwgX3Bhbk9mZnNldCk7XG5cblx0XHRcdF9lcXVhbGl6ZVBvaW50cyhwLCBzdGFydFBvaW50c0xpc3RbMF0pO1xuXHRcdFx0X2VxdWFsaXplUG9pbnRzKHAyLCBzdGFydFBvaW50c0xpc3RbMV0pO1xuXG5cdFx0XHRfZmluZENlbnRlck9mUG9pbnRzKHAsIHAyLCBfY3VyckNlbnRlclBvaW50KTtcblxuXHRcdFx0X21pZFpvb21Qb2ludC54ID0gTWF0aC5hYnMoX2N1cnJDZW50ZXJQb2ludC54KSAtIF9wYW5PZmZzZXQueDtcblx0XHRcdF9taWRab29tUG9pbnQueSA9IE1hdGguYWJzKF9jdXJyQ2VudGVyUG9pbnQueSkgLSBfcGFuT2Zmc2V0Lnk7XG5cdFx0XHRfY3VyclBvaW50c0Rpc3RhbmNlID0gX3N0YXJ0UG9pbnRzRGlzdGFuY2UgPSBfY2FsY3VsYXRlUG9pbnRzRGlzdGFuY2UocCwgcDIpO1xuXHRcdH1cblxuXG5cdH0sXG5cblx0Ly8gUG9pbnRlcm1vdmUvdG91Y2htb3ZlL21vdXNlbW92ZSBoYW5kbGVyXG5cdF9vbkRyYWdNb3ZlID0gZnVuY3Rpb24oZSkge1xuXG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0aWYoX3BvaW50ZXJFdmVudEVuYWJsZWQpIHtcblx0XHRcdHZhciBwb2ludGVySW5kZXggPSBmcmFtZXdvcmsuYXJyYXlTZWFyY2goX2N1cnJQb2ludGVycywgZS5wb2ludGVySWQsICdpZCcpO1xuXHRcdFx0aWYocG9pbnRlckluZGV4ID4gLTEpIHtcblx0XHRcdFx0dmFyIHAgPSBfY3VyclBvaW50ZXJzW3BvaW50ZXJJbmRleF07XG5cdFx0XHRcdHAueCA9IGUucGFnZVg7XG5cdFx0XHRcdHAueSA9IGUucGFnZVk7IFxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmKF9pc0RyYWdnaW5nKSB7XG5cdFx0XHR2YXIgdG91Y2hlc0xpc3QgPSBfZ2V0VG91Y2hQb2ludHMoZSk7XG5cdFx0XHRpZighX2RpcmVjdGlvbiAmJiAhX21vdmVkICYmICFfaXNab29taW5nKSB7XG5cblx0XHRcdFx0aWYoX21haW5TY3JvbGxQb3MueCAhPT0gX3NsaWRlU2l6ZS54ICogX2N1cnJQb3NpdGlvbkluZGV4KSB7XG5cdFx0XHRcdFx0Ly8gaWYgbWFpbiBzY3JvbGwgcG9zaXRpb24gaXMgc2hpZnRlZCDigJMgZGlyZWN0aW9uIGlzIGFsd2F5cyBob3Jpem9udGFsXG5cdFx0XHRcdFx0X2RpcmVjdGlvbiA9ICdoJztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgZGlmZiA9IE1hdGguYWJzKHRvdWNoZXNMaXN0WzBdLnggLSBfY3VyclBvaW50LngpIC0gTWF0aC5hYnModG91Y2hlc0xpc3RbMF0ueSAtIF9jdXJyUG9pbnQueSk7XG5cdFx0XHRcdFx0Ly8gY2hlY2sgdGhlIGRpcmVjdGlvbiBvZiBtb3ZlbWVudFxuXHRcdFx0XHRcdGlmKE1hdGguYWJzKGRpZmYpID49IERJUkVDVElPTl9DSEVDS19PRkZTRVQpIHtcblx0XHRcdFx0XHRcdF9kaXJlY3Rpb24gPSBkaWZmID4gMCA/ICdoJyA6ICd2Jztcblx0XHRcdFx0XHRcdF9jdXJyZW50UG9pbnRzID0gdG91Y2hlc0xpc3Q7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X2N1cnJlbnRQb2ludHMgPSB0b3VjaGVzTGlzdDtcblx0XHRcdH1cblx0XHR9XHRcblx0fSxcblx0Ly8gXG5cdF9yZW5kZXJNb3ZlbWVudCA9ICBmdW5jdGlvbigpIHtcblxuXHRcdGlmKCFfY3VycmVudFBvaW50cykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBudW1Qb2ludHMgPSBfY3VycmVudFBvaW50cy5sZW5ndGg7XG5cblx0XHRpZihudW1Qb2ludHMgPT09IDApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRfZXF1YWxpemVQb2ludHMocCwgX2N1cnJlbnRQb2ludHNbMF0pO1xuXG5cdFx0ZGVsdGEueCA9IHAueCAtIF9jdXJyUG9pbnQueDtcblx0XHRkZWx0YS55ID0gcC55IC0gX2N1cnJQb2ludC55O1xuXG5cdFx0aWYoX2lzWm9vbWluZyAmJiBudW1Qb2ludHMgPiAxKSB7XG5cdFx0XHQvLyBIYW5kbGUgYmVoYXZpb3VyIGZvciBtb3JlIHRoYW4gMSBwb2ludFxuXG5cdFx0XHRfY3VyclBvaW50LnggPSBwLng7XG5cdFx0XHRfY3VyclBvaW50LnkgPSBwLnk7XG5cdFx0XG5cdFx0XHQvLyBjaGVjayBpZiBvbmUgb2YgdHdvIHBvaW50cyBjaGFuZ2VkXG5cdFx0XHRpZiggIWRlbHRhLnggJiYgIWRlbHRhLnkgJiYgX2lzRXF1YWxQb2ludHMoX2N1cnJlbnRQb2ludHNbMV0sIHAyKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRfZXF1YWxpemVQb2ludHMocDIsIF9jdXJyZW50UG9pbnRzWzFdKTtcblxuXG5cdFx0XHRpZighX3pvb21TdGFydGVkKSB7XG5cdFx0XHRcdF96b29tU3RhcnRlZCA9IHRydWU7XG5cdFx0XHRcdF9zaG91dCgnem9vbUdlc3R1cmVTdGFydGVkJyk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIERpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuXHRcdFx0dmFyIHBvaW50c0Rpc3RhbmNlID0gX2NhbGN1bGF0ZVBvaW50c0Rpc3RhbmNlKHAscDIpO1xuXG5cdFx0XHR2YXIgem9vbUxldmVsID0gX2NhbGN1bGF0ZVpvb21MZXZlbChwb2ludHNEaXN0YW5jZSk7XG5cblx0XHRcdC8vIHNsaWdodGx5IG92ZXIgdGhlIG9mIGluaXRpYWwgem9vbSBsZXZlbFxuXHRcdFx0aWYoem9vbUxldmVsID4gc2VsZi5jdXJySXRlbS5pbml0aWFsWm9vbUxldmVsICsgc2VsZi5jdXJySXRlbS5pbml0aWFsWm9vbUxldmVsIC8gMTUpIHtcblx0XHRcdFx0X3dhc092ZXJJbml0aWFsWm9vbSA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IHRoZSBmcmljdGlvbiBpZiB6b29tIGxldmVsIGlzIG91dCBvZiB0aGUgYm91bmRzXG5cdFx0XHR2YXIgem9vbUZyaWN0aW9uID0gMSxcblx0XHRcdFx0bWluWm9vbUxldmVsID0gX2dldE1pblpvb21MZXZlbCgpLFxuXHRcdFx0XHRtYXhab29tTGV2ZWwgPSBfZ2V0TWF4Wm9vbUxldmVsKCk7XG5cblx0XHRcdGlmICggem9vbUxldmVsIDwgbWluWm9vbUxldmVsICkge1xuXHRcdFx0XHRcblx0XHRcdFx0aWYoX29wdGlvbnMucGluY2hUb0Nsb3NlICYmICFfd2FzT3ZlckluaXRpYWxab29tICYmIF9zdGFydFpvb21MZXZlbCA8PSBzZWxmLmN1cnJJdGVtLmluaXRpYWxab29tTGV2ZWwpIHtcblx0XHRcdFx0XHQvLyBmYWRlIG91dCBiYWNrZ3JvdW5kIGlmIHpvb21pbmcgb3V0XG5cdFx0XHRcdFx0dmFyIG1pbnVzRGlmZiA9IG1pblpvb21MZXZlbCAtIHpvb21MZXZlbDtcblx0XHRcdFx0XHR2YXIgcGVyY2VudCA9IDEgLSBtaW51c0RpZmYgLyAobWluWm9vbUxldmVsIC8gMS4yKTtcblxuXHRcdFx0XHRcdF9hcHBseUJnT3BhY2l0eShwZXJjZW50KTtcblx0XHRcdFx0XHRfc2hvdXQoJ29uUGluY2hDbG9zZScsIHBlcmNlbnQpO1xuXHRcdFx0XHRcdF9vcGFjaXR5Q2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0em9vbUZyaWN0aW9uID0gKG1pblpvb21MZXZlbCAtIHpvb21MZXZlbCkgLyBtaW5ab29tTGV2ZWw7XG5cdFx0XHRcdFx0aWYoem9vbUZyaWN0aW9uID4gMSkge1xuXHRcdFx0XHRcdFx0em9vbUZyaWN0aW9uID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0em9vbUxldmVsID0gbWluWm9vbUxldmVsIC0gem9vbUZyaWN0aW9uICogKG1pblpvb21MZXZlbCAvIDMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0fSBlbHNlIGlmICggem9vbUxldmVsID4gbWF4Wm9vbUxldmVsICkge1xuXHRcdFx0XHQvLyAxLjUgLSBleHRyYSB6b29tIGxldmVsIGFib3ZlIHRoZSBtYXguIEUuZy4gaWYgbWF4IGlzIHg2LCByZWFsIG1heCA2ICsgMS41ID0gNy41XG5cdFx0XHRcdHpvb21GcmljdGlvbiA9ICh6b29tTGV2ZWwgLSBtYXhab29tTGV2ZWwpIC8gKCBtaW5ab29tTGV2ZWwgKiA2ICk7XG5cdFx0XHRcdGlmKHpvb21GcmljdGlvbiA+IDEpIHtcblx0XHRcdFx0XHR6b29tRnJpY3Rpb24gPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHpvb21MZXZlbCA9IG1heFpvb21MZXZlbCArIHpvb21GcmljdGlvbiAqIG1pblpvb21MZXZlbDtcblx0XHRcdH1cblxuXHRcdFx0aWYoem9vbUZyaWN0aW9uIDwgMCkge1xuXHRcdFx0XHR6b29tRnJpY3Rpb24gPSAwO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBkaXN0YW5jZSBiZXR3ZWVuIHRvdWNoIHBvaW50cyBhZnRlciBmcmljdGlvbiBpcyBhcHBsaWVkXG5cdFx0XHRfY3VyclBvaW50c0Rpc3RhbmNlID0gcG9pbnRzRGlzdGFuY2U7XG5cblx0XHRcdC8vIF9jZW50ZXJQb2ludCAtIFRoZSBwb2ludCBpbiB0aGUgbWlkZGxlIG9mIHR3byBwb2ludGVyc1xuXHRcdFx0X2ZpbmRDZW50ZXJPZlBvaW50cyhwLCBwMiwgX2NlbnRlclBvaW50KTtcblx0XHRcblx0XHRcdC8vIHBhbmluZyB3aXRoIHR3byBwb2ludGVycyBwcmVzc2VkXG5cdFx0XHRfY3VyclBhbkRpc3QueCArPSBfY2VudGVyUG9pbnQueCAtIF9jdXJyQ2VudGVyUG9pbnQueDtcblx0XHRcdF9jdXJyUGFuRGlzdC55ICs9IF9jZW50ZXJQb2ludC55IC0gX2N1cnJDZW50ZXJQb2ludC55O1xuXHRcdFx0X2VxdWFsaXplUG9pbnRzKF9jdXJyQ2VudGVyUG9pbnQsIF9jZW50ZXJQb2ludCk7XG5cblx0XHRcdF9wYW5PZmZzZXQueCA9IF9jYWxjdWxhdGVQYW5PZmZzZXQoJ3gnLCB6b29tTGV2ZWwpO1xuXHRcdFx0X3Bhbk9mZnNldC55ID0gX2NhbGN1bGF0ZVBhbk9mZnNldCgneScsIHpvb21MZXZlbCk7XG5cblx0XHRcdF9pc1pvb21pbmdJbiA9IHpvb21MZXZlbCA+IF9jdXJyWm9vbUxldmVsO1xuXHRcdFx0X2N1cnJab29tTGV2ZWwgPSB6b29tTGV2ZWw7XG5cdFx0XHRfYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gaGFuZGxlIGJlaGF2aW91ciBmb3Igb25lIHBvaW50IChkcmFnZ2luZyBvciBwYW5uaW5nKVxuXG5cdFx0XHRpZighX2RpcmVjdGlvbikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmKF9pc0ZpcnN0TW92ZSkge1xuXHRcdFx0XHRfaXNGaXJzdE1vdmUgPSBmYWxzZTtcblxuXHRcdFx0XHQvLyBzdWJ0cmFjdCBkcmFnIGRpc3RhbmNlIHRoYXQgd2FzIHVzZWQgZHVyaW5nIHRoZSBkZXRlY3Rpb24gZGlyZWN0aW9uICBcblxuXHRcdFx0XHRpZiggTWF0aC5hYnMoZGVsdGEueCkgPj0gRElSRUNUSU9OX0NIRUNLX09GRlNFVCkge1xuXHRcdFx0XHRcdGRlbHRhLnggLT0gX2N1cnJlbnRQb2ludHNbMF0ueCAtIF9zdGFydFBvaW50Lng7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmKCBNYXRoLmFicyhkZWx0YS55KSA+PSBESVJFQ1RJT05fQ0hFQ0tfT0ZGU0VUKSB7XG5cdFx0XHRcdFx0ZGVsdGEueSAtPSBfY3VycmVudFBvaW50c1swXS55IC0gX3N0YXJ0UG9pbnQueTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRfY3VyclBvaW50LnggPSBwLng7XG5cdFx0XHRfY3VyclBvaW50LnkgPSBwLnk7XG5cblx0XHRcdC8vIGRvIG5vdGhpbmcgaWYgcG9pbnRlcnMgcG9zaXRpb24gaGFzbid0IGNoYW5nZWRcblx0XHRcdGlmKGRlbHRhLnggPT09IDAgJiYgZGVsdGEueSA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmKF9kaXJlY3Rpb24gPT09ICd2JyAmJiBfb3B0aW9ucy5jbG9zZU9uVmVydGljYWxEcmFnKSB7XG5cdFx0XHRcdGlmKCFfY2FuUGFuKCkpIHtcblx0XHRcdFx0XHRfY3VyclBhbkRpc3QueSArPSBkZWx0YS55O1xuXHRcdFx0XHRcdF9wYW5PZmZzZXQueSArPSBkZWx0YS55O1xuXG5cdFx0XHRcdFx0dmFyIG9wYWNpdHlSYXRpbyA9IF9jYWxjdWxhdGVWZXJ0aWNhbERyYWdPcGFjaXR5UmF0aW8oKTtcblxuXHRcdFx0XHRcdF92ZXJ0aWNhbERyYWdJbml0aWF0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdF9zaG91dCgnb25WZXJ0aWNhbERyYWcnLCBvcGFjaXR5UmF0aW8pO1xuXG5cdFx0XHRcdFx0X2FwcGx5QmdPcGFjaXR5KG9wYWNpdHlSYXRpbyk7XG5cdFx0XHRcdFx0X2FwcGx5Q3VycmVudFpvb21QYW4oKTtcblx0XHRcdFx0XHRyZXR1cm4gO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdF9wdXNoUG9zUG9pbnQoX2dldEN1cnJlbnRUaW1lKCksIHAueCwgcC55KTtcblxuXHRcdFx0X21vdmVkID0gdHJ1ZTtcblx0XHRcdF9jdXJyUGFuQm91bmRzID0gc2VsZi5jdXJySXRlbS5ib3VuZHM7XG5cdFx0XHRcblx0XHRcdHZhciBtYWluU2Nyb2xsQ2hhbmdlZCA9IF9wYW5Pck1vdmVNYWluU2Nyb2xsKCd4JywgZGVsdGEpO1xuXHRcdFx0aWYoIW1haW5TY3JvbGxDaGFuZ2VkKSB7XG5cdFx0XHRcdF9wYW5Pck1vdmVNYWluU2Nyb2xsKCd5JywgZGVsdGEpO1xuXG5cdFx0XHRcdF9yb3VuZFBvaW50KF9wYW5PZmZzZXQpO1xuXHRcdFx0XHRfYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0sXG5cdFxuXHQvLyBQb2ludGVydXAvcG9pbnRlcmNhbmNlbC90b3VjaGVuZC90b3VjaGNhbmNlbC9tb3VzZXVwIGV2ZW50IGhhbmRsZXJcblx0X29uRHJhZ1JlbGVhc2UgPSBmdW5jdGlvbihlKSB7XG5cblx0XHRpZihfZmVhdHVyZXMuaXNPbGRBbmRyb2lkICkge1xuXG5cdFx0XHRpZihfb2xkQW5kcm9pZFRvdWNoRW5kVGltZW91dCAmJiBlLnR5cGUgPT09ICdtb3VzZXVwJykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIG9uIEFuZHJvaWQgKHY0LjEsIDQuMiwgNC4zICYgcG9zc2libHkgb2xkZXIpIFxuXHRcdFx0Ly8gZ2hvc3QgbW91c2Vkb3duL3VwIGV2ZW50IGlzbid0IHByZXZlbnRhYmxlIHZpYSBlLnByZXZlbnREZWZhdWx0LFxuXHRcdFx0Ly8gd2hpY2ggY2F1c2VzIGZha2UgbW91c2Vkb3duIGV2ZW50XG5cdFx0XHQvLyBzbyB3ZSBibG9jayBtb3VzZWRvd24vdXAgZm9yIDYwMG1zXG5cdFx0XHRpZiggZS50eXBlLmluZGV4T2YoJ3RvdWNoJykgPiAtMSApIHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KF9vbGRBbmRyb2lkVG91Y2hFbmRUaW1lb3V0KTtcblx0XHRcdFx0X29sZEFuZHJvaWRUb3VjaEVuZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdF9vbGRBbmRyb2lkVG91Y2hFbmRUaW1lb3V0ID0gMDtcblx0XHRcdFx0fSwgNjAwKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdH1cblxuXHRcdF9zaG91dCgncG9pbnRlclVwJyk7XG5cblx0XHRpZihfcHJldmVudERlZmF1bHRFdmVudEJlaGF2aW91cihlLCBmYWxzZSkpIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHR2YXIgcmVsZWFzZVBvaW50O1xuXG5cdFx0aWYoX3BvaW50ZXJFdmVudEVuYWJsZWQpIHtcblx0XHRcdHZhciBwb2ludGVySW5kZXggPSBmcmFtZXdvcmsuYXJyYXlTZWFyY2goX2N1cnJQb2ludGVycywgZS5wb2ludGVySWQsICdpZCcpO1xuXHRcdFx0XG5cdFx0XHRpZihwb2ludGVySW5kZXggPiAtMSkge1xuXHRcdFx0XHRyZWxlYXNlUG9pbnQgPSBfY3VyclBvaW50ZXJzLnNwbGljZShwb2ludGVySW5kZXgsIDEpWzBdO1xuXG5cdFx0XHRcdGlmKG5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKSB7XG5cdFx0XHRcdFx0dmFyIE1TUE9JTlRFUl9UWVBFUyA9IHtcblx0XHRcdFx0XHRcdDQ6ICdtb3VzZScsIC8vIGV2ZW50Lk1TUE9JTlRFUl9UWVBFX01PVVNFXG5cdFx0XHRcdFx0XHQyOiAndG91Y2gnLCAvLyBldmVudC5NU1BPSU5URVJfVFlQRV9UT1VDSCBcblx0XHRcdFx0XHRcdDM6ICdwZW4nIC8vIGV2ZW50Lk1TUE9JTlRFUl9UWVBFX1BFTlxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0cmVsZWFzZVBvaW50LnR5cGUgPSBNU1BPSU5URVJfVFlQRVNbZS5wb2ludGVyVHlwZV07XG5cblx0XHRcdFx0XHRpZighcmVsZWFzZVBvaW50LnR5cGUpIHtcblx0XHRcdFx0XHRcdHJlbGVhc2VQb2ludC50eXBlID0gZS5wb2ludGVyVHlwZSB8fCAnbW91c2UnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZWxlYXNlUG9pbnQudHlwZSA9IGUucG9pbnRlclR5cGUgfHwgJ21vdXNlJztcblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIHRvdWNoTGlzdCA9IF9nZXRUb3VjaFBvaW50cyhlKSxcblx0XHRcdGdlc3R1cmVUeXBlLFxuXHRcdFx0bnVtUG9pbnRzID0gdG91Y2hMaXN0Lmxlbmd0aDtcblxuXHRcdGlmKGUudHlwZSA9PT0gJ21vdXNldXAnKSB7XG5cdFx0XHRudW1Qb2ludHMgPSAwO1xuXHRcdH1cblxuXHRcdC8vIERvIG5vdGhpbmcgaWYgdGhlcmUgd2VyZSAzIHRvdWNoIHBvaW50cyBvciBtb3JlXG5cdFx0aWYobnVtUG9pbnRzID09PSAyKSB7XG5cdFx0XHRfY3VycmVudFBvaW50cyA9IG51bGw7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBpZiBzZWNvbmQgcG9pbnRlciByZWxlYXNlZFxuXHRcdGlmKG51bVBvaW50cyA9PT0gMSkge1xuXHRcdFx0X2VxdWFsaXplUG9pbnRzKF9zdGFydFBvaW50LCB0b3VjaExpc3RbMF0pO1xuXHRcdH1cdFx0XHRcdFxuXG5cblx0XHQvLyBwb2ludGVyIGhhc24ndCBtb3ZlZCwgc2VuZCBcInRhcCByZWxlYXNlXCIgcG9pbnRcblx0XHRpZihudW1Qb2ludHMgPT09IDAgJiYgIV9kaXJlY3Rpb24gJiYgIV9tYWluU2Nyb2xsQW5pbWF0aW5nKSB7XG5cdFx0XHRpZighcmVsZWFzZVBvaW50KSB7XG5cdFx0XHRcdGlmKGUudHlwZSA9PT0gJ21vdXNldXAnKSB7XG5cdFx0XHRcdFx0cmVsZWFzZVBvaW50ID0ge3g6IGUucGFnZVgsIHk6IGUucGFnZVksIHR5cGU6J21vdXNlJ307XG5cdFx0XHRcdH0gZWxzZSBpZihlLmNoYW5nZWRUb3VjaGVzICYmIGUuY2hhbmdlZFRvdWNoZXNbMF0pIHtcblx0XHRcdFx0XHRyZWxlYXNlUG9pbnQgPSB7eDogZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCwgeTogZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWSwgdHlwZTondG91Y2gnfTtcblx0XHRcdFx0fVx0XHRcblx0XHRcdH1cblxuXHRcdFx0X3Nob3V0KCd0b3VjaFJlbGVhc2UnLCBlLCByZWxlYXNlUG9pbnQpO1xuXHRcdH1cblxuXHRcdC8vIERpZmZlcmVuY2UgaW4gdGltZSBiZXR3ZWVuIHJlbGVhc2luZyBvZiB0d28gbGFzdCB0b3VjaCBwb2ludHMgKHpvb20gZ2VzdHVyZSlcblx0XHR2YXIgcmVsZWFzZVRpbWVEaWZmID0gLTE7XG5cblx0XHQvLyBHZXN0dXJlIGNvbXBsZXRlZCwgbm8gcG9pbnRlcnMgbGVmdFxuXHRcdGlmKG51bVBvaW50cyA9PT0gMCkge1xuXHRcdFx0X2lzRHJhZ2dpbmcgPSBmYWxzZTtcblx0XHRcdGZyYW1ld29yay51bmJpbmQod2luZG93LCBfdXBNb3ZlRXZlbnRzLCBzZWxmKTtcblxuXHRcdFx0X3N0b3BEcmFnVXBkYXRlTG9vcCgpO1xuXG5cdFx0XHRpZihfaXNab29taW5nKSB7XG5cdFx0XHRcdC8vIFR3byBwb2ludHMgcmVsZWFzZWQgYXQgdGhlIHNhbWUgdGltZVxuXHRcdFx0XHRyZWxlYXNlVGltZURpZmYgPSAwO1xuXHRcdFx0fSBlbHNlIGlmKF9sYXN0UmVsZWFzZVRpbWUgIT09IC0xKSB7XG5cdFx0XHRcdHJlbGVhc2VUaW1lRGlmZiA9IF9nZXRDdXJyZW50VGltZSgpIC0gX2xhc3RSZWxlYXNlVGltZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0X2xhc3RSZWxlYXNlVGltZSA9IG51bVBvaW50cyA9PT0gMSA/IF9nZXRDdXJyZW50VGltZSgpIDogLTE7XG5cdFx0XG5cdFx0aWYocmVsZWFzZVRpbWVEaWZmICE9PSAtMSAmJiByZWxlYXNlVGltZURpZmYgPCAxNTApIHtcblx0XHRcdGdlc3R1cmVUeXBlID0gJ3pvb20nO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRnZXN0dXJlVHlwZSA9ICdzd2lwZSc7XG5cdFx0fVxuXG5cdFx0aWYoX2lzWm9vbWluZyAmJiBudW1Qb2ludHMgPCAyKSB7XG5cdFx0XHRfaXNab29taW5nID0gZmFsc2U7XG5cblx0XHRcdC8vIE9ubHkgc2Vjb25kIHBvaW50IHJlbGVhc2VkXG5cdFx0XHRpZihudW1Qb2ludHMgPT09IDEpIHtcblx0XHRcdFx0Z2VzdHVyZVR5cGUgPSAnem9vbVBvaW50ZXJVcCc7XG5cdFx0XHR9XG5cdFx0XHRfc2hvdXQoJ3pvb21HZXN0dXJlRW5kZWQnKTtcblx0XHR9XG5cblx0XHRfY3VycmVudFBvaW50cyA9IG51bGw7XG5cdFx0aWYoIV9tb3ZlZCAmJiAhX3pvb21TdGFydGVkICYmICFfbWFpblNjcm9sbEFuaW1hdGluZyAmJiAhX3ZlcnRpY2FsRHJhZ0luaXRpYXRlZCkge1xuXHRcdFx0Ly8gbm90aGluZyB0byBhbmltYXRlXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcblx0XHRfc3RvcEFsbEFuaW1hdGlvbnMoKTtcblxuXHRcdFxuXHRcdGlmKCFfcmVsZWFzZUFuaW1EYXRhKSB7XG5cdFx0XHRfcmVsZWFzZUFuaW1EYXRhID0gX2luaXREcmFnUmVsZWFzZUFuaW1hdGlvbkRhdGEoKTtcblx0XHR9XG5cdFx0XG5cdFx0X3JlbGVhc2VBbmltRGF0YS5jYWxjdWxhdGVTd2lwZVNwZWVkKCd4Jyk7XG5cblxuXHRcdGlmKF92ZXJ0aWNhbERyYWdJbml0aWF0ZWQpIHtcblxuXHRcdFx0dmFyIG9wYWNpdHlSYXRpbyA9IF9jYWxjdWxhdGVWZXJ0aWNhbERyYWdPcGFjaXR5UmF0aW8oKTtcblxuXHRcdFx0aWYob3BhY2l0eVJhdGlvIDwgX29wdGlvbnMudmVydGljYWxEcmFnUmFuZ2UpIHtcblx0XHRcdFx0c2VsZi5jbG9zZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGluaXRhbFBhblkgPSBfcGFuT2Zmc2V0LnksXG5cdFx0XHRcdFx0aW5pdGlhbEJnT3BhY2l0eSA9IF9iZ09wYWNpdHk7XG5cblx0XHRcdFx0X2FuaW1hdGVQcm9wKCd2ZXJ0aWNhbERyYWcnLCAwLCAxLCAzMDAsIGZyYW1ld29yay5lYXNpbmcuY3ViaWMub3V0LCBmdW5jdGlvbihub3cpIHtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRfcGFuT2Zmc2V0LnkgPSAoc2VsZi5jdXJySXRlbS5pbml0aWFsUG9zaXRpb24ueSAtIGluaXRhbFBhblkpICogbm93ICsgaW5pdGFsUGFuWTtcblxuXHRcdFx0XHRcdF9hcHBseUJnT3BhY2l0eSggICgxIC0gaW5pdGlhbEJnT3BhY2l0eSkgKiBub3cgKyBpbml0aWFsQmdPcGFjaXR5ICk7XG5cdFx0XHRcdFx0X2FwcGx5Q3VycmVudFpvb21QYW4oKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0X3Nob3V0KCdvblZlcnRpY2FsRHJhZycsIDEpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cblx0XHQvLyBtYWluIHNjcm9sbCBcblx0XHRpZiggIChfbWFpblNjcm9sbFNoaWZ0ZWQgfHwgX21haW5TY3JvbGxBbmltYXRpbmcpICYmIG51bVBvaW50cyA9PT0gMCkge1xuXHRcdFx0dmFyIGl0ZW1DaGFuZ2VkID0gX2ZpbmlzaFN3aXBlTWFpblNjcm9sbEdlc3R1cmUoZ2VzdHVyZVR5cGUsIF9yZWxlYXNlQW5pbURhdGEpO1xuXHRcdFx0aWYoaXRlbUNoYW5nZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Z2VzdHVyZVR5cGUgPSAnem9vbVBvaW50ZXJVcCc7XG5cdFx0fVxuXG5cdFx0Ly8gcHJldmVudCB6b29tL3BhbiBhbmltYXRpb24gd2hlbiBtYWluIHNjcm9sbCBhbmltYXRpb24gcnVuc1xuXHRcdGlmKF9tYWluU2Nyb2xsQW5pbWF0aW5nKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdFxuXHRcdC8vIENvbXBsZXRlIHNpbXBsZSB6b29tIGdlc3R1cmUgKHJlc2V0IHpvb20gbGV2ZWwgaWYgaXQncyBvdXQgb2YgdGhlIGJvdW5kcykgIFxuXHRcdGlmKGdlc3R1cmVUeXBlICE9PSAnc3dpcGUnKSB7XG5cdFx0XHRfY29tcGxldGVab29tR2VzdHVyZSgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XG5cdFx0Ly8gQ29tcGxldGUgcGFuIGdlc3R1cmUgaWYgbWFpbiBzY3JvbGwgaXMgbm90IHNoaWZ0ZWQsIGFuZCBpdCdzIHBvc3NpYmxlIHRvIHBhbiBjdXJyZW50IGltYWdlXG5cdFx0aWYoIV9tYWluU2Nyb2xsU2hpZnRlZCAmJiBfY3Vyclpvb21MZXZlbCA+IHNlbGYuY3Vyckl0ZW0uZml0UmF0aW8pIHtcblx0XHRcdF9jb21wbGV0ZVBhbkdlc3R1cmUoX3JlbGVhc2VBbmltRGF0YSk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gUmV0dXJucyBvYmplY3Qgd2l0aCBkYXRhIGFib3V0IGdlc3R1cmVcblx0Ly8gSXQncyBjcmVhdGVkIG9ubHkgb25jZSBhbmQgdGhlbiByZXVzZWRcblx0X2luaXREcmFnUmVsZWFzZUFuaW1hdGlvbkRhdGEgID0gZnVuY3Rpb24oKSB7XG5cdFx0Ly8gdGVtcCBsb2NhbCB2YXJzXG5cdFx0dmFyIGxhc3RGbGlja0R1cmF0aW9uLFxuXHRcdFx0dGVtcFJlbGVhc2VQb3M7XG5cblx0XHQvLyBzID0gdGhpc1xuXHRcdHZhciBzID0ge1xuXHRcdFx0bGFzdEZsaWNrT2Zmc2V0OiB7fSxcblx0XHRcdGxhc3RGbGlja0Rpc3Q6IHt9LFxuXHRcdFx0bGFzdEZsaWNrU3BlZWQ6IHt9LFxuXHRcdFx0c2xvd0Rvd25SYXRpbzogIHt9LFxuXHRcdFx0c2xvd0Rvd25SYXRpb1JldmVyc2U6ICB7fSxcblx0XHRcdHNwZWVkRGVjZWxlcmF0aW9uUmF0aW86ICB7fSxcblx0XHRcdHNwZWVkRGVjZWxlcmF0aW9uUmF0aW9BYnM6ICB7fSxcblx0XHRcdGRpc3RhbmNlT2Zmc2V0OiAge30sXG5cdFx0XHRiYWNrQW5pbURlc3RpbmF0aW9uOiB7fSxcblx0XHRcdGJhY2tBbmltU3RhcnRlZDoge30sXG5cdFx0XHRjYWxjdWxhdGVTd2lwZVNwZWVkOiBmdW5jdGlvbihheGlzKSB7XG5cdFx0XHRcdFxuXG5cdFx0XHRcdGlmKCBfcG9zUG9pbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRsYXN0RmxpY2tEdXJhdGlvbiA9IF9nZXRDdXJyZW50VGltZSgpIC0gX2dlc3R1cmVDaGVja1NwZWVkVGltZSArIDUwO1xuXHRcdFx0XHRcdHRlbXBSZWxlYXNlUG9zID0gX3Bvc1BvaW50c1tfcG9zUG9pbnRzLmxlbmd0aC0yXVtheGlzXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsYXN0RmxpY2tEdXJhdGlvbiA9IF9nZXRDdXJyZW50VGltZSgpIC0gX2dlc3R1cmVTdGFydFRpbWU7IC8vIHRvdGFsIGdlc3R1cmUgZHVyYXRpb25cblx0XHRcdFx0XHR0ZW1wUmVsZWFzZVBvcyA9IF9zdGFydFBvaW50W2F4aXNdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHMubGFzdEZsaWNrT2Zmc2V0W2F4aXNdID0gX2N1cnJQb2ludFtheGlzXSAtIHRlbXBSZWxlYXNlUG9zO1xuXHRcdFx0XHRzLmxhc3RGbGlja0Rpc3RbYXhpc10gPSBNYXRoLmFicyhzLmxhc3RGbGlja09mZnNldFtheGlzXSk7XG5cdFx0XHRcdGlmKHMubGFzdEZsaWNrRGlzdFtheGlzXSA+IDIwKSB7XG5cdFx0XHRcdFx0cy5sYXN0RmxpY2tTcGVlZFtheGlzXSA9IHMubGFzdEZsaWNrT2Zmc2V0W2F4aXNdIC8gbGFzdEZsaWNrRHVyYXRpb247XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cy5sYXN0RmxpY2tTcGVlZFtheGlzXSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIE1hdGguYWJzKHMubGFzdEZsaWNrU3BlZWRbYXhpc10pIDwgMC4xICkge1xuXHRcdFx0XHRcdHMubGFzdEZsaWNrU3BlZWRbYXhpc10gPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRzLnNsb3dEb3duUmF0aW9bYXhpc10gPSAwLjk1O1xuXHRcdFx0XHRzLnNsb3dEb3duUmF0aW9SZXZlcnNlW2F4aXNdID0gMSAtIHMuc2xvd0Rvd25SYXRpb1theGlzXTtcblx0XHRcdFx0cy5zcGVlZERlY2VsZXJhdGlvblJhdGlvW2F4aXNdID0gMTtcblx0XHRcdH0sXG5cblx0XHRcdGNhbGN1bGF0ZU92ZXJCb3VuZHNBbmltT2Zmc2V0OiBmdW5jdGlvbihheGlzLCBzcGVlZCkge1xuXHRcdFx0XHRpZighcy5iYWNrQW5pbVN0YXJ0ZWRbYXhpc10pIHtcblxuXHRcdFx0XHRcdGlmKF9wYW5PZmZzZXRbYXhpc10gPiBfY3VyclBhbkJvdW5kcy5taW5bYXhpc10pIHtcblx0XHRcdFx0XHRcdHMuYmFja0FuaW1EZXN0aW5hdGlvbltheGlzXSA9IF9jdXJyUGFuQm91bmRzLm1pbltheGlzXTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdH0gZWxzZSBpZihfcGFuT2Zmc2V0W2F4aXNdIDwgX2N1cnJQYW5Cb3VuZHMubWF4W2F4aXNdKSB7XG5cdFx0XHRcdFx0XHRzLmJhY2tBbmltRGVzdGluYXRpb25bYXhpc10gPSBfY3VyclBhbkJvdW5kcy5tYXhbYXhpc107XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYocy5iYWNrQW5pbURlc3RpbmF0aW9uW2F4aXNdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHMuc2xvd0Rvd25SYXRpb1theGlzXSA9IDAuNztcblx0XHRcdFx0XHRcdHMuc2xvd0Rvd25SYXRpb1JldmVyc2VbYXhpc10gPSAxIC0gcy5zbG93RG93blJhdGlvW2F4aXNdO1xuXHRcdFx0XHRcdFx0aWYocy5zcGVlZERlY2VsZXJhdGlvblJhdGlvQWJzW2F4aXNdIDwgMC4wNSkge1xuXG5cdFx0XHRcdFx0XHRcdHMubGFzdEZsaWNrU3BlZWRbYXhpc10gPSAwO1xuXHRcdFx0XHRcdFx0XHRzLmJhY2tBbmltU3RhcnRlZFtheGlzXSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0X2FuaW1hdGVQcm9wKCdib3VuY2Vab29tUGFuJytheGlzLF9wYW5PZmZzZXRbYXhpc10sIFxuXHRcdFx0XHRcdFx0XHRcdHMuYmFja0FuaW1EZXN0aW5hdGlvbltheGlzXSwgXG5cdFx0XHRcdFx0XHRcdFx0c3BlZWQgfHwgMzAwLCBcblx0XHRcdFx0XHRcdFx0XHRmcmFtZXdvcmsuZWFzaW5nLnNpbmUub3V0LCBcblx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbihwb3MpIHtcblx0XHRcdFx0XHRcdFx0XHRcdF9wYW5PZmZzZXRbYXhpc10gPSBwb3M7XG5cdFx0XHRcdFx0XHRcdFx0XHRfYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVkdWNlcyB0aGUgc3BlZWQgYnkgc2xvd0Rvd25SYXRpbyAocGVyIDEwbXMpXG5cdFx0XHRjYWxjdWxhdGVBbmltT2Zmc2V0OiBmdW5jdGlvbihheGlzKSB7XG5cdFx0XHRcdGlmKCFzLmJhY2tBbmltU3RhcnRlZFtheGlzXSkge1xuXHRcdFx0XHRcdHMuc3BlZWREZWNlbGVyYXRpb25SYXRpb1theGlzXSA9IHMuc3BlZWREZWNlbGVyYXRpb25SYXRpb1theGlzXSAqIChzLnNsb3dEb3duUmF0aW9bYXhpc10gKyBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHMuc2xvd0Rvd25SYXRpb1JldmVyc2VbYXhpc10gLSBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHMuc2xvd0Rvd25SYXRpb1JldmVyc2VbYXhpc10gKiBzLnRpbWVEaWZmIC8gMTApO1xuXG5cdFx0XHRcdFx0cy5zcGVlZERlY2VsZXJhdGlvblJhdGlvQWJzW2F4aXNdID0gTWF0aC5hYnMocy5sYXN0RmxpY2tTcGVlZFtheGlzXSAqIHMuc3BlZWREZWNlbGVyYXRpb25SYXRpb1theGlzXSk7XG5cdFx0XHRcdFx0cy5kaXN0YW5jZU9mZnNldFtheGlzXSA9IHMubGFzdEZsaWNrU3BlZWRbYXhpc10gKiBzLnNwZWVkRGVjZWxlcmF0aW9uUmF0aW9bYXhpc10gKiBzLnRpbWVEaWZmO1xuXHRcdFx0XHRcdF9wYW5PZmZzZXRbYXhpc10gKz0gcy5kaXN0YW5jZU9mZnNldFtheGlzXTtcblxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRwYW5BbmltTG9vcDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggX2FuaW1hdGlvbnMuem9vbVBhbiApIHtcblx0XHRcdFx0XHRfYW5pbWF0aW9ucy56b29tUGFuLnJhZiA9IF9yZXF1ZXN0QUYocy5wYW5BbmltTG9vcCk7XG5cblx0XHRcdFx0XHRzLm5vdyA9IF9nZXRDdXJyZW50VGltZSgpO1xuXHRcdFx0XHRcdHMudGltZURpZmYgPSBzLm5vdyAtIHMubGFzdE5vdztcblx0XHRcdFx0XHRzLmxhc3ROb3cgPSBzLm5vdztcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRzLmNhbGN1bGF0ZUFuaW1PZmZzZXQoJ3gnKTtcblx0XHRcdFx0XHRzLmNhbGN1bGF0ZUFuaW1PZmZzZXQoJ3knKTtcblxuXHRcdFx0XHRcdF9hcHBseUN1cnJlbnRab29tUGFuKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cy5jYWxjdWxhdGVPdmVyQm91bmRzQW5pbU9mZnNldCgneCcpO1xuXHRcdFx0XHRcdHMuY2FsY3VsYXRlT3ZlckJvdW5kc0FuaW1PZmZzZXQoJ3knKTtcblxuXG5cdFx0XHRcdFx0aWYgKHMuc3BlZWREZWNlbGVyYXRpb25SYXRpb0Ficy54IDwgMC4wNSAmJiBzLnNwZWVkRGVjZWxlcmF0aW9uUmF0aW9BYnMueSA8IDAuMDUpIHtcblxuXHRcdFx0XHRcdFx0Ly8gcm91bmQgcGFuIHBvc2l0aW9uXG5cdFx0XHRcdFx0XHRfcGFuT2Zmc2V0LnggPSBNYXRoLnJvdW5kKF9wYW5PZmZzZXQueCk7XG5cdFx0XHRcdFx0XHRfcGFuT2Zmc2V0LnkgPSBNYXRoLnJvdW5kKF9wYW5PZmZzZXQueSk7XG5cdFx0XHRcdFx0XHRfYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRfc3RvcEFuaW1hdGlvbignem9vbVBhbicpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gcztcblx0fSxcblxuXHRfY29tcGxldGVQYW5HZXN0dXJlID0gZnVuY3Rpb24oYW5pbURhdGEpIHtcblx0XHQvLyBjYWxjdWxhdGUgc3dpcGUgc3BlZWQgZm9yIFkgYXhpcyAocGFhbm5pbmcpXG5cdFx0YW5pbURhdGEuY2FsY3VsYXRlU3dpcGVTcGVlZCgneScpO1xuXG5cdFx0X2N1cnJQYW5Cb3VuZHMgPSBzZWxmLmN1cnJJdGVtLmJvdW5kcztcblx0XHRcblx0XHRhbmltRGF0YS5iYWNrQW5pbURlc3RpbmF0aW9uID0ge307XG5cdFx0YW5pbURhdGEuYmFja0FuaW1TdGFydGVkID0ge307XG5cblx0XHQvLyBBdm9pZCBhY2NlbGVyYXRpb24gYW5pbWF0aW9uIGlmIHNwZWVkIGlzIHRvbyBsb3dcblx0XHRpZihNYXRoLmFicyhhbmltRGF0YS5sYXN0RmxpY2tTcGVlZC54KSA8PSAwLjA1ICYmIE1hdGguYWJzKGFuaW1EYXRhLmxhc3RGbGlja1NwZWVkLnkpIDw9IDAuMDUgKSB7XG5cdFx0XHRhbmltRGF0YS5zcGVlZERlY2VsZXJhdGlvblJhdGlvQWJzLnggPSBhbmltRGF0YS5zcGVlZERlY2VsZXJhdGlvblJhdGlvQWJzLnkgPSAwO1xuXG5cdFx0XHQvLyBSdW4gcGFuIGRyYWcgcmVsZWFzZSBhbmltYXRpb24uIEUuZy4gaWYgeW91IGRyYWcgaW1hZ2UgYW5kIHJlbGVhc2UgZmluZ2VyIHdpdGhvdXQgbW9tZW50dW0uXG5cdFx0XHRhbmltRGF0YS5jYWxjdWxhdGVPdmVyQm91bmRzQW5pbU9mZnNldCgneCcpO1xuXHRcdFx0YW5pbURhdGEuY2FsY3VsYXRlT3ZlckJvdW5kc0FuaW1PZmZzZXQoJ3knKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIEFuaW1hdGlvbiBsb29wIHRoYXQgY29udHJvbHMgdGhlIGFjY2VsZXJhdGlvbiBhZnRlciBwYW4gZ2VzdHVyZSBlbmRzXG5cdFx0X3JlZ2lzdGVyU3RhcnRBbmltYXRpb24oJ3pvb21QYW4nKTtcblx0XHRhbmltRGF0YS5sYXN0Tm93ID0gX2dldEN1cnJlbnRUaW1lKCk7XG5cdFx0YW5pbURhdGEucGFuQW5pbUxvb3AoKTtcblx0fSxcblxuXG5cdF9maW5pc2hTd2lwZU1haW5TY3JvbGxHZXN0dXJlID0gZnVuY3Rpb24oZ2VzdHVyZVR5cGUsIF9yZWxlYXNlQW5pbURhdGEpIHtcblx0XHR2YXIgaXRlbUNoYW5nZWQ7XG5cdFx0aWYoIV9tYWluU2Nyb2xsQW5pbWF0aW5nKSB7XG5cdFx0XHRfY3Vyclpvb21lZEl0ZW1JbmRleCA9IF9jdXJyZW50SXRlbUluZGV4O1xuXHRcdH1cblxuXG5cdFx0XG5cdFx0dmFyIGl0ZW1zRGlmZjtcblxuXHRcdGlmKGdlc3R1cmVUeXBlID09PSAnc3dpcGUnKSB7XG5cdFx0XHR2YXIgdG90YWxTaGlmdERpc3QgPSBfY3VyclBvaW50LnggLSBfc3RhcnRQb2ludC54LFxuXHRcdFx0XHRpc0Zhc3RMYXN0RmxpY2sgPSBfcmVsZWFzZUFuaW1EYXRhLmxhc3RGbGlja0Rpc3QueCA8IDEwO1xuXG5cdFx0XHQvLyBpZiBjb250YWluZXIgaXMgc2hpZnRlZCBmb3IgbW9yZSB0aGFuIE1JTl9TV0lQRV9ESVNUQU5DRSwgXG5cdFx0XHQvLyBhbmQgbGFzdCBmbGljayBnZXN0dXJlIHdhcyBpbiByaWdodCBkaXJlY3Rpb25cblx0XHRcdGlmKHRvdGFsU2hpZnREaXN0ID4gTUlOX1NXSVBFX0RJU1RBTkNFICYmIFxuXHRcdFx0XHQoaXNGYXN0TGFzdEZsaWNrIHx8IF9yZWxlYXNlQW5pbURhdGEubGFzdEZsaWNrT2Zmc2V0LnggPiAyMCkgKSB7XG5cdFx0XHRcdC8vIGdvIHRvIHByZXYgaXRlbVxuXHRcdFx0XHRpdGVtc0RpZmYgPSAtMTtcblx0XHRcdH0gZWxzZSBpZih0b3RhbFNoaWZ0RGlzdCA8IC1NSU5fU1dJUEVfRElTVEFOQ0UgJiYgXG5cdFx0XHRcdChpc0Zhc3RMYXN0RmxpY2sgfHwgX3JlbGVhc2VBbmltRGF0YS5sYXN0RmxpY2tPZmZzZXQueCA8IC0yMCkgKSB7XG5cdFx0XHRcdC8vIGdvIHRvIG5leHQgaXRlbVxuXHRcdFx0XHRpdGVtc0RpZmYgPSAxO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBuZXh0Q2lyY2xlO1xuXG5cdFx0aWYoaXRlbXNEaWZmKSB7XG5cdFx0XHRcblx0XHRcdF9jdXJyZW50SXRlbUluZGV4ICs9IGl0ZW1zRGlmZjtcblxuXHRcdFx0aWYoX2N1cnJlbnRJdGVtSW5kZXggPCAwKSB7XG5cdFx0XHRcdF9jdXJyZW50SXRlbUluZGV4ID0gX29wdGlvbnMubG9vcCA/IF9nZXROdW1JdGVtcygpLTEgOiAwO1xuXHRcdFx0XHRuZXh0Q2lyY2xlID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSBpZihfY3VycmVudEl0ZW1JbmRleCA+PSBfZ2V0TnVtSXRlbXMoKSkge1xuXHRcdFx0XHRfY3VycmVudEl0ZW1JbmRleCA9IF9vcHRpb25zLmxvb3AgPyAwIDogX2dldE51bUl0ZW1zKCktMTtcblx0XHRcdFx0bmV4dENpcmNsZSA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmKCFuZXh0Q2lyY2xlIHx8IF9vcHRpb25zLmxvb3ApIHtcblx0XHRcdFx0X2luZGV4RGlmZiArPSBpdGVtc0RpZmY7XG5cdFx0XHRcdF9jdXJyUG9zaXRpb25JbmRleCAtPSBpdGVtc0RpZmY7XG5cdFx0XHRcdGl0ZW1DaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdFxuXG5cdFx0XHRcblx0XHR9XG5cblx0XHR2YXIgYW5pbWF0ZVRvWCA9IF9zbGlkZVNpemUueCAqIF9jdXJyUG9zaXRpb25JbmRleDtcblx0XHR2YXIgYW5pbWF0ZVRvRGlzdCA9IE1hdGguYWJzKCBhbmltYXRlVG9YIC0gX21haW5TY3JvbGxQb3MueCApO1xuXHRcdHZhciBmaW5pc2hBbmltRHVyYXRpb247XG5cblxuXHRcdGlmKCFpdGVtQ2hhbmdlZCAmJiBhbmltYXRlVG9YID4gX21haW5TY3JvbGxQb3MueCAhPT0gX3JlbGVhc2VBbmltRGF0YS5sYXN0RmxpY2tTcGVlZC54ID4gMCkge1xuXHRcdFx0Ly8gXCJyZXR1cm4gdG8gY3VycmVudFwiIGR1cmF0aW9uLCBlLmcuIHdoZW4gZHJhZ2dpbmcgZnJvbSBzbGlkZSAwIHRvIC0xXG5cdFx0XHRmaW5pc2hBbmltRHVyYXRpb24gPSAzMzM7IFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmaW5pc2hBbmltRHVyYXRpb24gPSBNYXRoLmFicyhfcmVsZWFzZUFuaW1EYXRhLmxhc3RGbGlja1NwZWVkLngpID4gMCA/IFxuXHRcdFx0XHRcdFx0XHRcdFx0YW5pbWF0ZVRvRGlzdCAvIE1hdGguYWJzKF9yZWxlYXNlQW5pbURhdGEubGFzdEZsaWNrU3BlZWQueCkgOiBcblx0XHRcdFx0XHRcdFx0XHRcdDMzMztcblxuXHRcdFx0ZmluaXNoQW5pbUR1cmF0aW9uID0gTWF0aC5taW4oZmluaXNoQW5pbUR1cmF0aW9uLCA0MDApO1xuXHRcdFx0ZmluaXNoQW5pbUR1cmF0aW9uID0gTWF0aC5tYXgoZmluaXNoQW5pbUR1cmF0aW9uLCAyNTApO1xuXHRcdH1cblxuXHRcdGlmKF9jdXJyWm9vbWVkSXRlbUluZGV4ID09PSBfY3VycmVudEl0ZW1JbmRleCkge1xuXHRcdFx0aXRlbUNoYW5nZWQgPSBmYWxzZTtcblx0XHR9XG5cdFx0XG5cdFx0X21haW5TY3JvbGxBbmltYXRpbmcgPSB0cnVlO1xuXHRcdFxuXHRcdF9zaG91dCgnbWFpblNjcm9sbEFuaW1TdGFydCcpO1xuXG5cdFx0X2FuaW1hdGVQcm9wKCdtYWluU2Nyb2xsJywgX21haW5TY3JvbGxQb3MueCwgYW5pbWF0ZVRvWCwgZmluaXNoQW5pbUR1cmF0aW9uLCBmcmFtZXdvcmsuZWFzaW5nLmN1YmljLm91dCwgXG5cdFx0XHRfbW92ZU1haW5TY3JvbGwsXG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0X3N0b3BBbGxBbmltYXRpb25zKCk7XG5cdFx0XHRcdF9tYWluU2Nyb2xsQW5pbWF0aW5nID0gZmFsc2U7XG5cdFx0XHRcdF9jdXJyWm9vbWVkSXRlbUluZGV4ID0gLTE7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZihpdGVtQ2hhbmdlZCB8fCBfY3Vyclpvb21lZEl0ZW1JbmRleCAhPT0gX2N1cnJlbnRJdGVtSW5kZXgpIHtcblx0XHRcdFx0XHRzZWxmLnVwZGF0ZUN1cnJJdGVtKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdF9zaG91dCgnbWFpblNjcm9sbEFuaW1Db21wbGV0ZScpO1xuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRpZihpdGVtQ2hhbmdlZCkge1xuXHRcdFx0c2VsZi51cGRhdGVDdXJySXRlbSh0cnVlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaXRlbUNoYW5nZWQ7XG5cdH0sXG5cblx0X2NhbGN1bGF0ZVpvb21MZXZlbCA9IGZ1bmN0aW9uKHRvdWNoZXNEaXN0YW5jZSkge1xuXHRcdHJldHVybiAgMSAvIF9zdGFydFBvaW50c0Rpc3RhbmNlICogdG91Y2hlc0Rpc3RhbmNlICogX3N0YXJ0Wm9vbUxldmVsO1xuXHR9LFxuXG5cdC8vIFJlc2V0cyB6b29tIGlmIGl0J3Mgb3V0IG9mIGJvdW5kc1xuXHRfY29tcGxldGVab29tR2VzdHVyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkZXN0Wm9vbUxldmVsID0gX2N1cnJab29tTGV2ZWwsXG5cdFx0XHRtaW5ab29tTGV2ZWwgPSBfZ2V0TWluWm9vbUxldmVsKCksXG5cdFx0XHRtYXhab29tTGV2ZWwgPSBfZ2V0TWF4Wm9vbUxldmVsKCk7XG5cblx0XHRpZiAoIF9jdXJyWm9vbUxldmVsIDwgbWluWm9vbUxldmVsICkge1xuXHRcdFx0ZGVzdFpvb21MZXZlbCA9IG1pblpvb21MZXZlbDtcblx0XHR9IGVsc2UgaWYgKCBfY3Vyclpvb21MZXZlbCA+IG1heFpvb21MZXZlbCApIHtcblx0XHRcdGRlc3Rab29tTGV2ZWwgPSBtYXhab29tTGV2ZWw7XG5cdFx0fVxuXG5cdFx0dmFyIGRlc3RPcGFjaXR5ID0gMSxcblx0XHRcdG9uVXBkYXRlLFxuXHRcdFx0aW5pdGlhbE9wYWNpdHkgPSBfYmdPcGFjaXR5O1xuXG5cdFx0aWYoX29wYWNpdHlDaGFuZ2VkICYmICFfaXNab29taW5nSW4gJiYgIV93YXNPdmVySW5pdGlhbFpvb20gJiYgX2N1cnJab29tTGV2ZWwgPCBtaW5ab29tTGV2ZWwpIHtcblx0XHRcdC8vX2Nsb3NlZEJ5U2Nyb2xsID0gdHJ1ZTtcblx0XHRcdHNlbGYuY2xvc2UoKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGlmKF9vcGFjaXR5Q2hhbmdlZCkge1xuXHRcdFx0b25VcGRhdGUgPSBmdW5jdGlvbihub3cpIHtcblx0XHRcdFx0X2FwcGx5QmdPcGFjaXR5KCAgKGRlc3RPcGFjaXR5IC0gaW5pdGlhbE9wYWNpdHkpICogbm93ICsgaW5pdGlhbE9wYWNpdHkgKTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0c2VsZi56b29tVG8oZGVzdFpvb21MZXZlbCwgMCwgMjAwLCAgZnJhbWV3b3JrLmVhc2luZy5jdWJpYy5vdXQsIG9uVXBkYXRlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXG5fcmVnaXN0ZXJNb2R1bGUoJ0dlc3R1cmVzJywge1xuXHRwdWJsaWNNZXRob2RzOiB7XG5cblx0XHRpbml0R2VzdHVyZXM6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBoZWxwZXIgZnVuY3Rpb24gdGhhdCBidWlsZHMgdG91Y2gvcG9pbnRlci9tb3VzZSBldmVudHNcblx0XHRcdHZhciBhZGRFdmVudE5hbWVzID0gZnVuY3Rpb24ocHJlZiwgZG93biwgbW92ZSwgdXAsIGNhbmNlbCkge1xuXHRcdFx0XHRfZHJhZ1N0YXJ0RXZlbnQgPSBwcmVmICsgZG93bjtcblx0XHRcdFx0X2RyYWdNb3ZlRXZlbnQgPSBwcmVmICsgbW92ZTtcblx0XHRcdFx0X2RyYWdFbmRFdmVudCA9IHByZWYgKyB1cDtcblx0XHRcdFx0aWYoY2FuY2VsKSB7XG5cdFx0XHRcdFx0X2RyYWdDYW5jZWxFdmVudCA9IHByZWYgKyBjYW5jZWw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X2RyYWdDYW5jZWxFdmVudCA9ICcnO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRfcG9pbnRlckV2ZW50RW5hYmxlZCA9IF9mZWF0dXJlcy5wb2ludGVyRXZlbnQ7XG5cdFx0XHRpZihfcG9pbnRlckV2ZW50RW5hYmxlZCAmJiBfZmVhdHVyZXMudG91Y2gpIHtcblx0XHRcdFx0Ly8gd2UgZG9uJ3QgbmVlZCB0b3VjaCBldmVudHMsIGlmIGJyb3dzZXIgc3VwcG9ydHMgcG9pbnRlciBldmVudHNcblx0XHRcdFx0X2ZlYXR1cmVzLnRvdWNoID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmKF9wb2ludGVyRXZlbnRFbmFibGVkKSB7XG5cdFx0XHRcdGlmKG5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKSB7XG5cdFx0XHRcdFx0Ly8gSUUxMCBwb2ludGVyIGV2ZW50cyBhcmUgY2FzZS1zZW5zaXRpdmVcblx0XHRcdFx0XHRhZGRFdmVudE5hbWVzKCdNU1BvaW50ZXInLCAnRG93bicsICdNb3ZlJywgJ1VwJywgJ0NhbmNlbCcpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGFkZEV2ZW50TmFtZXMoJ3BvaW50ZXInLCAnZG93bicsICdtb3ZlJywgJ3VwJywgJ2NhbmNlbCcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYoX2ZlYXR1cmVzLnRvdWNoKSB7XG5cdFx0XHRcdGFkZEV2ZW50TmFtZXMoJ3RvdWNoJywgJ3N0YXJ0JywgJ21vdmUnLCAnZW5kJywgJ2NhbmNlbCcpO1xuXHRcdFx0XHRfbGlrZWx5VG91Y2hEZXZpY2UgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YWRkRXZlbnROYW1lcygnbW91c2UnLCAnZG93bicsICdtb3ZlJywgJ3VwJyk7XHRcblx0XHRcdH1cblxuXHRcdFx0X3VwTW92ZUV2ZW50cyA9IF9kcmFnTW92ZUV2ZW50ICsgJyAnICsgX2RyYWdFbmRFdmVudCAgKyAnICcgKyAgX2RyYWdDYW5jZWxFdmVudDtcblx0XHRcdF9kb3duRXZlbnRzID0gX2RyYWdTdGFydEV2ZW50O1xuXG5cdFx0XHRpZihfcG9pbnRlckV2ZW50RW5hYmxlZCAmJiAhX2xpa2VseVRvdWNoRGV2aWNlKSB7XG5cdFx0XHRcdF9saWtlbHlUb3VjaERldmljZSA9IChuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAxKSB8fCAobmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgPiAxKTtcblx0XHRcdH1cblx0XHRcdC8vIG1ha2UgdmFyaWFibGUgcHVibGljXG5cdFx0XHRzZWxmLmxpa2VseVRvdWNoRGV2aWNlID0gX2xpa2VseVRvdWNoRGV2aWNlOyBcblx0XHRcdFxuXHRcdFx0X2dsb2JhbEV2ZW50SGFuZGxlcnNbX2RyYWdTdGFydEV2ZW50XSA9IF9vbkRyYWdTdGFydDtcblx0XHRcdF9nbG9iYWxFdmVudEhhbmRsZXJzW19kcmFnTW92ZUV2ZW50XSA9IF9vbkRyYWdNb3ZlO1xuXHRcdFx0X2dsb2JhbEV2ZW50SGFuZGxlcnNbX2RyYWdFbmRFdmVudF0gPSBfb25EcmFnUmVsZWFzZTsgLy8gdGhlIEtyYWtlblxuXG5cdFx0XHRpZihfZHJhZ0NhbmNlbEV2ZW50KSB7XG5cdFx0XHRcdF9nbG9iYWxFdmVudEhhbmRsZXJzW19kcmFnQ2FuY2VsRXZlbnRdID0gX2dsb2JhbEV2ZW50SGFuZGxlcnNbX2RyYWdFbmRFdmVudF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJpbmQgbW91c2UgZXZlbnRzIG9uIGRldmljZSB3aXRoIGRldGVjdGVkIGhhcmR3YXJlIHRvdWNoIHN1cHBvcnQsIGluIGNhc2UgaXQgc3VwcG9ydHMgbXVsdGlwbGUgdHlwZXMgb2YgaW5wdXQuXG5cdFx0XHRpZihfZmVhdHVyZXMudG91Y2gpIHtcblx0XHRcdFx0X2Rvd25FdmVudHMgKz0gJyBtb3VzZWRvd24nO1xuXHRcdFx0XHRfdXBNb3ZlRXZlbnRzICs9ICcgbW91c2Vtb3ZlIG1vdXNldXAnO1xuXHRcdFx0XHRfZ2xvYmFsRXZlbnRIYW5kbGVycy5tb3VzZWRvd24gPSBfZ2xvYmFsRXZlbnRIYW5kbGVyc1tfZHJhZ1N0YXJ0RXZlbnRdO1xuXHRcdFx0XHRfZ2xvYmFsRXZlbnRIYW5kbGVycy5tb3VzZW1vdmUgPSBfZ2xvYmFsRXZlbnRIYW5kbGVyc1tfZHJhZ01vdmVFdmVudF07XG5cdFx0XHRcdF9nbG9iYWxFdmVudEhhbmRsZXJzLm1vdXNldXAgPSBfZ2xvYmFsRXZlbnRIYW5kbGVyc1tfZHJhZ0VuZEV2ZW50XTtcblx0XHRcdH1cblxuXHRcdFx0aWYoIV9saWtlbHlUb3VjaERldmljZSkge1xuXHRcdFx0XHQvLyBkb24ndCBhbGxvdyBwYW4gdG8gbmV4dCBzbGlkZSBmcm9tIHpvb21lZCBzdGF0ZSBvbiBEZXNrdG9wXG5cdFx0XHRcdF9vcHRpb25zLmFsbG93UGFuVG9OZXh0ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH1cbn0pO1xuXG5cbi8qPj5nZXN0dXJlcyovXG5cbi8qPj5zaG93LWhpZGUtdHJhbnNpdGlvbiovXG4vKipcbiAqIHNob3ctaGlkZS10cmFuc2l0aW9uLmpzOlxuICpcbiAqIE1hbmFnZXMgaW5pdGlhbCBvcGVuaW5nIG9yIGNsb3NpbmcgdHJhbnNpdGlvbi5cbiAqXG4gKiBJZiB5b3UncmUgbm90IHBsYW5uaW5nIHRvIHVzZSB0cmFuc2l0aW9uIGZvciBnYWxsZXJ5IGF0IGFsbCxcbiAqIHlvdSBtYXkgc2V0IG9wdGlvbnMgaGlkZUFuaW1hdGlvbkR1cmF0aW9uIGFuZCBzaG93QW5pbWF0aW9uRHVyYXRpb24gdG8gMCxcbiAqIGFuZCBqdXN0IGRlbGV0ZSBzdGFydEFuaW1hdGlvbiBmdW5jdGlvbi5cbiAqIFxuICovXG5cblxudmFyIF9zaG93T3JIaWRlVGltZW91dCxcblx0X3Nob3dPckhpZGUgPSBmdW5jdGlvbihpdGVtLCBpbWcsIG91dCwgY29tcGxldGVGbikge1xuXG5cdFx0aWYoX3Nob3dPckhpZGVUaW1lb3V0KSB7XG5cdFx0XHRjbGVhclRpbWVvdXQoX3Nob3dPckhpZGVUaW1lb3V0KTtcblx0XHR9XG5cblx0XHRfaW5pdGlhbFpvb21SdW5uaW5nID0gdHJ1ZTtcblx0XHRfaW5pdGlhbENvbnRlbnRTZXQgPSB0cnVlO1xuXHRcdFxuXHRcdC8vIGRpbWVuc2lvbnMgb2Ygc21hbGwgdGh1bWJuYWlsIHt4Oix5Oix3On0uXG5cdFx0Ly8gSGVpZ2h0IGlzIG9wdGlvbmFsLCBhcyBjYWxjdWxhdGVkIGJhc2VkIG9uIGxhcmdlIGltYWdlLlxuXHRcdHZhciB0aHVtYkJvdW5kczsgXG5cdFx0aWYoaXRlbS5pbml0aWFsTGF5b3V0KSB7XG5cdFx0XHR0aHVtYkJvdW5kcyA9IGl0ZW0uaW5pdGlhbExheW91dDtcblx0XHRcdGl0ZW0uaW5pdGlhbExheW91dCA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRodW1iQm91bmRzID0gX29wdGlvbnMuZ2V0VGh1bWJCb3VuZHNGbiAmJiBfb3B0aW9ucy5nZXRUaHVtYkJvdW5kc0ZuKF9jdXJyZW50SXRlbUluZGV4KTtcblx0XHR9XG5cblx0XHR2YXIgZHVyYXRpb24gPSBvdXQgPyBfb3B0aW9ucy5oaWRlQW5pbWF0aW9uRHVyYXRpb24gOiBfb3B0aW9ucy5zaG93QW5pbWF0aW9uRHVyYXRpb247XG5cblx0XHR2YXIgb25Db21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0X3N0b3BBbmltYXRpb24oJ2luaXRpYWxab29tJyk7XG5cdFx0XHRpZighb3V0KSB7XG5cdFx0XHRcdF9hcHBseUJnT3BhY2l0eSgxKTtcblx0XHRcdFx0aWYoaW1nKSB7XG5cdFx0XHRcdFx0aW1nLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZyYW1ld29yay5hZGRDbGFzcyh0ZW1wbGF0ZSwgJ3Bzd3AtLWFuaW1hdGVkLWluJyk7XG5cdFx0XHRcdF9zaG91dCgnaW5pdGlhbFpvb20nICsgKG91dCA/ICdPdXRFbmQnIDogJ0luRW5kJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi50ZW1wbGF0ZS5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG5cdFx0XHRcdHNlbGYuYmcucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihjb21wbGV0ZUZuKSB7XG5cdFx0XHRcdGNvbXBsZXRlRm4oKTtcblx0XHRcdH1cblx0XHRcdF9pbml0aWFsWm9vbVJ1bm5pbmcgPSBmYWxzZTtcblx0XHR9O1xuXG5cdFx0Ly8gaWYgYm91bmRzIGFyZW4ndCBwcm92aWRlZCwganVzdCBvcGVuIGdhbGxlcnkgd2l0aG91dCBhbmltYXRpb25cblx0XHRpZighZHVyYXRpb24gfHwgIXRodW1iQm91bmRzIHx8IHRodW1iQm91bmRzLnggPT09IHVuZGVmaW5lZCkge1xuXG5cdFx0XHRfc2hvdXQoJ2luaXRpYWxab29tJyArIChvdXQgPyAnT3V0JyA6ICdJbicpICk7XG5cblx0XHRcdF9jdXJyWm9vbUxldmVsID0gaXRlbS5pbml0aWFsWm9vbUxldmVsO1xuXHRcdFx0X2VxdWFsaXplUG9pbnRzKF9wYW5PZmZzZXQsICBpdGVtLmluaXRpYWxQb3NpdGlvbiApO1xuXHRcdFx0X2FwcGx5Q3VycmVudFpvb21QYW4oKTtcblxuXHRcdFx0dGVtcGxhdGUuc3R5bGUub3BhY2l0eSA9IG91dCA/IDAgOiAxO1xuXHRcdFx0X2FwcGx5QmdPcGFjaXR5KDEpO1xuXG5cdFx0XHRpZihkdXJhdGlvbikge1xuXHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdG9uQ29tcGxldGUoKTtcblx0XHRcdFx0fSwgZHVyYXRpb24pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b25Db21wbGV0ZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHN0YXJ0QW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2xvc2VXaXRoUmFmID0gX2Nsb3NlZEJ5U2Nyb2xsLFxuXHRcdFx0XHRmYWRlRXZlcnl0aGluZyA9ICFzZWxmLmN1cnJJdGVtLnNyYyB8fCBzZWxmLmN1cnJJdGVtLmxvYWRFcnJvciB8fCBfb3B0aW9ucy5zaG93SGlkZU9wYWNpdHk7XG5cdFx0XHRcblx0XHRcdC8vIGFwcGx5IGh3LWFjY2VsZXJhdGlvbiB0byBpbWFnZVxuXHRcdFx0aWYoaXRlbS5taW5pSW1nKSB7XG5cdFx0XHRcdGl0ZW0ubWluaUltZy5zdHlsZS53ZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgPSAnaGlkZGVuJztcblx0XHRcdH1cblxuXHRcdFx0aWYoIW91dCkge1xuXHRcdFx0XHRfY3Vyclpvb21MZXZlbCA9IHRodW1iQm91bmRzLncgLyBpdGVtLnc7XG5cdFx0XHRcdF9wYW5PZmZzZXQueCA9IHRodW1iQm91bmRzLng7XG5cdFx0XHRcdF9wYW5PZmZzZXQueSA9IHRodW1iQm91bmRzLnkgLSBfaW5pdGFsV2luZG93U2Nyb2xsWTtcblxuXHRcdFx0XHRzZWxmW2ZhZGVFdmVyeXRoaW5nID8gJ3RlbXBsYXRlJyA6ICdiZyddLnN0eWxlLm9wYWNpdHkgPSAwLjAwMTtcblx0XHRcdFx0X2FwcGx5Q3VycmVudFpvb21QYW4oKTtcblx0XHRcdH1cblxuXHRcdFx0X3JlZ2lzdGVyU3RhcnRBbmltYXRpb24oJ2luaXRpYWxab29tJyk7XG5cdFx0XHRcblx0XHRcdGlmKG91dCAmJiAhY2xvc2VXaXRoUmFmKSB7XG5cdFx0XHRcdGZyYW1ld29yay5yZW1vdmVDbGFzcyh0ZW1wbGF0ZSwgJ3Bzd3AtLWFuaW1hdGVkLWluJyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKGZhZGVFdmVyeXRoaW5nKSB7XG5cdFx0XHRcdGlmKG91dCkge1xuXHRcdFx0XHRcdGZyYW1ld29ya1sgKGNsb3NlV2l0aFJhZiA/ICdyZW1vdmUnIDogJ2FkZCcpICsgJ0NsYXNzJyBdKHRlbXBsYXRlLCAncHN3cC0tYW5pbWF0ZV9vcGFjaXR5Jyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGZyYW1ld29yay5hZGRDbGFzcyh0ZW1wbGF0ZSwgJ3Bzd3AtLWFuaW1hdGVfb3BhY2l0eScpO1xuXHRcdFx0XHRcdH0sIDMwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRfc2hvd09ySGlkZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdF9zaG91dCgnaW5pdGlhbFpvb20nICsgKG91dCA/ICdPdXQnIDogJ0luJykgKTtcblx0XHRcdFx0XG5cblx0XHRcdFx0aWYoIW91dCkge1xuXG5cdFx0XHRcdFx0Ly8gXCJpblwiIGFuaW1hdGlvbiBhbHdheXMgdXNlcyBDU1MgdHJhbnNpdGlvbnMgKGluc3RlYWQgb2YgckFGKS5cblx0XHRcdFx0XHQvLyBDU1MgdHJhbnNpdGlvbiB3b3JrIGZhc3RlciBoZXJlLCBcblx0XHRcdFx0XHQvLyBhcyBkZXZlbG9wZXIgbWF5IGFsc28gd2FudCB0byBhbmltYXRlIG90aGVyIHRoaW5ncywgXG5cdFx0XHRcdFx0Ly8gbGlrZSB1aSBvbiB0b3Agb2Ygc2xpZGluZyBhcmVhLCB3aGljaCBjYW4gYmUgYW5pbWF0ZWQganVzdCB2aWEgQ1NTXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0X2N1cnJab29tTGV2ZWwgPSBpdGVtLmluaXRpYWxab29tTGV2ZWw7XG5cdFx0XHRcdFx0X2VxdWFsaXplUG9pbnRzKF9wYW5PZmZzZXQsICBpdGVtLmluaXRpYWxQb3NpdGlvbiApO1xuXHRcdFx0XHRcdF9hcHBseUN1cnJlbnRab29tUGFuKCk7XG5cdFx0XHRcdFx0X2FwcGx5QmdPcGFjaXR5KDEpO1xuXG5cdFx0XHRcdFx0aWYoZmFkZUV2ZXJ5dGhpbmcpIHtcblx0XHRcdFx0XHRcdHRlbXBsYXRlLnN0eWxlLm9wYWNpdHkgPSAxO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRfYXBwbHlCZ09wYWNpdHkoMSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0X3Nob3dPckhpZGVUaW1lb3V0ID0gc2V0VGltZW91dChvbkNvbXBsZXRlLCBkdXJhdGlvbiArIDIwKTtcblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIFwib3V0XCIgYW5pbWF0aW9uIHVzZXMgckFGIG9ubHkgd2hlbiBQaG90b1N3aXBlIGlzIGNsb3NlZCBieSBicm93c2VyIHNjcm9sbCwgdG8gcmVjYWxjdWxhdGUgcG9zaXRpb25cblx0XHRcdFx0XHR2YXIgZGVzdFpvb21MZXZlbCA9IHRodW1iQm91bmRzLncgLyBpdGVtLncsXG5cdFx0XHRcdFx0XHRpbml0aWFsUGFuT2Zmc2V0ID0ge1xuXHRcdFx0XHRcdFx0XHR4OiBfcGFuT2Zmc2V0LngsXG5cdFx0XHRcdFx0XHRcdHk6IF9wYW5PZmZzZXQueVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGluaXRpYWxab29tTGV2ZWwgPSBfY3Vyclpvb21MZXZlbCxcblx0XHRcdFx0XHRcdGluaXRhbEJnT3BhY2l0eSA9IF9iZ09wYWNpdHksXG5cdFx0XHRcdFx0XHRvblVwZGF0ZSA9IGZ1bmN0aW9uKG5vdykge1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0aWYobm93ID09PSAxKSB7XG5cdFx0XHRcdFx0XHRcdFx0X2N1cnJab29tTGV2ZWwgPSBkZXN0Wm9vbUxldmVsO1xuXHRcdFx0XHRcdFx0XHRcdF9wYW5PZmZzZXQueCA9IHRodW1iQm91bmRzLng7XG5cdFx0XHRcdFx0XHRcdFx0X3Bhbk9mZnNldC55ID0gdGh1bWJCb3VuZHMueSAgLSBfY3VycmVudFdpbmRvd1Njcm9sbFk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0X2N1cnJab29tTGV2ZWwgPSAoZGVzdFpvb21MZXZlbCAtIGluaXRpYWxab29tTGV2ZWwpICogbm93ICsgaW5pdGlhbFpvb21MZXZlbDtcblx0XHRcdFx0XHRcdFx0XHRfcGFuT2Zmc2V0LnggPSAodGh1bWJCb3VuZHMueCAtIGluaXRpYWxQYW5PZmZzZXQueCkgKiBub3cgKyBpbml0aWFsUGFuT2Zmc2V0Lng7XG5cdFx0XHRcdFx0XHRcdFx0X3Bhbk9mZnNldC55ID0gKHRodW1iQm91bmRzLnkgLSBfY3VycmVudFdpbmRvd1Njcm9sbFkgLSBpbml0aWFsUGFuT2Zmc2V0LnkpICogbm93ICsgaW5pdGlhbFBhbk9mZnNldC55O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRfYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xuXHRcdFx0XHRcdFx0XHRpZihmYWRlRXZlcnl0aGluZykge1xuXHRcdFx0XHRcdFx0XHRcdHRlbXBsYXRlLnN0eWxlLm9wYWNpdHkgPSAxIC0gbm93O1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdF9hcHBseUJnT3BhY2l0eSggaW5pdGFsQmdPcGFjaXR5IC0gbm93ICogaW5pdGFsQmdPcGFjaXR5ICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRpZihjbG9zZVdpdGhSYWYpIHtcblx0XHRcdFx0XHRcdF9hbmltYXRlUHJvcCgnaW5pdGlhbFpvb20nLCAwLCAxLCBkdXJhdGlvbiwgZnJhbWV3b3JrLmVhc2luZy5jdWJpYy5vdXQsIG9uVXBkYXRlLCBvbkNvbXBsZXRlKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0b25VcGRhdGUoMSk7XG5cdFx0XHRcdFx0XHRfc2hvd09ySGlkZVRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uQ29tcGxldGUsIGR1cmF0aW9uICsgMjApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR9LCBvdXQgPyAyNSA6IDkwKTsgLy8gTWFpbiBwdXJwb3NlIG9mIHRoaXMgZGVsYXkgaXMgdG8gZ2l2ZSBicm93c2VyIHRpbWUgdG8gcGFpbnQgYW5kXG5cdFx0XHRcdFx0Ly8gY3JlYXRlIGNvbXBvc2l0ZSBsYXllcnMgb2YgUGhvdG9Td2lwZSBVSSBwYXJ0cyAoYmFja2dyb3VuZCwgY29udHJvbHMsIGNhcHRpb24sIGFycm93cykuXG5cdFx0XHRcdFx0Ly8gV2hpY2ggYXZvaWRzIGxhZyBhdCB0aGUgYmVnaW5uaW5nIG9mIHNjYWxlIHRyYW5zaXRpb24uXG5cdFx0fTtcblx0XHRzdGFydEFuaW1hdGlvbigpO1xuXG5cdFx0XG5cdH07XG5cbi8qPj5zaG93LWhpZGUtdHJhbnNpdGlvbiovXG5cbi8qPj5pdGVtcy1jb250cm9sbGVyKi9cbi8qKlxuKlxuKiBDb250cm9sbGVyIG1hbmFnZXMgZ2FsbGVyeSBpdGVtcywgdGhlaXIgZGltZW5zaW9ucywgYW5kIHRoZWlyIGNvbnRlbnQuXG4qIFxuKi9cblxudmFyIF9pdGVtcyxcblx0X3RlbXBQYW5BcmVhU2l6ZSA9IHt9LFxuXHRfaW1hZ2VzVG9BcHBlbmRQb29sID0gW10sXG5cdF9pbml0aWFsQ29udGVudFNldCxcblx0X2luaXRpYWxab29tUnVubmluZyxcblx0X2NvbnRyb2xsZXJEZWZhdWx0T3B0aW9ucyA9IHtcblx0XHRpbmRleDogMCxcblx0XHRlcnJvck1zZzogJzxkaXYgY2xhc3M9XCJwc3dwX19lcnJvci1tc2dcIj48YSBocmVmPVwiJXVybCVcIiB0YXJnZXQ9XCJfYmxhbmtcIj5UaGUgaW1hZ2U8L2E+IGNvdWxkIG5vdCBiZSBsb2FkZWQuPC9kaXY+Jyxcblx0XHRmb3JjZVByb2dyZXNzaXZlTG9hZGluZzogZmFsc2UsIC8vIFRPRE9cblx0XHRwcmVsb2FkOiBbMSwxXSxcblx0XHRnZXROdW1JdGVtc0ZuOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBfaXRlbXMubGVuZ3RoO1xuXHRcdH1cblx0fTtcblxuXG52YXIgX2dldEl0ZW1BdCxcblx0X2dldE51bUl0ZW1zLFxuXHRfaW5pdGlhbElzTG9vcCxcblx0X2dldFplcm9Cb3VuZHMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0Y2VudGVyOnt4OjAseTowfSwgXG5cdFx0XHRtYXg6e3g6MCx5OjB9LCBcblx0XHRcdG1pbjp7eDowLHk6MH1cblx0XHR9O1xuXHR9LFxuXHRfY2FsY3VsYXRlU2luZ2xlSXRlbVBhbkJvdW5kcyA9IGZ1bmN0aW9uKGl0ZW0sIHJlYWxQYW5FbGVtZW50VywgcmVhbFBhbkVsZW1lbnRIICkge1xuXHRcdHZhciBib3VuZHMgPSBpdGVtLmJvdW5kcztcblxuXHRcdC8vIHBvc2l0aW9uIG9mIGVsZW1lbnQgd2hlbiBpdCdzIGNlbnRlcmVkXG5cdFx0Ym91bmRzLmNlbnRlci54ID0gTWF0aC5yb3VuZCgoX3RlbXBQYW5BcmVhU2l6ZS54IC0gcmVhbFBhbkVsZW1lbnRXKSAvIDIpO1xuXHRcdGJvdW5kcy5jZW50ZXIueSA9IE1hdGgucm91bmQoKF90ZW1wUGFuQXJlYVNpemUueSAtIHJlYWxQYW5FbGVtZW50SCkgLyAyKSArIGl0ZW0udkdhcC50b3A7XG5cblx0XHQvLyBtYXhpbXVtIHBhbiBwb3NpdGlvblxuXHRcdGJvdW5kcy5tYXgueCA9IChyZWFsUGFuRWxlbWVudFcgPiBfdGVtcFBhbkFyZWFTaXplLngpID8gXG5cdFx0XHRcdFx0XHRcdE1hdGgucm91bmQoX3RlbXBQYW5BcmVhU2l6ZS54IC0gcmVhbFBhbkVsZW1lbnRXKSA6IFxuXHRcdFx0XHRcdFx0XHRib3VuZHMuY2VudGVyLng7XG5cdFx0XG5cdFx0Ym91bmRzLm1heC55ID0gKHJlYWxQYW5FbGVtZW50SCA+IF90ZW1wUGFuQXJlYVNpemUueSkgPyBcblx0XHRcdFx0XHRcdFx0TWF0aC5yb3VuZChfdGVtcFBhbkFyZWFTaXplLnkgLSByZWFsUGFuRWxlbWVudEgpICsgaXRlbS52R2FwLnRvcCA6IFxuXHRcdFx0XHRcdFx0XHRib3VuZHMuY2VudGVyLnk7XG5cdFx0XG5cdFx0Ly8gbWluaW11bSBwYW4gcG9zaXRpb25cblx0XHRib3VuZHMubWluLnggPSAocmVhbFBhbkVsZW1lbnRXID4gX3RlbXBQYW5BcmVhU2l6ZS54KSA/IDAgOiBib3VuZHMuY2VudGVyLng7XG5cdFx0Ym91bmRzLm1pbi55ID0gKHJlYWxQYW5FbGVtZW50SCA+IF90ZW1wUGFuQXJlYVNpemUueSkgPyBpdGVtLnZHYXAudG9wIDogYm91bmRzLmNlbnRlci55O1xuXHR9LFxuXHRfY2FsY3VsYXRlSXRlbVNpemUgPSBmdW5jdGlvbihpdGVtLCB2aWV3cG9ydFNpemUsIHpvb21MZXZlbCkge1xuXG5cdFx0aWYgKGl0ZW0uc3JjICYmICFpdGVtLmxvYWRFcnJvcikge1xuXHRcdFx0dmFyIGlzSW5pdGlhbCA9ICF6b29tTGV2ZWw7XG5cdFx0XHRcblx0XHRcdGlmKGlzSW5pdGlhbCkge1xuXHRcdFx0XHRpZighaXRlbS52R2FwKSB7XG5cdFx0XHRcdFx0aXRlbS52R2FwID0ge3RvcDowLGJvdHRvbTowfTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBhbGxvd3Mgb3ZlcnJpZGluZyB2ZXJ0aWNhbCBtYXJnaW4gZm9yIGluZGl2aWR1YWwgaXRlbXNcblx0XHRcdFx0X3Nob3V0KCdwYXJzZVZlcnRpY2FsTWFyZ2luJywgaXRlbSk7XG5cdFx0XHR9XG5cblxuXHRcdFx0X3RlbXBQYW5BcmVhU2l6ZS54ID0gdmlld3BvcnRTaXplLng7XG5cdFx0XHRfdGVtcFBhbkFyZWFTaXplLnkgPSB2aWV3cG9ydFNpemUueSAtIGl0ZW0udkdhcC50b3AgLSBpdGVtLnZHYXAuYm90dG9tO1xuXG5cdFx0XHRpZiAoaXNJbml0aWFsKSB7XG5cdFx0XHRcdHZhciBoUmF0aW8gPSBfdGVtcFBhbkFyZWFTaXplLnggLyBpdGVtLnc7XG5cdFx0XHRcdHZhciB2UmF0aW8gPSBfdGVtcFBhbkFyZWFTaXplLnkgLyBpdGVtLmg7XG5cblx0XHRcdFx0aXRlbS5maXRSYXRpbyA9IGhSYXRpbyA8IHZSYXRpbyA/IGhSYXRpbyA6IHZSYXRpbztcblx0XHRcdFx0Ly9pdGVtLmZpbGxSYXRpbyA9IGhSYXRpbyA+IHZSYXRpbyA/IGhSYXRpbyA6IHZSYXRpbztcblxuXHRcdFx0XHR2YXIgc2NhbGVNb2RlID0gX29wdGlvbnMuc2NhbGVNb2RlO1xuXG5cdFx0XHRcdGlmIChzY2FsZU1vZGUgPT09ICdvcmlnJykge1xuXHRcdFx0XHRcdHpvb21MZXZlbCA9IDE7XG5cdFx0XHRcdH0gZWxzZSBpZiAoc2NhbGVNb2RlID09PSAnZml0Jykge1xuXHRcdFx0XHRcdHpvb21MZXZlbCA9IGl0ZW0uZml0UmF0aW87XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoem9vbUxldmVsID4gMSkge1xuXHRcdFx0XHRcdHpvb21MZXZlbCA9IDE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpdGVtLmluaXRpYWxab29tTGV2ZWwgPSB6b29tTGV2ZWw7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZighaXRlbS5ib3VuZHMpIHtcblx0XHRcdFx0XHQvLyByZXVzZSBib3VuZHMgb2JqZWN0XG5cdFx0XHRcdFx0aXRlbS5ib3VuZHMgPSBfZ2V0WmVyb0JvdW5kcygpOyBcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZighem9vbUxldmVsKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0X2NhbGN1bGF0ZVNpbmdsZUl0ZW1QYW5Cb3VuZHMoaXRlbSwgaXRlbS53ICogem9vbUxldmVsLCBpdGVtLmggKiB6b29tTGV2ZWwpO1xuXG5cdFx0XHRpZiAoaXNJbml0aWFsICYmIHpvb21MZXZlbCA9PT0gaXRlbS5pbml0aWFsWm9vbUxldmVsKSB7XG5cdFx0XHRcdGl0ZW0uaW5pdGlhbFBvc2l0aW9uID0gaXRlbS5ib3VuZHMuY2VudGVyO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaXRlbS5ib3VuZHM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGl0ZW0udyA9IGl0ZW0uaCA9IDA7XG5cdFx0XHRpdGVtLmluaXRpYWxab29tTGV2ZWwgPSBpdGVtLmZpdFJhdGlvID0gMTtcblx0XHRcdGl0ZW0uYm91bmRzID0gX2dldFplcm9Cb3VuZHMoKTtcblx0XHRcdGl0ZW0uaW5pdGlhbFBvc2l0aW9uID0gaXRlbS5ib3VuZHMuY2VudGVyO1xuXG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBpbWFnZSwgd2UgcmV0dXJuIHplcm8gYm91bmRzIChjb250ZW50IGlzIG5vdCB6b29tYWJsZSlcblx0XHRcdHJldHVybiBpdGVtLmJvdW5kcztcblx0XHR9XG5cdFx0XG5cdH0sXG5cblx0XG5cblxuXHRfYXBwZW5kSW1hZ2UgPSBmdW5jdGlvbihpbmRleCwgaXRlbSwgYmFzZURpdiwgaW1nLCBwcmV2ZW50QW5pbWF0aW9uLCBrZWVwUGxhY2Vob2xkZXIpIHtcblx0XHRcblxuXHRcdGlmKGl0ZW0ubG9hZEVycm9yKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYoaW1nKSB7XG5cblx0XHRcdGl0ZW0uaW1hZ2VBcHBlbmRlZCA9IHRydWU7XG5cdFx0XHRfc2V0SW1hZ2VTaXplKGl0ZW0sIGltZywgKGl0ZW0gPT09IHNlbGYuY3Vyckl0ZW0gJiYgX3JlbmRlck1heFJlc29sdXRpb24pICk7XG5cdFx0XHRcblx0XHRcdGJhc2VEaXYuYXBwZW5kQ2hpbGQoaW1nKTtcblxuXHRcdFx0aWYoa2VlcFBsYWNlaG9sZGVyKSB7XG5cdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYoaXRlbSAmJiBpdGVtLmxvYWRlZCAmJiBpdGVtLnBsYWNlaG9sZGVyKSB7XG5cdFx0XHRcdFx0XHRpdGVtLnBsYWNlaG9sZGVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0XHRcdFx0XHRpdGVtLnBsYWNlaG9sZGVyID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIDUwMCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRcblxuXG5cdF9wcmVsb2FkSW1hZ2UgPSBmdW5jdGlvbihpdGVtKSB7XG5cdFx0aXRlbS5sb2FkaW5nID0gdHJ1ZTtcblx0XHRpdGVtLmxvYWRlZCA9IGZhbHNlO1xuXHRcdHZhciBpbWcgPSBpdGVtLmltZyA9IGZyYW1ld29yay5jcmVhdGVFbCgncHN3cF9faW1nJywgJ2ltZycpO1xuXHRcdHZhciBvbkNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpdGVtLmxvYWRpbmcgPSBmYWxzZTtcblx0XHRcdGl0ZW0ubG9hZGVkID0gdHJ1ZTtcblxuXHRcdFx0aWYoaXRlbS5sb2FkQ29tcGxldGUpIHtcblx0XHRcdFx0aXRlbS5sb2FkQ29tcGxldGUoaXRlbSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpdGVtLmltZyA9IG51bGw7IC8vIG5vIG5lZWQgdG8gc3RvcmUgaW1hZ2Ugb2JqZWN0XG5cdFx0XHR9XG5cdFx0XHRpbWcub25sb2FkID0gaW1nLm9uZXJyb3IgPSBudWxsO1xuXHRcdFx0aW1nID0gbnVsbDtcblx0XHR9O1xuXHRcdGltZy5vbmxvYWQgPSBvbkNvbXBsZXRlO1xuXHRcdGltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpdGVtLmxvYWRFcnJvciA9IHRydWU7XG5cdFx0XHRvbkNvbXBsZXRlKCk7XG5cdFx0fTtcdFx0XG5cblx0XHRpbWcuc3JjID0gaXRlbS5zcmM7Ly8gKyAnP2E9JyArIE1hdGgucmFuZG9tKCk7XG5cblx0XHRyZXR1cm4gaW1nO1xuXHR9LFxuXHRfY2hlY2tGb3JFcnJvciA9IGZ1bmN0aW9uKGl0ZW0sIGNsZWFuVXApIHtcblx0XHRpZihpdGVtLnNyYyAmJiBpdGVtLmxvYWRFcnJvciAmJiBpdGVtLmNvbnRhaW5lcikge1xuXG5cdFx0XHRpZihjbGVhblVwKSB7XG5cdFx0XHRcdGl0ZW0uY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuXHRcdFx0fVxuXG5cdFx0XHRpdGVtLmNvbnRhaW5lci5pbm5lckhUTUwgPSBfb3B0aW9ucy5lcnJvck1zZy5yZXBsYWNlKCcldXJsJScsICBpdGVtLnNyYyApO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcblx0XHR9XG5cdH0sXG5cdF9zZXRJbWFnZVNpemUgPSBmdW5jdGlvbihpdGVtLCBpbWcsIG1heFJlcykge1xuXHRcdGlmKCFpdGVtLnNyYykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKCFpbWcpIHtcblx0XHRcdGltZyA9IGl0ZW0uY29udGFpbmVyLmxhc3RDaGlsZDtcblx0XHR9XG5cblx0XHR2YXIgdyA9IG1heFJlcyA/IGl0ZW0udyA6IE1hdGgucm91bmQoaXRlbS53ICogaXRlbS5maXRSYXRpbyksXG5cdFx0XHRoID0gbWF4UmVzID8gaXRlbS5oIDogTWF0aC5yb3VuZChpdGVtLmggKiBpdGVtLmZpdFJhdGlvKTtcblx0XHRcblx0XHRpZihpdGVtLnBsYWNlaG9sZGVyICYmICFpdGVtLmxvYWRlZCkge1xuXHRcdFx0aXRlbS5wbGFjZWhvbGRlci5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuXHRcdFx0aXRlbS5wbGFjZWhvbGRlci5zdHlsZS5oZWlnaHQgPSBoICsgJ3B4Jztcblx0XHR9XG5cblx0XHRpbWcuc3R5bGUud2lkdGggPSB3ICsgJ3B4Jztcblx0XHRpbWcuc3R5bGUuaGVpZ2h0ID0gaCArICdweCc7XG5cdH0sXG5cdF9hcHBlbmRJbWFnZXNQb29sID0gZnVuY3Rpb24oKSB7XG5cblx0XHRpZihfaW1hZ2VzVG9BcHBlbmRQb29sLmxlbmd0aCkge1xuXHRcdFx0dmFyIHBvb2xJdGVtO1xuXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgX2ltYWdlc1RvQXBwZW5kUG9vbC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRwb29sSXRlbSA9IF9pbWFnZXNUb0FwcGVuZFBvb2xbaV07XG5cdFx0XHRcdGlmKCBwb29sSXRlbS5ob2xkZXIuaW5kZXggPT09IHBvb2xJdGVtLmluZGV4ICkge1xuXHRcdFx0XHRcdF9hcHBlbmRJbWFnZShwb29sSXRlbS5pbmRleCwgcG9vbEl0ZW0uaXRlbSwgcG9vbEl0ZW0uYmFzZURpdiwgcG9vbEl0ZW0uaW1nLCBmYWxzZSwgcG9vbEl0ZW0uY2xlYXJQbGFjZWhvbGRlcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdF9pbWFnZXNUb0FwcGVuZFBvb2wgPSBbXTtcblx0XHR9XG5cdH07XG5cdFxuXG5cbl9yZWdpc3Rlck1vZHVsZSgnQ29udHJvbGxlcicsIHtcblxuXHRwdWJsaWNNZXRob2RzOiB7XG5cblx0XHRsYXp5TG9hZEl0ZW06IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0XHRpbmRleCA9IF9nZXRMb29wZWRJZChpbmRleCk7XG5cdFx0XHR2YXIgaXRlbSA9IF9nZXRJdGVtQXQoaW5kZXgpO1xuXG5cdFx0XHRpZighaXRlbSB8fCAoKGl0ZW0ubG9hZGVkIHx8IGl0ZW0ubG9hZGluZykgJiYgIV9pdGVtc05lZWRVcGRhdGUpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0X3Nob3V0KCdnZXR0aW5nRGF0YScsIGluZGV4LCBpdGVtKTtcblxuXHRcdFx0aWYgKCFpdGVtLnNyYykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdF9wcmVsb2FkSW1hZ2UoaXRlbSk7XG5cdFx0fSxcblx0XHRpbml0Q29udHJvbGxlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRmcmFtZXdvcmsuZXh0ZW5kKF9vcHRpb25zLCBfY29udHJvbGxlckRlZmF1bHRPcHRpb25zLCB0cnVlKTtcblx0XHRcdHNlbGYuaXRlbXMgPSBfaXRlbXMgPSBpdGVtcztcblx0XHRcdF9nZXRJdGVtQXQgPSBzZWxmLmdldEl0ZW1BdDtcblx0XHRcdF9nZXROdW1JdGVtcyA9IF9vcHRpb25zLmdldE51bUl0ZW1zRm47IC8vc2VsZi5nZXROdW1JdGVtcztcblxuXG5cblx0XHRcdF9pbml0aWFsSXNMb29wID0gX29wdGlvbnMubG9vcDtcblx0XHRcdGlmKF9nZXROdW1JdGVtcygpIDwgMykge1xuXHRcdFx0XHRfb3B0aW9ucy5sb29wID0gZmFsc2U7IC8vIGRpc2FibGUgbG9vcCBpZiBsZXNzIHRoZW4gMyBpdGVtc1xuXHRcdFx0fVxuXG5cdFx0XHRfbGlzdGVuKCdiZWZvcmVDaGFuZ2UnLCBmdW5jdGlvbihkaWZmKSB7XG5cblx0XHRcdFx0dmFyIHAgPSBfb3B0aW9ucy5wcmVsb2FkLFxuXHRcdFx0XHRcdGlzTmV4dCA9IGRpZmYgPT09IG51bGwgPyB0cnVlIDogKGRpZmYgPj0gMCksXG5cdFx0XHRcdFx0cHJlbG9hZEJlZm9yZSA9IE1hdGgubWluKHBbMF0sIF9nZXROdW1JdGVtcygpICksXG5cdFx0XHRcdFx0cHJlbG9hZEFmdGVyID0gTWF0aC5taW4ocFsxXSwgX2dldE51bUl0ZW1zKCkgKSxcblx0XHRcdFx0XHRpO1xuXG5cblx0XHRcdFx0Zm9yKGkgPSAxOyBpIDw9IChpc05leHQgPyBwcmVsb2FkQWZ0ZXIgOiBwcmVsb2FkQmVmb3JlKTsgaSsrKSB7XG5cdFx0XHRcdFx0c2VsZi5sYXp5TG9hZEl0ZW0oX2N1cnJlbnRJdGVtSW5kZXgraSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yKGkgPSAxOyBpIDw9IChpc05leHQgPyBwcmVsb2FkQmVmb3JlIDogcHJlbG9hZEFmdGVyKTsgaSsrKSB7XG5cdFx0XHRcdFx0c2VsZi5sYXp5TG9hZEl0ZW0oX2N1cnJlbnRJdGVtSW5kZXgtaSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRfbGlzdGVuKCdpbml0aWFsTGF5b3V0JywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuY3Vyckl0ZW0uaW5pdGlhbExheW91dCA9IF9vcHRpb25zLmdldFRodW1iQm91bmRzRm4gJiYgX29wdGlvbnMuZ2V0VGh1bWJCb3VuZHNGbihfY3VycmVudEl0ZW1JbmRleCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0X2xpc3RlbignbWFpblNjcm9sbEFuaW1Db21wbGV0ZScsIF9hcHBlbmRJbWFnZXNQb29sKTtcblx0XHRcdF9saXN0ZW4oJ2luaXRpYWxab29tSW5FbmQnLCBfYXBwZW5kSW1hZ2VzUG9vbCk7XG5cblxuXG5cdFx0XHRfbGlzdGVuKCdkZXN0cm95JywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpdGVtO1xuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgX2l0ZW1zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aXRlbSA9IF9pdGVtc1tpXTtcblx0XHRcdFx0XHQvLyByZW1vdmUgcmVmZXJlbmNlIHRvIERPTSBlbGVtZW50cywgZm9yIEdDXG5cdFx0XHRcdFx0aWYoaXRlbS5jb250YWluZXIpIHtcblx0XHRcdFx0XHRcdGl0ZW0uY29udGFpbmVyID0gbnVsbDsgXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKGl0ZW0ucGxhY2Vob2xkZXIpIHtcblx0XHRcdFx0XHRcdGl0ZW0ucGxhY2Vob2xkZXIgPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihpdGVtLmltZykge1xuXHRcdFx0XHRcdFx0aXRlbS5pbWcgPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihpdGVtLnByZWxvYWRlcikge1xuXHRcdFx0XHRcdFx0aXRlbS5wcmVsb2FkZXIgPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihpdGVtLmxvYWRFcnJvcikge1xuXHRcdFx0XHRcdFx0aXRlbS5sb2FkZWQgPSBpdGVtLmxvYWRFcnJvciA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRfaW1hZ2VzVG9BcHBlbmRQb29sID0gbnVsbDtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblxuXHRcdGdldEl0ZW1BdDogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRcdGlmIChpbmRleCA+PSAwKSB7XG5cdFx0XHRcdHJldHVybiBfaXRlbXNbaW5kZXhdICE9PSB1bmRlZmluZWQgPyBfaXRlbXNbaW5kZXhdIDogZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblxuXHRcdGFsbG93UHJvZ3Jlc3NpdmVJbWc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gMS4gUHJvZ3Jlc3NpdmUgaW1hZ2UgbG9hZGluZyBpc24ndCB3b3JraW5nIG9uIHdlYmtpdC9ibGluayBcblx0XHRcdC8vICAgIHdoZW4gaHctYWNjZWxlcmF0aW9uIChlLmcuIHRyYW5zbGF0ZVopIGlzIGFwcGxpZWQgdG8gSU1HIGVsZW1lbnQuXG5cdFx0XHQvLyAgICBUaGF0J3Mgd2h5IGluIFBob3RvU3dpcGUgcGFyZW50IGVsZW1lbnQgZ2V0cyB6b29tIHRyYW5zZm9ybSwgbm90IGltYWdlIGl0c2VsZi5cblx0XHRcdC8vICAgIFxuXHRcdFx0Ly8gMi4gUHJvZ3Jlc3NpdmUgaW1hZ2UgbG9hZGluZyBzb21ldGltZXMgYmxpbmtzIGluIHdlYmtpdC9ibGluayB3aGVuIGFwcGx5aW5nIGFuaW1hdGlvbiB0byBwYXJlbnQgZWxlbWVudC5cblx0XHRcdC8vICAgIFRoYXQncyB3aHkgaXQncyBkaXNhYmxlZCBvbiB0b3VjaCBkZXZpY2VzIChtYWlubHkgYmVjYXVzZSBvZiBzd2lwZSB0cmFuc2l0aW9uKVxuXHRcdFx0Ly8gICAgXG5cdFx0XHQvLyAzLiBQcm9ncmVzc2l2ZSBpbWFnZSBsb2FkaW5nIHNvbWV0aW1lcyBkb2Vzbid0IHdvcmsgaW4gSUUgKHVwIHRvIDExKS5cblxuXHRcdFx0Ly8gRG9uJ3QgYWxsb3cgcHJvZ3Jlc3NpdmUgbG9hZGluZyBvbiBub24tbGFyZ2UgdG91Y2ggZGV2aWNlc1xuXHRcdFx0cmV0dXJuIF9vcHRpb25zLmZvcmNlUHJvZ3Jlc3NpdmVMb2FkaW5nIHx8ICFfbGlrZWx5VG91Y2hEZXZpY2UgfHwgX29wdGlvbnMubW91c2VVc2VkIHx8IHNjcmVlbi53aWR0aCA+IDEyMDA7IFxuXHRcdFx0Ly8gMTIwMCAtIHRvIGVsaW1pbmF0ZSB0b3VjaCBkZXZpY2VzIHdpdGggbGFyZ2Ugc2NyZWVuIChsaWtlIENocm9tZWJvb2sgUGl4ZWwpXG5cdFx0fSxcblxuXHRcdHNldENvbnRlbnQ6IGZ1bmN0aW9uKGhvbGRlciwgaW5kZXgpIHtcblxuXHRcdFx0aWYoX29wdGlvbnMubG9vcCkge1xuXHRcdFx0XHRpbmRleCA9IF9nZXRMb29wZWRJZChpbmRleCk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBwcmV2SXRlbSA9IHNlbGYuZ2V0SXRlbUF0KGhvbGRlci5pbmRleCk7XG5cdFx0XHRpZihwcmV2SXRlbSkge1xuXHRcdFx0XHRwcmV2SXRlbS5jb250YWluZXIgPSBudWxsO1xuXHRcdFx0fVxuXHRcblx0XHRcdHZhciBpdGVtID0gc2VsZi5nZXRJdGVtQXQoaW5kZXgpLFxuXHRcdFx0XHRpbWc7XG5cdFx0XHRcblx0XHRcdGlmKCFpdGVtKSB7XG5cdFx0XHRcdGhvbGRlci5lbC5pbm5lckhUTUwgPSAnJztcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBhbGxvdyB0byBvdmVycmlkZSBkYXRhXG5cdFx0XHRfc2hvdXQoJ2dldHRpbmdEYXRhJywgaW5kZXgsIGl0ZW0pO1xuXG5cdFx0XHRob2xkZXIuaW5kZXggPSBpbmRleDtcblx0XHRcdGhvbGRlci5pdGVtID0gaXRlbTtcblxuXHRcdFx0Ly8gYmFzZSBjb250YWluZXIgRElWIGlzIGNyZWF0ZWQgb25seSBvbmNlIGZvciBlYWNoIG9mIDMgaG9sZGVyc1xuXHRcdFx0dmFyIGJhc2VEaXYgPSBpdGVtLmNvbnRhaW5lciA9IGZyYW1ld29yay5jcmVhdGVFbCgncHN3cF9fem9vbS13cmFwJyk7IFxuXG5cdFx0XHRcblxuXHRcdFx0aWYoIWl0ZW0uc3JjICYmIGl0ZW0uaHRtbCkge1xuXHRcdFx0XHRpZihpdGVtLmh0bWwudGFnTmFtZSkge1xuXHRcdFx0XHRcdGJhc2VEaXYuYXBwZW5kQ2hpbGQoaXRlbS5odG1sKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRiYXNlRGl2LmlubmVySFRNTCA9IGl0ZW0uaHRtbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRfY2hlY2tGb3JFcnJvcihpdGVtKTtcblxuXHRcdFx0X2NhbGN1bGF0ZUl0ZW1TaXplKGl0ZW0sIF92aWV3cG9ydFNpemUpO1xuXHRcdFx0XG5cdFx0XHRpZihpdGVtLnNyYyAmJiAhaXRlbS5sb2FkRXJyb3IgJiYgIWl0ZW0ubG9hZGVkKSB7XG5cblx0XHRcdFx0aXRlbS5sb2FkQ29tcGxldGUgPSBmdW5jdGlvbihpdGVtKSB7XG5cblx0XHRcdFx0XHQvLyBnYWxsZXJ5IGNsb3NlZCBiZWZvcmUgaW1hZ2UgZmluaXNoZWQgbG9hZGluZ1xuXHRcdFx0XHRcdGlmKCFfaXNPcGVuKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gY2hlY2sgaWYgaG9sZGVyIGhhc24ndCBjaGFuZ2VkIHdoaWxlIGltYWdlIHdhcyBsb2FkaW5nXG5cdFx0XHRcdFx0aWYoaG9sZGVyICYmIGhvbGRlci5pbmRleCA9PT0gaW5kZXggKSB7XG5cdFx0XHRcdFx0XHRpZiggX2NoZWNrRm9yRXJyb3IoaXRlbSwgdHJ1ZSkgKSB7XG5cdFx0XHRcdFx0XHRcdGl0ZW0ubG9hZENvbXBsZXRlID0gaXRlbS5pbWcgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRfY2FsY3VsYXRlSXRlbVNpemUoaXRlbSwgX3ZpZXdwb3J0U2l6ZSk7XG5cdFx0XHRcdFx0XHRcdF9hcHBseVpvb21QYW5Ub0l0ZW0oaXRlbSk7XG5cblx0XHRcdFx0XHRcdFx0aWYoaG9sZGVyLmluZGV4ID09PSBfY3VycmVudEl0ZW1JbmRleCkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIHJlY2FsY3VsYXRlIGRpbWVuc2lvbnNcblx0XHRcdFx0XHRcdFx0XHRzZWxmLnVwZGF0ZUN1cnJab29tSXRlbSgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmKCAhaXRlbS5pbWFnZUFwcGVuZGVkICkge1xuXHRcdFx0XHRcdFx0XHRpZihfZmVhdHVyZXMudHJhbnNmb3JtICYmIChfbWFpblNjcm9sbEFuaW1hdGluZyB8fCBfaW5pdGlhbFpvb21SdW5uaW5nKSApIHtcblx0XHRcdFx0XHRcdFx0XHRfaW1hZ2VzVG9BcHBlbmRQb29sLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRcdFx0aXRlbTppdGVtLFxuXHRcdFx0XHRcdFx0XHRcdFx0YmFzZURpdjpiYXNlRGl2LFxuXHRcdFx0XHRcdFx0XHRcdFx0aW1nOml0ZW0uaW1nLFxuXHRcdFx0XHRcdFx0XHRcdFx0aW5kZXg6aW5kZXgsXG5cdFx0XHRcdFx0XHRcdFx0XHRob2xkZXI6aG9sZGVyLFxuXHRcdFx0XHRcdFx0XHRcdFx0Y2xlYXJQbGFjZWhvbGRlcjp0cnVlXG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0X2FwcGVuZEltYWdlKGluZGV4LCBpdGVtLCBiYXNlRGl2LCBpdGVtLmltZywgX21haW5TY3JvbGxBbmltYXRpbmcgfHwgX2luaXRpYWxab29tUnVubmluZywgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIHJlbW92ZSBwcmVsb2FkZXIgJiBtaW5pLWltZ1xuXHRcdFx0XHRcdFx0XHRpZighX2luaXRpYWxab29tUnVubmluZyAmJiBpdGVtLnBsYWNlaG9sZGVyKSB7XG5cdFx0XHRcdFx0XHRcdFx0aXRlbS5wbGFjZWhvbGRlci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRcdFx0XHRcdFx0XHRcdGl0ZW0ucGxhY2Vob2xkZXIgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aXRlbS5sb2FkQ29tcGxldGUgPSBudWxsO1xuXHRcdFx0XHRcdGl0ZW0uaW1nID0gbnVsbDsgLy8gbm8gbmVlZCB0byBzdG9yZSBpbWFnZSBlbGVtZW50IGFmdGVyIGl0J3MgYWRkZWRcblxuXHRcdFx0XHRcdF9zaG91dCgnaW1hZ2VMb2FkQ29tcGxldGUnLCBpbmRleCwgaXRlbSk7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0aWYoZnJhbWV3b3JrLmZlYXR1cmVzLnRyYW5zZm9ybSkge1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHZhciBwbGFjZWhvbGRlckNsYXNzTmFtZSA9ICdwc3dwX19pbWcgcHN3cF9faW1nLS1wbGFjZWhvbGRlcic7IFxuXHRcdFx0XHRcdHBsYWNlaG9sZGVyQ2xhc3NOYW1lICs9IChpdGVtLm1zcmMgPyAnJyA6ICcgcHN3cF9faW1nLS1wbGFjZWhvbGRlci0tYmxhbmsnKTtcblxuXHRcdFx0XHRcdHZhciBwbGFjZWhvbGRlciA9IGZyYW1ld29yay5jcmVhdGVFbChwbGFjZWhvbGRlckNsYXNzTmFtZSwgaXRlbS5tc3JjID8gJ2ltZycgOiAnJyk7XG5cdFx0XHRcdFx0aWYoaXRlbS5tc3JjKSB7XG5cdFx0XHRcdFx0XHRwbGFjZWhvbGRlci5zcmMgPSBpdGVtLm1zcmM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdF9zZXRJbWFnZVNpemUoaXRlbSwgcGxhY2Vob2xkZXIpO1xuXG5cdFx0XHRcdFx0YmFzZURpdi5hcHBlbmRDaGlsZChwbGFjZWhvbGRlcik7XG5cdFx0XHRcdFx0aXRlbS5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuXG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cblx0XHRcdFx0XG5cblx0XHRcdFx0aWYoIWl0ZW0ubG9hZGluZykge1xuXHRcdFx0XHRcdF9wcmVsb2FkSW1hZ2UoaXRlbSk7XG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdGlmKCBzZWxmLmFsbG93UHJvZ3Jlc3NpdmVJbWcoKSApIHtcblx0XHRcdFx0XHQvLyBqdXN0IGFwcGVuZCBpbWFnZVxuXHRcdFx0XHRcdGlmKCFfaW5pdGlhbENvbnRlbnRTZXQgJiYgX2ZlYXR1cmVzLnRyYW5zZm9ybSkge1xuXHRcdFx0XHRcdFx0X2ltYWdlc1RvQXBwZW5kUG9vbC5wdXNoKHtcblx0XHRcdFx0XHRcdFx0aXRlbTppdGVtLCBcblx0XHRcdFx0XHRcdFx0YmFzZURpdjpiYXNlRGl2LCBcblx0XHRcdFx0XHRcdFx0aW1nOml0ZW0uaW1nLCBcblx0XHRcdFx0XHRcdFx0aW5kZXg6aW5kZXgsIFxuXHRcdFx0XHRcdFx0XHRob2xkZXI6aG9sZGVyXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0X2FwcGVuZEltYWdlKGluZGV4LCBpdGVtLCBiYXNlRGl2LCBpdGVtLmltZywgdHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0fSBlbHNlIGlmKGl0ZW0uc3JjICYmICFpdGVtLmxvYWRFcnJvcikge1xuXHRcdFx0XHQvLyBpbWFnZSBvYmplY3QgaXMgY3JlYXRlZCBldmVyeSB0aW1lLCBkdWUgdG8gYnVncyBvZiBpbWFnZSBsb2FkaW5nICYgZGVsYXkgd2hlbiBzd2l0Y2hpbmcgaW1hZ2VzXG5cdFx0XHRcdGltZyA9IGZyYW1ld29yay5jcmVhdGVFbCgncHN3cF9faW1nJywgJ2ltZycpO1xuXHRcdFx0XHRpbWcuc3R5bGUub3BhY2l0eSA9IDE7XG5cdFx0XHRcdGltZy5zcmMgPSBpdGVtLnNyYztcblx0XHRcdFx0X3NldEltYWdlU2l6ZShpdGVtLCBpbWcpO1xuXHRcdFx0XHRfYXBwZW5kSW1hZ2UoaW5kZXgsIGl0ZW0sIGJhc2VEaXYsIGltZywgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRcblxuXHRcdFx0aWYoIV9pbml0aWFsQ29udGVudFNldCAmJiBpbmRleCA9PT0gX2N1cnJlbnRJdGVtSW5kZXgpIHtcblx0XHRcdFx0X2N1cnJab29tRWxlbWVudFN0eWxlID0gYmFzZURpdi5zdHlsZTtcblx0XHRcdFx0X3Nob3dPckhpZGUoaXRlbSwgKGltZyB8fGl0ZW0uaW1nKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X2FwcGx5Wm9vbVBhblRvSXRlbShpdGVtKTtcblx0XHRcdH1cblxuXHRcdFx0aG9sZGVyLmVsLmlubmVySFRNTCA9ICcnO1xuXHRcdFx0aG9sZGVyLmVsLmFwcGVuZENoaWxkKGJhc2VEaXYpO1xuXHRcdH0sXG5cblx0XHRjbGVhblNsaWRlOiBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdGlmKGl0ZW0uaW1nICkge1xuXHRcdFx0XHRpdGVtLmltZy5vbmxvYWQgPSBpdGVtLmltZy5vbmVycm9yID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdGl0ZW0ubG9hZGVkID0gaXRlbS5sb2FkaW5nID0gaXRlbS5pbWcgPSBpdGVtLmltYWdlQXBwZW5kZWQgPSBmYWxzZTtcblx0XHR9XG5cblx0fVxufSk7XG5cbi8qPj5pdGVtcy1jb250cm9sbGVyKi9cblxuLyo+PnRhcCovXG4vKipcbiAqIHRhcC5qczpcbiAqXG4gKiBEaXNwbGF0Y2hlcyB0YXAgYW5kIGRvdWJsZS10YXAgZXZlbnRzLlxuICogXG4gKi9cblxudmFyIHRhcFRpbWVyLFxuXHR0YXBSZWxlYXNlUG9pbnQgPSB7fSxcblx0X2Rpc3BhdGNoVGFwRXZlbnQgPSBmdW5jdGlvbihvcmlnRXZlbnQsIHJlbGVhc2VQb2ludCwgcG9pbnRlclR5cGUpIHtcdFx0XG5cdFx0dmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCggJ0N1c3RvbUV2ZW50JyApLFxuXHRcdFx0ZURldGFpbCA9IHtcblx0XHRcdFx0b3JpZ0V2ZW50Om9yaWdFdmVudCwgXG5cdFx0XHRcdHRhcmdldDpvcmlnRXZlbnQudGFyZ2V0LCBcblx0XHRcdFx0cmVsZWFzZVBvaW50OiByZWxlYXNlUG9pbnQsIFxuXHRcdFx0XHRwb2ludGVyVHlwZTpwb2ludGVyVHlwZSB8fCAndG91Y2gnXG5cdFx0XHR9O1xuXG5cdFx0ZS5pbml0Q3VzdG9tRXZlbnQoICdwc3dwVGFwJywgdHJ1ZSwgdHJ1ZSwgZURldGFpbCApO1xuXHRcdG9yaWdFdmVudC50YXJnZXQuZGlzcGF0Y2hFdmVudChlKTtcblx0fTtcblxuX3JlZ2lzdGVyTW9kdWxlKCdUYXAnLCB7XG5cdHB1YmxpY01ldGhvZHM6IHtcblx0XHRpbml0VGFwOiBmdW5jdGlvbigpIHtcblx0XHRcdF9saXN0ZW4oJ2ZpcnN0VG91Y2hTdGFydCcsIHNlbGYub25UYXBTdGFydCk7XG5cdFx0XHRfbGlzdGVuKCd0b3VjaFJlbGVhc2UnLCBzZWxmLm9uVGFwUmVsZWFzZSk7XG5cdFx0XHRfbGlzdGVuKCdkZXN0cm95JywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRhcFJlbGVhc2VQb2ludCA9IHt9O1xuXHRcdFx0XHR0YXBUaW1lciA9IG51bGw7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdG9uVGFwU3RhcnQ6IGZ1bmN0aW9uKHRvdWNoTGlzdCkge1xuXHRcdFx0aWYodG91Y2hMaXN0Lmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRhcFRpbWVyKTtcblx0XHRcdFx0dGFwVGltZXIgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0b25UYXBSZWxlYXNlOiBmdW5jdGlvbihlLCByZWxlYXNlUG9pbnQpIHtcblx0XHRcdGlmKCFyZWxlYXNlUG9pbnQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZighX21vdmVkICYmICFfaXNNdWx0aXRvdWNoICYmICFfbnVtQW5pbWF0aW9ucykge1xuXHRcdFx0XHR2YXIgcDAgPSByZWxlYXNlUG9pbnQ7XG5cdFx0XHRcdGlmKHRhcFRpbWVyKSB7XG5cdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRhcFRpbWVyKTtcblx0XHRcdFx0XHR0YXBUaW1lciA9IG51bGw7XG5cblx0XHRcdFx0XHQvLyBDaGVjayBpZiB0YXBlZCBvbiB0aGUgc2FtZSBwbGFjZVxuXHRcdFx0XHRcdGlmICggX2lzTmVhcmJ5UG9pbnRzKHAwLCB0YXBSZWxlYXNlUG9pbnQpICkge1xuXHRcdFx0XHRcdFx0X3Nob3V0KCdkb3VibGVUYXAnLCBwMCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYocmVsZWFzZVBvaW50LnR5cGUgPT09ICdtb3VzZScpIHtcblx0XHRcdFx0XHRfZGlzcGF0Y2hUYXBFdmVudChlLCByZWxlYXNlUG9pbnQsICdtb3VzZScpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBjbGlja2VkVGFnTmFtZSA9IGUudGFyZ2V0LnRhZ05hbWUudG9VcHBlckNhc2UoKTtcblx0XHRcdFx0Ly8gYXZvaWQgZG91YmxlIHRhcCBkZWxheSBvbiBidXR0b25zIGFuZCBlbGVtZW50cyB0aGF0IGhhdmUgY2xhc3MgcHN3cF9fc2luZ2xlLXRhcFxuXHRcdFx0XHRpZihjbGlja2VkVGFnTmFtZSA9PT0gJ0JVVFRPTicgfHwgZnJhbWV3b3JrLmhhc0NsYXNzKGUudGFyZ2V0LCAncHN3cF9fc2luZ2xlLXRhcCcpICkge1xuXHRcdFx0XHRcdF9kaXNwYXRjaFRhcEV2ZW50KGUsIHJlbGVhc2VQb2ludCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2VxdWFsaXplUG9pbnRzKHRhcFJlbGVhc2VQb2ludCwgcDApO1xuXG5cdFx0XHRcdHRhcFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRfZGlzcGF0Y2hUYXBFdmVudChlLCByZWxlYXNlUG9pbnQpO1xuXHRcdFx0XHRcdHRhcFRpbWVyID0gbnVsbDtcblx0XHRcdFx0fSwgMzAwKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG4vKj4+dGFwKi9cblxuLyo+PmRlc2t0b3Atem9vbSovXG4vKipcbiAqXG4gKiBkZXNrdG9wLXpvb20uanM6XG4gKlxuICogLSBCaW5kcyBtb3VzZXdoZWVsIGV2ZW50IGZvciBwYW5pbmcgem9vbWVkIGltYWdlLlxuICogLSBNYW5hZ2VzIFwiZHJhZ2dpbmdcIiwgXCJ6b29tZWQtaW5cIiwgXCJ6b29tLW91dFwiIGNsYXNzZXMuXG4gKiAgICh3aGljaCBhcmUgdXNlZCBmb3IgY3Vyc29ycyBhbmQgem9vbSBpY29uKVxuICogLSBBZGRzIHRvZ2dsZURlc2t0b3Bab29tIGZ1bmN0aW9uLlxuICogXG4gKi9cblxudmFyIF93aGVlbERlbHRhO1xuXHRcbl9yZWdpc3Rlck1vZHVsZSgnRGVza3RvcFpvb20nLCB7XG5cblx0cHVibGljTWV0aG9kczoge1xuXG5cdFx0aW5pdERlc2t0b3Bab29tOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0aWYoX29sZElFKSB7XG5cdFx0XHRcdC8vIG5vIHpvb20gZm9yIG9sZCBJRSAoPD04KVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmKF9saWtlbHlUb3VjaERldmljZSkge1xuXHRcdFx0XHQvLyBpZiBkZXRlY3RlZCBoYXJkd2FyZSB0b3VjaCBzdXBwb3J0LCB3ZSB3YWl0IHVudGlsIG1vdXNlIGlzIHVzZWQsXG5cdFx0XHRcdC8vIGFuZCBvbmx5IHRoZW4gYXBwbHkgZGVza3RvcC16b29tIGZlYXR1cmVzXG5cdFx0XHRcdF9saXN0ZW4oJ21vdXNlVXNlZCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHNlbGYuc2V0dXBEZXNrdG9wWm9vbSgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuc2V0dXBEZXNrdG9wWm9vbSh0cnVlKTtcblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRzZXR1cERlc2t0b3Bab29tOiBmdW5jdGlvbihvbkluaXQpIHtcblxuXHRcdFx0X3doZWVsRGVsdGEgPSB7fTtcblxuXHRcdFx0dmFyIGV2ZW50cyA9ICd3aGVlbCBtb3VzZXdoZWVsIERPTU1vdXNlU2Nyb2xsJztcblx0XHRcdFxuXHRcdFx0X2xpc3RlbignYmluZEV2ZW50cycsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmcmFtZXdvcmsuYmluZCh0ZW1wbGF0ZSwgZXZlbnRzLCAgc2VsZi5oYW5kbGVNb3VzZVdoZWVsKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRfbGlzdGVuKCd1bmJpbmRFdmVudHMnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYoX3doZWVsRGVsdGEpIHtcblx0XHRcdFx0XHRmcmFtZXdvcmsudW5iaW5kKHRlbXBsYXRlLCBldmVudHMsIHNlbGYuaGFuZGxlTW91c2VXaGVlbCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRzZWxmLm1vdXNlWm9vbWVkSW4gPSBmYWxzZTtcblxuXHRcdFx0dmFyIGhhc0RyYWdnaW5nQ2xhc3MsXG5cdFx0XHRcdHVwZGF0ZVpvb21hYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYoc2VsZi5tb3VzZVpvb21lZEluKSB7XG5cdFx0XHRcdFx0XHRmcmFtZXdvcmsucmVtb3ZlQ2xhc3ModGVtcGxhdGUsICdwc3dwLS16b29tZWQtaW4nKTtcblx0XHRcdFx0XHRcdHNlbGYubW91c2Vab29tZWRJbiA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihfY3Vyclpvb21MZXZlbCA8IDEpIHtcblx0XHRcdFx0XHRcdGZyYW1ld29yay5hZGRDbGFzcyh0ZW1wbGF0ZSwgJ3Bzd3AtLXpvb20tYWxsb3dlZCcpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRmcmFtZXdvcmsucmVtb3ZlQ2xhc3ModGVtcGxhdGUsICdwc3dwLS16b29tLWFsbG93ZWQnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVtb3ZlRHJhZ2dpbmdDbGFzcygpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZW1vdmVEcmFnZ2luZ0NsYXNzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYoaGFzRHJhZ2dpbmdDbGFzcykge1xuXHRcdFx0XHRcdFx0ZnJhbWV3b3JrLnJlbW92ZUNsYXNzKHRlbXBsYXRlLCAncHN3cC0tZHJhZ2dpbmcnKTtcblx0XHRcdFx0XHRcdGhhc0RyYWdnaW5nQ2xhc3MgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdF9saXN0ZW4oJ3Jlc2l6ZScgLCB1cGRhdGVab29tYWJsZSk7XG5cdFx0XHRfbGlzdGVuKCdhZnRlckNoYW5nZScgLCB1cGRhdGVab29tYWJsZSk7XG5cdFx0XHRfbGlzdGVuKCdwb2ludGVyRG93bicsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZihzZWxmLm1vdXNlWm9vbWVkSW4pIHtcblx0XHRcdFx0XHRoYXNEcmFnZ2luZ0NsYXNzID0gdHJ1ZTtcblx0XHRcdFx0XHRmcmFtZXdvcmsuYWRkQ2xhc3ModGVtcGxhdGUsICdwc3dwLS1kcmFnZ2luZycpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdF9saXN0ZW4oJ3BvaW50ZXJVcCcsIHJlbW92ZURyYWdnaW5nQ2xhc3MpO1xuXG5cdFx0XHRpZighb25Jbml0KSB7XG5cdFx0XHRcdHVwZGF0ZVpvb21hYmxlKCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHR9LFxuXG5cdFx0aGFuZGxlTW91c2VXaGVlbDogZnVuY3Rpb24oZSkge1xuXG5cdFx0XHRpZihfY3Vyclpvb21MZXZlbCA8PSBzZWxmLmN1cnJJdGVtLmZpdFJhdGlvKSB7XG5cdFx0XHRcdGlmKCBfb3B0aW9ucy5tb2RhbCApIHtcblxuXHRcdFx0XHRcdGlmICghX29wdGlvbnMuY2xvc2VPblNjcm9sbCB8fCBfbnVtQW5pbWF0aW9ucyB8fCBfaXNEcmFnZ2luZykge1xuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZihfdHJhbnNmb3JtS2V5ICYmIE1hdGguYWJzKGUuZGVsdGFZKSA+IDIpIHtcblx0XHRcdFx0XHRcdC8vIGNsb3NlIFBob3RvU3dpcGVcblx0XHRcdFx0XHRcdC8vIGlmIGJyb3dzZXIgc3VwcG9ydHMgdHJhbnNmb3JtcyAmIHNjcm9sbCBjaGFuZ2VkIGVub3VnaFxuXHRcdFx0XHRcdFx0X2Nsb3NlZEJ5U2Nyb2xsID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHNlbGYuY2xvc2UoKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYWxsb3cganVzdCBvbmUgZXZlbnQgdG8gZmlyZVxuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzL3doZWVsXG5cdFx0XHRfd2hlZWxEZWx0YS54ID0gMDtcblxuXHRcdFx0aWYoJ2RlbHRhWCcgaW4gZSkge1xuXHRcdFx0XHRpZihlLmRlbHRhTW9kZSA9PT0gMSAvKiBET01fREVMVEFfTElORSAqLykge1xuXHRcdFx0XHRcdC8vIDE4IC0gYXZlcmFnZSBsaW5lIGhlaWdodFxuXHRcdFx0XHRcdF93aGVlbERlbHRhLnggPSBlLmRlbHRhWCAqIDE4O1xuXHRcdFx0XHRcdF93aGVlbERlbHRhLnkgPSBlLmRlbHRhWSAqIDE4O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF93aGVlbERlbHRhLnggPSBlLmRlbHRhWDtcblx0XHRcdFx0XHRfd2hlZWxEZWx0YS55ID0gZS5kZWx0YVk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZignd2hlZWxEZWx0YScgaW4gZSkge1xuXHRcdFx0XHRpZihlLndoZWVsRGVsdGFYKSB7XG5cdFx0XHRcdFx0X3doZWVsRGVsdGEueCA9IC0wLjE2ICogZS53aGVlbERlbHRhWDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihlLndoZWVsRGVsdGFZKSB7XG5cdFx0XHRcdFx0X3doZWVsRGVsdGEueSA9IC0wLjE2ICogZS53aGVlbERlbHRhWTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfd2hlZWxEZWx0YS55ID0gLTAuMTYgKiBlLndoZWVsRGVsdGE7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZignZGV0YWlsJyBpbiBlKSB7XG5cdFx0XHRcdF93aGVlbERlbHRhLnkgPSBlLmRldGFpbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0X2NhbGN1bGF0ZVBhbkJvdW5kcyhfY3Vyclpvb21MZXZlbCwgdHJ1ZSk7XG5cblx0XHRcdHZhciBuZXdQYW5YID0gX3Bhbk9mZnNldC54IC0gX3doZWVsRGVsdGEueCxcblx0XHRcdFx0bmV3UGFuWSA9IF9wYW5PZmZzZXQueSAtIF93aGVlbERlbHRhLnk7XG5cblx0XHRcdC8vIG9ubHkgcHJldmVudCBzY3JvbGxpbmcgaW4gbm9ubW9kYWwgbW9kZSB3aGVuIG5vdCBhdCBlZGdlc1xuXHRcdFx0aWYgKF9vcHRpb25zLm1vZGFsIHx8XG5cdFx0XHRcdChcblx0XHRcdFx0bmV3UGFuWCA8PSBfY3VyclBhbkJvdW5kcy5taW4ueCAmJiBuZXdQYW5YID49IF9jdXJyUGFuQm91bmRzLm1heC54ICYmXG5cdFx0XHRcdG5ld1BhblkgPD0gX2N1cnJQYW5Cb3VuZHMubWluLnkgJiYgbmV3UGFuWSA+PSBfY3VyclBhbkJvdW5kcy5tYXgueVxuXHRcdFx0XHQpICkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRPRE86IHVzZSByQUYgaW5zdGVhZCBvZiBtb3VzZXdoZWVsP1xuXHRcdFx0c2VsZi5wYW5UbyhuZXdQYW5YLCBuZXdQYW5ZKTtcblx0XHR9LFxuXG5cdFx0dG9nZ2xlRGVza3RvcFpvb206IGZ1bmN0aW9uKGNlbnRlclBvaW50KSB7XG5cdFx0XHRjZW50ZXJQb2ludCA9IGNlbnRlclBvaW50IHx8IHt4Ol92aWV3cG9ydFNpemUueC8yICsgX29mZnNldC54LCB5Ol92aWV3cG9ydFNpemUueS8yICsgX29mZnNldC55IH07XG5cblx0XHRcdHZhciBkb3VibGVUYXBab29tTGV2ZWwgPSBfb3B0aW9ucy5nZXREb3VibGVUYXBab29tKHRydWUsIHNlbGYuY3Vyckl0ZW0pO1xuXHRcdFx0dmFyIHpvb21PdXQgPSBfY3Vyclpvb21MZXZlbCA9PT0gZG91YmxlVGFwWm9vbUxldmVsO1xuXHRcdFx0XG5cdFx0XHRzZWxmLm1vdXNlWm9vbWVkSW4gPSAhem9vbU91dDtcblxuXHRcdFx0c2VsZi56b29tVG8oem9vbU91dCA/IHNlbGYuY3Vyckl0ZW0uaW5pdGlhbFpvb21MZXZlbCA6IGRvdWJsZVRhcFpvb21MZXZlbCwgY2VudGVyUG9pbnQsIDMzMyk7XG5cdFx0XHRmcmFtZXdvcmtbICghem9vbU91dCA/ICdhZGQnIDogJ3JlbW92ZScpICsgJ0NsYXNzJ10odGVtcGxhdGUsICdwc3dwLS16b29tZWQtaW4nKTtcblx0XHR9XG5cblx0fVxufSk7XG5cblxuLyo+PmRlc2t0b3Atem9vbSovXG5cbi8qPj5oaXN0b3J5Ki9cbi8qKlxuICpcbiAqIGhpc3RvcnkuanM6XG4gKlxuICogLSBCYWNrIGJ1dHRvbiB0byBjbG9zZSBnYWxsZXJ5LlxuICogXG4gKiAtIFVuaXF1ZSBVUkwgZm9yIGVhY2ggc2xpZGU6IGV4YW1wbGUuY29tLyZwaWQ9MSZnaWQ9M1xuICogICAod2hlcmUgUElEIGlzIHBpY3R1cmUgaW5kZXgsIGFuZCBHSUQgYW5kIGdhbGxlcnkgaW5kZXgpXG4gKiAgIFxuICogLSBTd2l0Y2ggVVJMIHdoZW4gc2xpZGVzIGNoYW5nZS5cbiAqIFxuICovXG5cblxudmFyIF9oaXN0b3J5RGVmYXVsdE9wdGlvbnMgPSB7XG5cdGhpc3Rvcnk6IHRydWUsXG5cdGdhbGxlcnlVSUQ6IDFcbn07XG5cbnZhciBfaGlzdG9yeVVwZGF0ZVRpbWVvdXQsXG5cdF9oYXNoQ2hhbmdlVGltZW91dCxcblx0X2hhc2hBbmltQ2hlY2tUaW1lb3V0LFxuXHRfaGFzaENoYW5nZWRCeVNjcmlwdCxcblx0X2hhc2hDaGFuZ2VkQnlIaXN0b3J5LFxuXHRfaGFzaFJlc2V0ZWQsXG5cdF9pbml0aWFsSGFzaCxcblx0X2hpc3RvcnlDaGFuZ2VkLFxuXHRfY2xvc2VkRnJvbVVSTCxcblx0X3VybENoYW5nZWRPbmNlLFxuXHRfd2luZG93TG9jLFxuXG5cdF9zdXBwb3J0c1B1c2hTdGF0ZSxcblxuXHRfZ2V0SGFzaCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBfd2luZG93TG9jLmhhc2guc3Vic3RyaW5nKDEpO1xuXHR9LFxuXHRfY2xlYW5IaXN0b3J5VGltZW91dHMgPSBmdW5jdGlvbigpIHtcblxuXHRcdGlmKF9oaXN0b3J5VXBkYXRlVGltZW91dCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KF9oaXN0b3J5VXBkYXRlVGltZW91dCk7XG5cdFx0fVxuXG5cdFx0aWYoX2hhc2hBbmltQ2hlY2tUaW1lb3V0KSB7XG5cdFx0XHRjbGVhclRpbWVvdXQoX2hhc2hBbmltQ2hlY2tUaW1lb3V0KTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gcGlkIC0gUGljdHVyZSBpbmRleFxuXHQvLyBnaWQgLSBHYWxsZXJ5IGluZGV4XG5cdF9wYXJzZUl0ZW1JbmRleEZyb21VUkwgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgaGFzaCA9IF9nZXRIYXNoKCksXG5cdFx0XHRwYXJhbXMgPSB7fTtcblxuXHRcdGlmKGhhc2gubGVuZ3RoIDwgNSkgeyAvLyBwaWQ9MVxuXHRcdFx0cmV0dXJuIHBhcmFtcztcblx0XHR9XG5cblx0XHR2YXIgaSwgdmFycyA9IGhhc2guc3BsaXQoJyYnKTtcblx0XHRmb3IgKGkgPSAwOyBpIDwgdmFycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYoIXZhcnNbaV0pIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHR2YXIgcGFpciA9IHZhcnNbaV0uc3BsaXQoJz0nKTtcdFxuXHRcdFx0aWYocGFpci5sZW5ndGggPCAyKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0cGFyYW1zW3BhaXJbMF1dID0gcGFpclsxXTtcblx0XHR9XG5cdFx0aWYoX29wdGlvbnMuZ2FsbGVyeVBJRHMpIHtcblx0XHRcdC8vIGRldGVjdCBjdXN0b20gcGlkIGluIGhhc2ggYW5kIHNlYXJjaCBmb3IgaXQgYW1vbmcgdGhlIGl0ZW1zIGNvbGxlY3Rpb25cblx0XHRcdHZhciBzZWFyY2hmb3IgPSBwYXJhbXMucGlkO1xuXHRcdFx0cGFyYW1zLnBpZCA9IDA7IC8vIGlmIGN1c3RvbSBwaWQgY2Fubm90IGJlIGZvdW5kLCBmYWxsYmFjayB0byB0aGUgZmlyc3QgaXRlbVxuXHRcdFx0Zm9yKGkgPSAwOyBpIDwgX2l0ZW1zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmKF9pdGVtc1tpXS5waWQgPT09IHNlYXJjaGZvcikge1xuXHRcdFx0XHRcdHBhcmFtcy5waWQgPSBpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhcmFtcy5waWQgPSBwYXJzZUludChwYXJhbXMucGlkLDEwKS0xO1xuXHRcdH1cblx0XHRpZiggcGFyYW1zLnBpZCA8IDAgKSB7XG5cdFx0XHRwYXJhbXMucGlkID0gMDtcblx0XHR9XG5cdFx0cmV0dXJuIHBhcmFtcztcblx0fSxcblx0X3VwZGF0ZUhhc2ggPSBmdW5jdGlvbigpIHtcblxuXHRcdGlmKF9oYXNoQW5pbUNoZWNrVGltZW91dCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KF9oYXNoQW5pbUNoZWNrVGltZW91dCk7XG5cdFx0fVxuXG5cblx0XHRpZihfbnVtQW5pbWF0aW9ucyB8fCBfaXNEcmFnZ2luZykge1xuXHRcdFx0Ly8gY2hhbmdpbmcgYnJvd3NlciBVUkwgZm9yY2VzIGxheW91dC9wYWludCBpbiBzb21lIGJyb3dzZXJzLCB3aGljaCBjYXVzZXMgbm90aWNhYmxlIGxhZyBkdXJpbmcgYW5pbWF0aW9uXG5cdFx0XHQvLyB0aGF0J3Mgd2h5IHdlIHVwZGF0ZSBoYXNoIG9ubHkgd2hlbiBubyBhbmltYXRpb25zIHJ1bm5pbmdcblx0XHRcdF9oYXNoQW5pbUNoZWNrVGltZW91dCA9IHNldFRpbWVvdXQoX3VwZGF0ZUhhc2gsIDUwMCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdFxuXHRcdGlmKF9oYXNoQ2hhbmdlZEJ5U2NyaXB0KSB7XG5cdFx0XHRjbGVhclRpbWVvdXQoX2hhc2hDaGFuZ2VUaW1lb3V0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0X2hhc2hDaGFuZ2VkQnlTY3JpcHQgPSB0cnVlO1xuXHRcdH1cblxuXG5cdFx0dmFyIHBpZCA9IChfY3VycmVudEl0ZW1JbmRleCArIDEpO1xuXHRcdHZhciBpdGVtID0gX2dldEl0ZW1BdCggX2N1cnJlbnRJdGVtSW5kZXggKTtcblx0XHRpZihpdGVtLmhhc093blByb3BlcnR5KCdwaWQnKSkge1xuXHRcdFx0Ly8gY2FycnkgZm9yd2FyZCBhbnkgY3VzdG9tIHBpZCBhc3NpZ25lZCB0byB0aGUgaXRlbVxuXHRcdFx0cGlkID0gaXRlbS5waWQ7XG5cdFx0fVxuXHRcdHZhciBuZXdIYXNoID0gX2luaXRpYWxIYXNoICsgJyYnICArICAnZ2lkPScgKyBfb3B0aW9ucy5nYWxsZXJ5VUlEICsgJyYnICsgJ3BpZD0nICsgcGlkO1xuXG5cdFx0aWYoIV9oaXN0b3J5Q2hhbmdlZCkge1xuXHRcdFx0aWYoX3dpbmRvd0xvYy5oYXNoLmluZGV4T2YobmV3SGFzaCkgPT09IC0xKSB7XG5cdFx0XHRcdF91cmxDaGFuZ2VkT25jZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBmaXJzdCB0aW1lIC0gYWRkIG5ldyBoaXNvcnkgcmVjb3JkLCB0aGVuIGp1c3QgcmVwbGFjZVxuXHRcdH1cblxuXHRcdHZhciBuZXdVUkwgPSBfd2luZG93TG9jLmhyZWYuc3BsaXQoJyMnKVswXSArICcjJyArICBuZXdIYXNoO1xuXG5cdFx0aWYoIF9zdXBwb3J0c1B1c2hTdGF0ZSApIHtcblxuXHRcdFx0aWYoJyMnICsgbmV3SGFzaCAhPT0gd2luZG93LmxvY2F0aW9uLmhhc2gpIHtcblx0XHRcdFx0aGlzdG9yeVtfaGlzdG9yeUNoYW5nZWQgPyAncmVwbGFjZVN0YXRlJyA6ICdwdXNoU3RhdGUnXSgnJywgZG9jdW1lbnQudGl0bGUsIG5ld1VSTCk7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYoX2hpc3RvcnlDaGFuZ2VkKSB7XG5cdFx0XHRcdF93aW5kb3dMb2MucmVwbGFjZSggbmV3VVJMICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRfd2luZG93TG9jLmhhc2ggPSBuZXdIYXNoO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRcblxuXHRcdF9oaXN0b3J5Q2hhbmdlZCA9IHRydWU7XG5cdFx0X2hhc2hDaGFuZ2VUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdF9oYXNoQ2hhbmdlZEJ5U2NyaXB0ID0gZmFsc2U7XG5cdFx0fSwgNjApO1xuXHR9O1xuXG5cblxuXHRcblxuX3JlZ2lzdGVyTW9kdWxlKCdIaXN0b3J5Jywge1xuXG5cdFxuXG5cdHB1YmxpY01ldGhvZHM6IHtcblx0XHRpbml0SGlzdG9yeTogZnVuY3Rpb24oKSB7XG5cblx0XHRcdGZyYW1ld29yay5leHRlbmQoX29wdGlvbnMsIF9oaXN0b3J5RGVmYXVsdE9wdGlvbnMsIHRydWUpO1xuXG5cdFx0XHRpZiggIV9vcHRpb25zLmhpc3RvcnkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXG5cdFx0XHRfd2luZG93TG9jID0gd2luZG93LmxvY2F0aW9uO1xuXHRcdFx0X3VybENoYW5nZWRPbmNlID0gZmFsc2U7XG5cdFx0XHRfY2xvc2VkRnJvbVVSTCA9IGZhbHNlO1xuXHRcdFx0X2hpc3RvcnlDaGFuZ2VkID0gZmFsc2U7XG5cdFx0XHRfaW5pdGlhbEhhc2ggPSBfZ2V0SGFzaCgpO1xuXHRcdFx0X3N1cHBvcnRzUHVzaFN0YXRlID0gKCdwdXNoU3RhdGUnIGluIGhpc3RvcnkpO1xuXG5cblx0XHRcdGlmKF9pbml0aWFsSGFzaC5pbmRleE9mKCdnaWQ9JykgPiAtMSkge1xuXHRcdFx0XHRfaW5pdGlhbEhhc2ggPSBfaW5pdGlhbEhhc2guc3BsaXQoJyZnaWQ9JylbMF07XG5cdFx0XHRcdF9pbml0aWFsSGFzaCA9IF9pbml0aWFsSGFzaC5zcGxpdCgnP2dpZD0nKVswXTtcblx0XHRcdH1cblx0XHRcdFxuXG5cdFx0XHRfbGlzdGVuKCdhZnRlckNoYW5nZScsIHNlbGYudXBkYXRlVVJMKTtcblx0XHRcdF9saXN0ZW4oJ3VuYmluZEV2ZW50cycsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmcmFtZXdvcmsudW5iaW5kKHdpbmRvdywgJ2hhc2hjaGFuZ2UnLCBzZWxmLm9uSGFzaENoYW5nZSk7XG5cdFx0XHR9KTtcblxuXG5cdFx0XHR2YXIgcmV0dXJuVG9PcmlnaW5hbCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRfaGFzaFJlc2V0ZWQgPSB0cnVlO1xuXHRcdFx0XHRpZighX2Nsb3NlZEZyb21VUkwpIHtcblxuXHRcdFx0XHRcdGlmKF91cmxDaGFuZ2VkT25jZSkge1xuXHRcdFx0XHRcdFx0aGlzdG9yeS5iYWNrKCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0aWYoX2luaXRpYWxIYXNoKSB7XG5cdFx0XHRcdFx0XHRcdF93aW5kb3dMb2MuaGFzaCA9IF9pbml0aWFsSGFzaDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmIChfc3VwcG9ydHNQdXNoU3RhdGUpIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIHJlbW92ZSBoYXNoIGZyb20gdXJsIHdpdGhvdXQgcmVmcmVzaGluZyBpdCBvciBzY3JvbGxpbmcgdG8gdG9wXG5cdFx0XHRcdFx0XHRcdFx0aGlzdG9yeS5wdXNoU3RhdGUoJycsIGRvY3VtZW50LnRpdGxlLCAgX3dpbmRvd0xvYy5wYXRobmFtZSArIF93aW5kb3dMb2Muc2VhcmNoICk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0X3dpbmRvd0xvYy5oYXNoID0gJyc7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfY2xlYW5IaXN0b3J5VGltZW91dHMoKTtcblx0XHRcdH07XG5cblxuXHRcdFx0X2xpc3RlbigndW5iaW5kRXZlbnRzJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmKF9jbG9zZWRCeVNjcm9sbCkge1xuXHRcdFx0XHRcdC8vIGlmIFBob3RvU3dpcGUgaXMgY2xvc2VkIGJ5IHNjcm9sbCwgd2UgZ28gXCJiYWNrXCIgYmVmb3JlIHRoZSBjbG9zaW5nIGFuaW1hdGlvbiBzdGFydHNcblx0XHRcdFx0XHQvLyB0aGlzIGlzIGRvbmUgdG8ga2VlcCB0aGUgc2Nyb2xsIHBvc2l0aW9uXG5cdFx0XHRcdFx0cmV0dXJuVG9PcmlnaW5hbCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdF9saXN0ZW4oJ2Rlc3Ryb3knLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYoIV9oYXNoUmVzZXRlZCkge1xuXHRcdFx0XHRcdHJldHVyblRvT3JpZ2luYWwoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRfbGlzdGVuKCdmaXJzdFVwZGF0ZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRfY3VycmVudEl0ZW1JbmRleCA9IF9wYXJzZUl0ZW1JbmRleEZyb21VUkwoKS5waWQ7XG5cdFx0XHR9KTtcblxuXHRcdFx0XG5cblx0XHRcdFxuXHRcdFx0dmFyIGluZGV4ID0gX2luaXRpYWxIYXNoLmluZGV4T2YoJ3BpZD0nKTtcblx0XHRcdGlmKGluZGV4ID4gLTEpIHtcblx0XHRcdFx0X2luaXRpYWxIYXNoID0gX2luaXRpYWxIYXNoLnN1YnN0cmluZygwLCBpbmRleCk7XG5cdFx0XHRcdGlmKF9pbml0aWFsSGFzaC5zbGljZSgtMSkgPT09ICcmJykge1xuXHRcdFx0XHRcdF9pbml0aWFsSGFzaCA9IF9pbml0aWFsSGFzaC5zbGljZSgwLCAtMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZihfaXNPcGVuKSB7IC8vIGhhc24ndCBkZXN0cm95ZWQgeWV0XG5cdFx0XHRcdFx0ZnJhbWV3b3JrLmJpbmQod2luZG93LCAnaGFzaGNoYW5nZScsIHNlbGYub25IYXNoQ2hhbmdlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgNDApO1xuXHRcdFx0XG5cdFx0fSxcblx0XHRvbkhhc2hDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRpZihfZ2V0SGFzaCgpID09PSBfaW5pdGlhbEhhc2gpIHtcblxuXHRcdFx0XHRfY2xvc2VkRnJvbVVSTCA9IHRydWU7XG5cdFx0XHRcdHNlbGYuY2xvc2UoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYoIV9oYXNoQ2hhbmdlZEJ5U2NyaXB0KSB7XG5cblx0XHRcdFx0X2hhc2hDaGFuZ2VkQnlIaXN0b3J5ID0gdHJ1ZTtcblx0XHRcdFx0c2VsZi5nb1RvKCBfcGFyc2VJdGVtSW5kZXhGcm9tVVJMKCkucGlkICk7XG5cdFx0XHRcdF9oYXNoQ2hhbmdlZEJ5SGlzdG9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0fSxcblx0XHR1cGRhdGVVUkw6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBEZWxheSB0aGUgdXBkYXRlIG9mIFVSTCwgdG8gYXZvaWQgbGFnIGR1cmluZyB0cmFuc2l0aW9uLCBcblx0XHRcdC8vIGFuZCB0byBub3QgdG8gdHJpZ2dlciBhY3Rpb25zIGxpa2UgXCJyZWZyZXNoIHBhZ2Ugc291bmRcIiBvciBcImJsaW5raW5nIGZhdmljb25cIiB0byBvZnRlblxuXHRcdFx0XG5cdFx0XHRfY2xlYW5IaXN0b3J5VGltZW91dHMoKTtcblx0XHRcdFxuXG5cdFx0XHRpZihfaGFzaENoYW5nZWRCeUhpc3RvcnkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZighX2hpc3RvcnlDaGFuZ2VkKSB7XG5cdFx0XHRcdF91cGRhdGVIYXNoKCk7IC8vIGZpcnN0IHRpbWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdF9oaXN0b3J5VXBkYXRlVGltZW91dCA9IHNldFRpbWVvdXQoX3VwZGF0ZUhhc2gsIDgwMCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0fVxufSk7XG5cblxuLyo+Pmhpc3RvcnkqL1xuXHRmcmFtZXdvcmsuZXh0ZW5kKHNlbGYsIHB1YmxpY01ldGhvZHMpOyB9O1xuXHRyZXR1cm4gUGhvdG9Td2lwZTtcbn0pOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/photoswipe/dist/photoswipe.js\n");

/***/ }),

/***/ "./node_modules/photoswipe/src/js/ui/photoswipe-ui-default.js":
/*!********************************************************************!*\
  !*** ./node_modules/photoswipe/src/js/ui/photoswipe-ui-default.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n*\n* UI on top of main sliding area (caption, arrows, close button, etc.).\n* Built just using public methods/properties of PhotoSwipe.\n* \n*/\n(function (root, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(this, function () {\n  'use strict';\n\n  var PhotoSwipeUI_Default = function (pswp, framework) {\n    var ui = this;\n\n    var _overlayUIUpdated = false,\n        _controlsVisible = true,\n        _fullscrenAPI,\n        _controls,\n        _captionContainer,\n        _fakeCaptionContainer,\n        _indexIndicator,\n        _shareButton,\n        _shareModal,\n        _shareModalHidden = true,\n        _initalCloseOnScrollValue,\n        _isIdle,\n        _listen,\n        _loadingIndicator,\n        _loadingIndicatorHidden,\n        _loadingIndicatorTimeout,\n        _galleryHasOneSlide,\n        _options,\n        _defaultUIOptions = {\n      barsSize: {\n        top: 44,\n        bottom: 'auto'\n      },\n      closeElClasses: ['item', 'caption', 'zoom-wrap', 'ui', 'top-bar'],\n      timeToIdle: 4000,\n      timeToIdleOutside: 1000,\n      loadingIndicatorDelay: 1000,\n      // 2s\n      addCaptionHTMLFn: function (item, captionEl\n      /*, isFake */\n      ) {\n        if (!item.title) {\n          captionEl.children[0].innerHTML = '';\n          return false;\n        }\n\n        captionEl.children[0].innerHTML = item.title;\n        return true;\n      },\n      closeEl: true,\n      captionEl: true,\n      fullscreenEl: true,\n      zoomEl: true,\n      shareEl: true,\n      counterEl: true,\n      arrowEl: true,\n      preloaderEl: true,\n      tapToClose: false,\n      tapToToggleControls: true,\n      clickToCloseNonZoomable: true,\n      shareButtons: [{\n        id: 'facebook',\n        label: 'Share on Facebook',\n        url: 'https://www.facebook.com/sharer/sharer.php?u={{url}}'\n      }, {\n        id: 'twitter',\n        label: 'Tweet',\n        url: 'https://twitter.com/intent/tweet?text={{text}}&url={{url}}'\n      }, {\n        id: 'pinterest',\n        label: 'Pin it',\n        url: 'http://www.pinterest.com/pin/create/button/' + '?url={{url}}&media={{image_url}}&description={{text}}'\n      }, {\n        id: 'download',\n        label: 'Download image',\n        url: '{{raw_image_url}}',\n        download: true\n      }],\n      getImageURLForShare: function ()\n      /* shareButtonData */\n      {\n        return pswp.currItem.src || '';\n      },\n      getPageURLForShare: function ()\n      /* shareButtonData */\n      {\n        return window.location.href;\n      },\n      getTextForShare: function ()\n      /* shareButtonData */\n      {\n        return pswp.currItem.title || '';\n      },\n      indexIndicatorSep: ' / ',\n      fitControlsWidth: 1200\n    },\n        _blockControlsTap,\n        _blockControlsTapTimeout;\n\n    var _onControlsTap = function (e) {\n      if (_blockControlsTap) {\n        return true;\n      }\n\n      e = e || window.event;\n\n      if (_options.timeToIdle && _options.mouseUsed && !_isIdle) {\n        // reset idle timer\n        _onIdleMouseMove();\n      }\n\n      var target = e.target || e.srcElement,\n          uiElement,\n          clickedClass = target.getAttribute('class') || '',\n          found;\n\n      for (var i = 0; i < _uiElements.length; i++) {\n        uiElement = _uiElements[i];\n\n        if (uiElement.onTap && clickedClass.indexOf('pswp__' + uiElement.name) > -1) {\n          uiElement.onTap();\n          found = true;\n        }\n      }\n\n      if (found) {\n        if (e.stopPropagation) {\n          e.stopPropagation();\n        }\n\n        _blockControlsTap = true; // Some versions of Android don't prevent ghost click event \n        // when preventDefault() was called on touchstart and/or touchend.\n        // \n        // This happens on v4.3, 4.2, 4.1, \n        // older versions strangely work correctly, \n        // but just in case we add delay on all of them)\t\n\n        var tapDelay = framework.features.isOldAndroid ? 600 : 30;\n        _blockControlsTapTimeout = setTimeout(function () {\n          _blockControlsTap = false;\n        }, tapDelay);\n      }\n    },\n        _fitControlsInViewport = function () {\n      return !pswp.likelyTouchDevice || _options.mouseUsed || screen.width > _options.fitControlsWidth;\n    },\n        _togglePswpClass = function (el, cName, add) {\n      framework[(add ? 'add' : 'remove') + 'Class'](el, 'pswp__' + cName);\n    },\n        // add class when there is just one item in the gallery\n    // (by default it hides left/right arrows and 1ofX counter)\n    _countNumItems = function () {\n      var hasOneSlide = _options.getNumItemsFn() === 1;\n\n      if (hasOneSlide !== _galleryHasOneSlide) {\n        _togglePswpClass(_controls, 'ui--one-slide', hasOneSlide);\n\n        _galleryHasOneSlide = hasOneSlide;\n      }\n    },\n        _toggleShareModalClass = function () {\n      _togglePswpClass(_shareModal, 'share-modal--hidden', _shareModalHidden);\n    },\n        _toggleShareModal = function () {\n      _shareModalHidden = !_shareModalHidden;\n\n      if (!_shareModalHidden) {\n        _toggleShareModalClass();\n\n        setTimeout(function () {\n          if (!_shareModalHidden) {\n            framework.addClass(_shareModal, 'pswp__share-modal--fade-in');\n          }\n        }, 30);\n      } else {\n        framework.removeClass(_shareModal, 'pswp__share-modal--fade-in');\n        setTimeout(function () {\n          if (_shareModalHidden) {\n            _toggleShareModalClass();\n          }\n        }, 300);\n      }\n\n      if (!_shareModalHidden) {\n        _updateShareURLs();\n      }\n\n      return false;\n    },\n        _openWindowPopup = function (e) {\n      e = e || window.event;\n      var target = e.target || e.srcElement;\n      pswp.shout('shareLinkClick', e, target);\n\n      if (!target.href) {\n        return false;\n      }\n\n      if (target.hasAttribute('download')) {\n        return true;\n      }\n\n      window.open(target.href, 'pswp_share', 'scrollbars=yes,resizable=yes,toolbar=no,' + 'location=yes,width=550,height=420,top=100,left=' + (window.screen ? Math.round(screen.width / 2 - 275) : 100));\n\n      if (!_shareModalHidden) {\n        _toggleShareModal();\n      }\n\n      return false;\n    },\n        _updateShareURLs = function () {\n      var shareButtonOut = '',\n          shareButtonData,\n          shareURL,\n          image_url,\n          page_url,\n          share_text;\n\n      for (var i = 0; i < _options.shareButtons.length; i++) {\n        shareButtonData = _options.shareButtons[i];\n        image_url = _options.getImageURLForShare(shareButtonData);\n        page_url = _options.getPageURLForShare(shareButtonData);\n        share_text = _options.getTextForShare(shareButtonData);\n        shareURL = shareButtonData.url.replace('{{url}}', encodeURIComponent(page_url)).replace('{{image_url}}', encodeURIComponent(image_url)).replace('{{raw_image_url}}', image_url).replace('{{text}}', encodeURIComponent(share_text));\n        shareButtonOut += '<a href=\"' + shareURL + '\" target=\"_blank\" ' + 'class=\"pswp__share--' + shareButtonData.id + '\"' + (shareButtonData.download ? 'download' : '') + '>' + shareButtonData.label + '</a>';\n\n        if (_options.parseShareButtonOut) {\n          shareButtonOut = _options.parseShareButtonOut(shareButtonData, shareButtonOut);\n        }\n      }\n\n      _shareModal.children[0].innerHTML = shareButtonOut;\n      _shareModal.children[0].onclick = _openWindowPopup;\n    },\n        _hasCloseClass = function (target) {\n      for (var i = 0; i < _options.closeElClasses.length; i++) {\n        if (framework.hasClass(target, 'pswp__' + _options.closeElClasses[i])) {\n          return true;\n        }\n      }\n    },\n        _idleInterval,\n        _idleTimer,\n        _idleIncrement = 0,\n        _onIdleMouseMove = function () {\n      clearTimeout(_idleTimer);\n      _idleIncrement = 0;\n\n      if (_isIdle) {\n        ui.setIdle(false);\n      }\n    },\n        _onMouseLeaveWindow = function (e) {\n      e = e ? e : window.event;\n      var from = e.relatedTarget || e.toElement;\n\n      if (!from || from.nodeName === 'HTML') {\n        clearTimeout(_idleTimer);\n        _idleTimer = setTimeout(function () {\n          ui.setIdle(true);\n        }, _options.timeToIdleOutside);\n      }\n    },\n        _setupFullscreenAPI = function () {\n      if (_options.fullscreenEl && !framework.features.isOldAndroid) {\n        if (!_fullscrenAPI) {\n          _fullscrenAPI = ui.getFullscreenAPI();\n        }\n\n        if (_fullscrenAPI) {\n          framework.bind(document, _fullscrenAPI.eventK, ui.updateFullscreen);\n          ui.updateFullscreen();\n          framework.addClass(pswp.template, 'pswp--supports-fs');\n        } else {\n          framework.removeClass(pswp.template, 'pswp--supports-fs');\n        }\n      }\n    },\n        _setupLoadingIndicator = function () {\n      // Setup loading indicator\n      if (_options.preloaderEl) {\n        _toggleLoadingIndicator(true);\n\n        _listen('beforeChange', function () {\n          clearTimeout(_loadingIndicatorTimeout); // display loading indicator with delay\n\n          _loadingIndicatorTimeout = setTimeout(function () {\n            if (pswp.currItem && pswp.currItem.loading) {\n              if (!pswp.allowProgressiveImg() || pswp.currItem.img && !pswp.currItem.img.naturalWidth) {\n                // show preloader if progressive loading is not enabled, \n                // or image width is not defined yet (because of slow connection)\n                _toggleLoadingIndicator(false); // items-controller.js function allowProgressiveImg\n\n              }\n            } else {\n              _toggleLoadingIndicator(true); // hide preloader\n\n            }\n          }, _options.loadingIndicatorDelay);\n        });\n\n        _listen('imageLoadComplete', function (index, item) {\n          if (pswp.currItem === item) {\n            _toggleLoadingIndicator(true);\n          }\n        });\n      }\n    },\n        _toggleLoadingIndicator = function (hide) {\n      if (_loadingIndicatorHidden !== hide) {\n        _togglePswpClass(_loadingIndicator, 'preloader--active', !hide);\n\n        _loadingIndicatorHidden = hide;\n      }\n    },\n        _applyNavBarGaps = function (item) {\n      var gap = item.vGap;\n\n      if (_fitControlsInViewport()) {\n        var bars = _options.barsSize;\n\n        if (_options.captionEl && bars.bottom === 'auto') {\n          if (!_fakeCaptionContainer) {\n            _fakeCaptionContainer = framework.createEl('pswp__caption pswp__caption--fake');\n\n            _fakeCaptionContainer.appendChild(framework.createEl('pswp__caption__center'));\n\n            _controls.insertBefore(_fakeCaptionContainer, _captionContainer);\n\n            framework.addClass(_controls, 'pswp__ui--fit');\n          }\n\n          if (_options.addCaptionHTMLFn(item, _fakeCaptionContainer, true)) {\n            var captionSize = _fakeCaptionContainer.clientHeight;\n            gap.bottom = parseInt(captionSize, 10) || 44;\n          } else {\n            gap.bottom = bars.top; // if no caption, set size of bottom gap to size of top\n          }\n        } else {\n          gap.bottom = bars.bottom === 'auto' ? 0 : bars.bottom;\n        } // height of top bar is static, no need to calculate it\n\n\n        gap.top = bars.top;\n      } else {\n        gap.top = gap.bottom = 0;\n      }\n    },\n        _setupIdle = function () {\n      // Hide controls when mouse is used\n      if (_options.timeToIdle) {\n        _listen('mouseUsed', function () {\n          framework.bind(document, 'mousemove', _onIdleMouseMove);\n          framework.bind(document, 'mouseout', _onMouseLeaveWindow);\n          _idleInterval = setInterval(function () {\n            _idleIncrement++;\n\n            if (_idleIncrement === 2) {\n              ui.setIdle(true);\n            }\n          }, _options.timeToIdle / 2);\n        });\n      }\n    },\n        _setupHidingControlsDuringGestures = function () {\n      // Hide controls on vertical drag\n      _listen('onVerticalDrag', function (now) {\n        if (_controlsVisible && now < 0.95) {\n          ui.hideControls();\n        } else if (!_controlsVisible && now >= 0.95) {\n          ui.showControls();\n        }\n      }); // Hide controls when pinching to close\n\n\n      var pinchControlsHidden;\n\n      _listen('onPinchClose', function (now) {\n        if (_controlsVisible && now < 0.9) {\n          ui.hideControls();\n          pinchControlsHidden = true;\n        } else if (pinchControlsHidden && !_controlsVisible && now > 0.9) {\n          ui.showControls();\n        }\n      });\n\n      _listen('zoomGestureEnded', function () {\n        pinchControlsHidden = false;\n\n        if (pinchControlsHidden && !_controlsVisible) {\n          ui.showControls();\n        }\n      });\n    };\n\n    var _uiElements = [{\n      name: 'caption',\n      option: 'captionEl',\n      onInit: function (el) {\n        _captionContainer = el;\n      }\n    }, {\n      name: 'share-modal',\n      option: 'shareEl',\n      onInit: function (el) {\n        _shareModal = el;\n      },\n      onTap: function () {\n        _toggleShareModal();\n      }\n    }, {\n      name: 'button--share',\n      option: 'shareEl',\n      onInit: function (el) {\n        _shareButton = el;\n      },\n      onTap: function () {\n        _toggleShareModal();\n      }\n    }, {\n      name: 'button--zoom',\n      option: 'zoomEl',\n      onTap: pswp.toggleDesktopZoom\n    }, {\n      name: 'counter',\n      option: 'counterEl',\n      onInit: function (el) {\n        _indexIndicator = el;\n      }\n    }, {\n      name: 'button--close',\n      option: 'closeEl',\n      onTap: pswp.close\n    }, {\n      name: 'button--arrow--left',\n      option: 'arrowEl',\n      onTap: pswp.prev\n    }, {\n      name: 'button--arrow--right',\n      option: 'arrowEl',\n      onTap: pswp.next\n    }, {\n      name: 'button--fs',\n      option: 'fullscreenEl',\n      onTap: function () {\n        if (_fullscrenAPI.isFullscreen()) {\n          _fullscrenAPI.exit();\n        } else {\n          _fullscrenAPI.enter();\n        }\n      }\n    }, {\n      name: 'preloader',\n      option: 'preloaderEl',\n      onInit: function (el) {\n        _loadingIndicator = el;\n      }\n    }];\n\n    var _setupUIElements = function () {\n      var item, classAttr, uiElement;\n\n      var loopThroughChildElements = function (sChildren) {\n        if (!sChildren) {\n          return;\n        }\n\n        var l = sChildren.length;\n\n        for (var i = 0; i < l; i++) {\n          item = sChildren[i];\n          classAttr = item.className;\n\n          for (var a = 0; a < _uiElements.length; a++) {\n            uiElement = _uiElements[a];\n\n            if (classAttr.indexOf('pswp__' + uiElement.name) > -1) {\n              if (_options[uiElement.option]) {\n                // if element is not disabled from options\n                framework.removeClass(item, 'pswp__element--disabled');\n\n                if (uiElement.onInit) {\n                  uiElement.onInit(item);\n                } //item.style.display = 'block';\n\n              } else {\n                framework.addClass(item, 'pswp__element--disabled'); //item.style.display = 'none';\n              }\n            }\n          }\n        }\n      };\n\n      loopThroughChildElements(_controls.children);\n      var topBar = framework.getChildByClass(_controls, 'pswp__top-bar');\n\n      if (topBar) {\n        loopThroughChildElements(topBar.children);\n      }\n    };\n\n    ui.init = function () {\n      // extend options\n      framework.extend(pswp.options, _defaultUIOptions, true); // create local link for fast access\n\n      _options = pswp.options; // find pswp__ui element\n\n      _controls = framework.getChildByClass(pswp.scrollWrap, 'pswp__ui'); // create local link\n\n      _listen = pswp.listen;\n\n      _setupHidingControlsDuringGestures(); // update controls when slides change\n\n\n      _listen('beforeChange', ui.update); // toggle zoom on double-tap\n\n\n      _listen('doubleTap', function (point) {\n        var initialZoomLevel = pswp.currItem.initialZoomLevel;\n\n        if (pswp.getZoomLevel() !== initialZoomLevel) {\n          pswp.zoomTo(initialZoomLevel, point, 333);\n        } else {\n          pswp.zoomTo(_options.getDoubleTapZoom(false, pswp.currItem), point, 333);\n        }\n      }); // Allow text selection in caption\n\n\n      _listen('preventDragEvent', function (e, isDown, preventObj) {\n        var t = e.target || e.srcElement;\n\n        if (t && t.getAttribute('class') && e.type.indexOf('mouse') > -1 && (t.getAttribute('class').indexOf('__caption') > 0 || /(SMALL|STRONG|EM)/i.test(t.tagName))) {\n          preventObj.prevent = false;\n        }\n      }); // bind events for UI\n\n\n      _listen('bindEvents', function () {\n        framework.bind(_controls, 'pswpTap click', _onControlsTap);\n        framework.bind(pswp.scrollWrap, 'pswpTap', ui.onGlobalTap);\n\n        if (!pswp.likelyTouchDevice) {\n          framework.bind(pswp.scrollWrap, 'mouseover', ui.onMouseOver);\n        }\n      }); // unbind events for UI\n\n\n      _listen('unbindEvents', function () {\n        if (!_shareModalHidden) {\n          _toggleShareModal();\n        }\n\n        if (_idleInterval) {\n          clearInterval(_idleInterval);\n        }\n\n        framework.unbind(document, 'mouseout', _onMouseLeaveWindow);\n        framework.unbind(document, 'mousemove', _onIdleMouseMove);\n        framework.unbind(_controls, 'pswpTap click', _onControlsTap);\n        framework.unbind(pswp.scrollWrap, 'pswpTap', ui.onGlobalTap);\n        framework.unbind(pswp.scrollWrap, 'mouseover', ui.onMouseOver);\n\n        if (_fullscrenAPI) {\n          framework.unbind(document, _fullscrenAPI.eventK, ui.updateFullscreen);\n\n          if (_fullscrenAPI.isFullscreen()) {\n            _options.hideAnimationDuration = 0;\n\n            _fullscrenAPI.exit();\n          }\n\n          _fullscrenAPI = null;\n        }\n      }); // clean up things when gallery is destroyed\n\n\n      _listen('destroy', function () {\n        if (_options.captionEl) {\n          if (_fakeCaptionContainer) {\n            _controls.removeChild(_fakeCaptionContainer);\n          }\n\n          framework.removeClass(_captionContainer, 'pswp__caption--empty');\n        }\n\n        if (_shareModal) {\n          _shareModal.children[0].onclick = null;\n        }\n\n        framework.removeClass(_controls, 'pswp__ui--over-close');\n        framework.addClass(_controls, 'pswp__ui--hidden');\n        ui.setIdle(false);\n      });\n\n      if (!_options.showAnimationDuration) {\n        framework.removeClass(_controls, 'pswp__ui--hidden');\n      }\n\n      _listen('initialZoomIn', function () {\n        if (_options.showAnimationDuration) {\n          framework.removeClass(_controls, 'pswp__ui--hidden');\n        }\n      });\n\n      _listen('initialZoomOut', function () {\n        framework.addClass(_controls, 'pswp__ui--hidden');\n      });\n\n      _listen('parseVerticalMargin', _applyNavBarGaps);\n\n      _setupUIElements();\n\n      if (_options.shareEl && _shareButton && _shareModal) {\n        _shareModalHidden = true;\n      }\n\n      _countNumItems();\n\n      _setupIdle();\n\n      _setupFullscreenAPI();\n\n      _setupLoadingIndicator();\n    };\n\n    ui.setIdle = function (isIdle) {\n      _isIdle = isIdle;\n\n      _togglePswpClass(_controls, 'ui--idle', isIdle);\n    };\n\n    ui.update = function () {\n      // Don't update UI if it's hidden\n      if (_controlsVisible && pswp.currItem) {\n        ui.updateIndexIndicator();\n\n        if (_options.captionEl) {\n          _options.addCaptionHTMLFn(pswp.currItem, _captionContainer);\n\n          _togglePswpClass(_captionContainer, 'caption--empty', !pswp.currItem.title);\n        }\n\n        _overlayUIUpdated = true;\n      } else {\n        _overlayUIUpdated = false;\n      }\n\n      if (!_shareModalHidden) {\n        _toggleShareModal();\n      }\n\n      _countNumItems();\n    };\n\n    ui.updateFullscreen = function (e) {\n      if (e) {\n        // some browsers change window scroll position during the fullscreen\n        // so PhotoSwipe updates it just in case\n        setTimeout(function () {\n          pswp.setScrollOffset(0, framework.getScrollY());\n        }, 50);\n      } // toogle pswp--fs class on root element\n\n\n      framework[(_fullscrenAPI.isFullscreen() ? 'add' : 'remove') + 'Class'](pswp.template, 'pswp--fs');\n    };\n\n    ui.updateIndexIndicator = function () {\n      if (_options.counterEl) {\n        _indexIndicator.innerHTML = pswp.getCurrentIndex() + 1 + _options.indexIndicatorSep + _options.getNumItemsFn();\n      }\n    };\n\n    ui.onGlobalTap = function (e) {\n      e = e || window.event;\n      var target = e.target || e.srcElement;\n\n      if (_blockControlsTap) {\n        return;\n      }\n\n      if (e.detail && e.detail.pointerType === 'mouse') {\n        // close gallery if clicked outside of the image\n        if (_hasCloseClass(target)) {\n          pswp.close();\n          return;\n        }\n\n        if (framework.hasClass(target, 'pswp__img')) {\n          if (pswp.getZoomLevel() === 1 && pswp.getZoomLevel() <= pswp.currItem.fitRatio) {\n            if (_options.clickToCloseNonZoomable) {\n              pswp.close();\n            }\n          } else {\n            pswp.toggleDesktopZoom(e.detail.releasePoint);\n          }\n        }\n      } else {\n        // tap anywhere (except buttons) to toggle visibility of controls\n        if (_options.tapToToggleControls) {\n          if (_controlsVisible) {\n            ui.hideControls();\n          } else {\n            ui.showControls();\n          }\n        } // tap to close gallery\n\n\n        if (_options.tapToClose && (framework.hasClass(target, 'pswp__img') || _hasCloseClass(target))) {\n          pswp.close();\n          return;\n        }\n      }\n    };\n\n    ui.onMouseOver = function (e) {\n      e = e || window.event;\n      var target = e.target || e.srcElement; // add class when mouse is over an element that should close the gallery\n\n      _togglePswpClass(_controls, 'ui--over-close', _hasCloseClass(target));\n    };\n\n    ui.hideControls = function () {\n      framework.addClass(_controls, 'pswp__ui--hidden');\n      _controlsVisible = false;\n    };\n\n    ui.showControls = function () {\n      _controlsVisible = true;\n\n      if (!_overlayUIUpdated) {\n        ui.update();\n      }\n\n      framework.removeClass(_controls, 'pswp__ui--hidden');\n    };\n\n    ui.supportsFullscreen = function () {\n      var d = document;\n      return !!(d.exitFullscreen || d.mozCancelFullScreen || d.webkitExitFullscreen || d.msExitFullscreen);\n    };\n\n    ui.getFullscreenAPI = function () {\n      var dE = document.documentElement,\n          api,\n          tF = 'fullscreenchange';\n\n      if (dE.requestFullscreen) {\n        api = {\n          enterK: 'requestFullscreen',\n          exitK: 'exitFullscreen',\n          elementK: 'fullscreenElement',\n          eventK: tF\n        };\n      } else if (dE.mozRequestFullScreen) {\n        api = {\n          enterK: 'mozRequestFullScreen',\n          exitK: 'mozCancelFullScreen',\n          elementK: 'mozFullScreenElement',\n          eventK: 'moz' + tF\n        };\n      } else if (dE.webkitRequestFullscreen) {\n        api = {\n          enterK: 'webkitRequestFullscreen',\n          exitK: 'webkitExitFullscreen',\n          elementK: 'webkitFullscreenElement',\n          eventK: 'webkit' + tF\n        };\n      } else if (dE.msRequestFullscreen) {\n        api = {\n          enterK: 'msRequestFullscreen',\n          exitK: 'msExitFullscreen',\n          elementK: 'msFullscreenElement',\n          eventK: 'MSFullscreenChange'\n        };\n      }\n\n      if (api) {\n        api.enter = function () {\n          // disable close-on-scroll in fullscreen\n          _initalCloseOnScrollValue = _options.closeOnScroll;\n          _options.closeOnScroll = false;\n\n          if (this.enterK === 'webkitRequestFullscreen') {\n            pswp.template[this.enterK](Element.ALLOW_KEYBOARD_INPUT);\n          } else {\n            return pswp.template[this.enterK]();\n          }\n        };\n\n        api.exit = function () {\n          _options.closeOnScroll = _initalCloseOnScrollValue;\n          return document[this.exitK]();\n        };\n\n        api.isFullscreen = function () {\n          return document[this.elementK];\n        };\n      }\n\n      return api;\n    };\n  };\n\n  return PhotoSwipeUI_Default;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGhvdG9zd2lwZS9zcmMvanMvdWkvcGhvdG9zd2lwZS11aS1kZWZhdWx0LmpzPzIxZDgiXSwibmFtZXMiOlsicm9vdCIsImZhY3RvcnkiLCJkZWZpbmUiLCJQaG90b1N3aXBlVUlfRGVmYXVsdCIsInBzd3AiLCJmcmFtZXdvcmsiLCJ1aSIsIl9vdmVybGF5VUlVcGRhdGVkIiwiX2NvbnRyb2xzVmlzaWJsZSIsIl9mdWxsc2NyZW5BUEkiLCJfY29udHJvbHMiLCJfY2FwdGlvbkNvbnRhaW5lciIsIl9mYWtlQ2FwdGlvbkNvbnRhaW5lciIsIl9pbmRleEluZGljYXRvciIsIl9zaGFyZUJ1dHRvbiIsIl9zaGFyZU1vZGFsIiwiX3NoYXJlTW9kYWxIaWRkZW4iLCJfaW5pdGFsQ2xvc2VPblNjcm9sbFZhbHVlIiwiX2lzSWRsZSIsIl9saXN0ZW4iLCJfbG9hZGluZ0luZGljYXRvciIsIl9sb2FkaW5nSW5kaWNhdG9ySGlkZGVuIiwiX2xvYWRpbmdJbmRpY2F0b3JUaW1lb3V0IiwiX2dhbGxlcnlIYXNPbmVTbGlkZSIsIl9vcHRpb25zIiwiX2RlZmF1bHRVSU9wdGlvbnMiLCJiYXJzU2l6ZSIsInRvcCIsImJvdHRvbSIsImNsb3NlRWxDbGFzc2VzIiwidGltZVRvSWRsZSIsInRpbWVUb0lkbGVPdXRzaWRlIiwibG9hZGluZ0luZGljYXRvckRlbGF5IiwiYWRkQ2FwdGlvbkhUTUxGbiIsIml0ZW0iLCJjYXB0aW9uRWwiLCJ0aXRsZSIsImNoaWxkcmVuIiwiaW5uZXJIVE1MIiwiY2xvc2VFbCIsImZ1bGxzY3JlZW5FbCIsInpvb21FbCIsInNoYXJlRWwiLCJjb3VudGVyRWwiLCJhcnJvd0VsIiwicHJlbG9hZGVyRWwiLCJ0YXBUb0Nsb3NlIiwidGFwVG9Ub2dnbGVDb250cm9scyIsImNsaWNrVG9DbG9zZU5vblpvb21hYmxlIiwic2hhcmVCdXR0b25zIiwiaWQiLCJsYWJlbCIsInVybCIsImRvd25sb2FkIiwiZ2V0SW1hZ2VVUkxGb3JTaGFyZSIsImN1cnJJdGVtIiwic3JjIiwiZ2V0UGFnZVVSTEZvclNoYXJlIiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwiZ2V0VGV4dEZvclNoYXJlIiwiaW5kZXhJbmRpY2F0b3JTZXAiLCJmaXRDb250cm9sc1dpZHRoIiwiX2Jsb2NrQ29udHJvbHNUYXAiLCJfYmxvY2tDb250cm9sc1RhcFRpbWVvdXQiLCJfb25Db250cm9sc1RhcCIsImUiLCJldmVudCIsIm1vdXNlVXNlZCIsIl9vbklkbGVNb3VzZU1vdmUiLCJ0YXJnZXQiLCJzcmNFbGVtZW50IiwidWlFbGVtZW50IiwiY2xpY2tlZENsYXNzIiwiZ2V0QXR0cmlidXRlIiwiZm91bmQiLCJpIiwiX3VpRWxlbWVudHMiLCJsZW5ndGgiLCJvblRhcCIsImluZGV4T2YiLCJuYW1lIiwic3RvcFByb3BhZ2F0aW9uIiwidGFwRGVsYXkiLCJmZWF0dXJlcyIsImlzT2xkQW5kcm9pZCIsInNldFRpbWVvdXQiLCJfZml0Q29udHJvbHNJblZpZXdwb3J0IiwibGlrZWx5VG91Y2hEZXZpY2UiLCJzY3JlZW4iLCJ3aWR0aCIsIl90b2dnbGVQc3dwQ2xhc3MiLCJlbCIsImNOYW1lIiwiYWRkIiwiX2NvdW50TnVtSXRlbXMiLCJoYXNPbmVTbGlkZSIsImdldE51bUl0ZW1zRm4iLCJfdG9nZ2xlU2hhcmVNb2RhbENsYXNzIiwiX3RvZ2dsZVNoYXJlTW9kYWwiLCJhZGRDbGFzcyIsInJlbW92ZUNsYXNzIiwiX3VwZGF0ZVNoYXJlVVJMcyIsIl9vcGVuV2luZG93UG9wdXAiLCJzaG91dCIsImhhc0F0dHJpYnV0ZSIsIm9wZW4iLCJNYXRoIiwicm91bmQiLCJzaGFyZUJ1dHRvbk91dCIsInNoYXJlQnV0dG9uRGF0YSIsInNoYXJlVVJMIiwiaW1hZ2VfdXJsIiwicGFnZV91cmwiLCJzaGFyZV90ZXh0IiwicmVwbGFjZSIsImVuY29kZVVSSUNvbXBvbmVudCIsInBhcnNlU2hhcmVCdXR0b25PdXQiLCJvbmNsaWNrIiwiX2hhc0Nsb3NlQ2xhc3MiLCJoYXNDbGFzcyIsIl9pZGxlSW50ZXJ2YWwiLCJfaWRsZVRpbWVyIiwiX2lkbGVJbmNyZW1lbnQiLCJjbGVhclRpbWVvdXQiLCJzZXRJZGxlIiwiX29uTW91c2VMZWF2ZVdpbmRvdyIsImZyb20iLCJyZWxhdGVkVGFyZ2V0IiwidG9FbGVtZW50Iiwibm9kZU5hbWUiLCJfc2V0dXBGdWxsc2NyZWVuQVBJIiwiZ2V0RnVsbHNjcmVlbkFQSSIsImJpbmQiLCJkb2N1bWVudCIsImV2ZW50SyIsInVwZGF0ZUZ1bGxzY3JlZW4iLCJ0ZW1wbGF0ZSIsIl9zZXR1cExvYWRpbmdJbmRpY2F0b3IiLCJfdG9nZ2xlTG9hZGluZ0luZGljYXRvciIsImxvYWRpbmciLCJhbGxvd1Byb2dyZXNzaXZlSW1nIiwiaW1nIiwibmF0dXJhbFdpZHRoIiwiaW5kZXgiLCJoaWRlIiwiX2FwcGx5TmF2QmFyR2FwcyIsImdhcCIsInZHYXAiLCJiYXJzIiwiY3JlYXRlRWwiLCJhcHBlbmRDaGlsZCIsImluc2VydEJlZm9yZSIsImNhcHRpb25TaXplIiwiY2xpZW50SGVpZ2h0IiwicGFyc2VJbnQiLCJfc2V0dXBJZGxlIiwic2V0SW50ZXJ2YWwiLCJfc2V0dXBIaWRpbmdDb250cm9sc0R1cmluZ0dlc3R1cmVzIiwibm93IiwiaGlkZUNvbnRyb2xzIiwic2hvd0NvbnRyb2xzIiwicGluY2hDb250cm9sc0hpZGRlbiIsIm9wdGlvbiIsIm9uSW5pdCIsInRvZ2dsZURlc2t0b3Bab29tIiwiY2xvc2UiLCJwcmV2IiwibmV4dCIsImlzRnVsbHNjcmVlbiIsImV4aXQiLCJlbnRlciIsIl9zZXR1cFVJRWxlbWVudHMiLCJjbGFzc0F0dHIiLCJsb29wVGhyb3VnaENoaWxkRWxlbWVudHMiLCJzQ2hpbGRyZW4iLCJsIiwiY2xhc3NOYW1lIiwiYSIsInRvcEJhciIsImdldENoaWxkQnlDbGFzcyIsImluaXQiLCJleHRlbmQiLCJvcHRpb25zIiwic2Nyb2xsV3JhcCIsImxpc3RlbiIsInVwZGF0ZSIsInBvaW50IiwiaW5pdGlhbFpvb21MZXZlbCIsImdldFpvb21MZXZlbCIsInpvb21UbyIsImdldERvdWJsZVRhcFpvb20iLCJpc0Rvd24iLCJwcmV2ZW50T2JqIiwidCIsInR5cGUiLCJ0ZXN0IiwidGFnTmFtZSIsInByZXZlbnQiLCJvbkdsb2JhbFRhcCIsIm9uTW91c2VPdmVyIiwiY2xlYXJJbnRlcnZhbCIsInVuYmluZCIsImhpZGVBbmltYXRpb25EdXJhdGlvbiIsInJlbW92ZUNoaWxkIiwic2hvd0FuaW1hdGlvbkR1cmF0aW9uIiwiaXNJZGxlIiwidXBkYXRlSW5kZXhJbmRpY2F0b3IiLCJzZXRTY3JvbGxPZmZzZXQiLCJnZXRTY3JvbGxZIiwiZ2V0Q3VycmVudEluZGV4IiwiZGV0YWlsIiwicG9pbnRlclR5cGUiLCJmaXRSYXRpbyIsInJlbGVhc2VQb2ludCIsInN1cHBvcnRzRnVsbHNjcmVlbiIsImQiLCJleGl0RnVsbHNjcmVlbiIsIm1vekNhbmNlbEZ1bGxTY3JlZW4iLCJ3ZWJraXRFeGl0RnVsbHNjcmVlbiIsIm1zRXhpdEZ1bGxzY3JlZW4iLCJkRSIsImRvY3VtZW50RWxlbWVudCIsImFwaSIsInRGIiwicmVxdWVzdEZ1bGxzY3JlZW4iLCJlbnRlcksiLCJleGl0SyIsImVsZW1lbnRLIiwibW96UmVxdWVzdEZ1bGxTY3JlZW4iLCJ3ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbiIsIm1zUmVxdWVzdEZ1bGxzY3JlZW4iLCJjbG9zZU9uU2Nyb2xsIiwiRWxlbWVudCIsIkFMTE9XX0tFWUJPQVJEX0lOUFVUIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0FBTUEsQ0FBQyxVQUFVQSxJQUFWLEVBQWdCQyxPQUFoQixFQUF5QjtBQUN6QixNQUFJLElBQUosRUFBZ0Q7QUFDL0NDLHdDQUFPRCxPQUFEO0FBQUE7QUFBQTtBQUFBO0FBQUEsb0dBQU47QUFDQSxHQUZELE1BRU8sRUFJTjtBQUNELENBUkQsRUFRRyxJQVJILEVBUVMsWUFBWTtBQUVwQjs7QUFJRCxNQUFJRSxvQkFBb0IsR0FDdkIsVUFBU0MsSUFBVCxFQUFlQyxTQUFmLEVBQTBCO0FBRTFCLFFB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LEVBQUUscUJBREg7QUFFTEMsZUFBSyxFQUFFLGtCQUZGO0FBR0xDLGtCQUFRLEVBQUUscUJBSEw7QUFJTDdGLGdCQUFNLEVBQUU7QUFKSCxTQUFOO0FBTUE7O0FBRUQsVUFBR3dGLEdBQUgsRUFBUTtBQUNQQSxXQUFHLENBQUNwRCxLQUFKLEdBQVksWUFBVztBQUN0QjtBQUNBM0osbUNBQXlCLEdBQUdPLFFBQVEsQ0FBQ2lOLGFBQXJDO0FBQ0FqTixrQkFBUSxDQUFDaU4sYUFBVCxHQUF5QixLQUF6Qjs7QUFFQSxjQUFHLEtBQUtOLE1BQUwsS0FBZ0IseUJBQW5CLEVBQThDO0FBQzdDL04sZ0JBQUksQ0FBQ3NJLFFBQUwsQ0FBYyxLQUFLeUYsTUFBbkIsRUFBNEJPLE9BQU8sQ0FBQ0Msb0JBQXBDO0FBQ0EsV0FGRCxNQUVPO0FBQ04sbUJBQU92TyxJQUFJLENBQUNzSSxRQUFMLENBQWMsS0FBS3lGLE1BQW5CLEdBQVA7QUFDQTtBQUNELFNBVkQ7O0FBV0FILFdBQUcsQ0FBQ3JELElBQUosR0FBVyxZQUFXO0FBQ3JCbkosa0JBQVEsQ0FBQ2lOLGFBQVQsR0FBeUJ4Tix5QkFBekI7QUFFQSxpQkFBT3NILFFBQVEsQ0FBQyxLQUFLNkYsS0FBTixDQUFSLEVBQVA7QUFFQSxTQUxEOztBQU1BSixXQUFHLENBQUN0RCxZQUFKLEdBQW1CLFlBQVc7QUFBRSxpQkFBT25DLFFBQVEsQ0FBQyxLQUFLOEYsUUFBTixDQUFmO0FBQWlDLFNBQWpFO0FBQ0E7O0FBRUQsYUFBT0wsR0FBUDtBQUNBLEtBOUREO0FBa0VBLEdBajBCRDs7QUFrMEJBLFNBQU83TixvQkFBUDtBQUdDLENBbjFCRCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9waG90b3N3aXBlL3NyYy9qcy91aS9waG90b3N3aXBlLXVpLWRlZmF1bHQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbipcbiogVUkgb24gdG9wIG9mIG1haW4gc2xpZGluZyBhcmVhIChjYXB0aW9uLCBhcnJvd3MsIGNsb3NlIGJ1dHRvbiwgZXRjLikuXG4qIEJ1aWx0IGp1c3QgdXNpbmcgcHVibGljIG1ldGhvZHMvcHJvcGVydGllcyBvZiBQaG90b1N3aXBlLlxuKiBcbiovXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHsgXG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0XHRkZWZpbmUoZmFjdG9yeSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH0gZWxzZSB7XG5cdFx0cm9vdC5QaG90b1N3aXBlVUlfRGVmYXVsdCA9IGZhY3RvcnkoKTtcblx0fVxufSkodGhpcywgZnVuY3Rpb24gKCkge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXG5cbnZhciBQaG90b1N3aXBlVUlfRGVmYXVsdCA9XG4gZnVuY3Rpb24ocHN3cCwgZnJhbWV3b3JrKSB7XG5cblx0dmFyIHVpID0gdGhpcztcblx0dmFyIF9vdmVybGF5VUlVcGRhdGVkID0gZmFsc2UsXG5cdFx0X2NvbnRyb2xzVmlzaWJsZSA9IHRydWUsXG5cdFx0X2Z1bGxzY3JlbkFQSSxcblx0XHRfY29udHJvbHMsXG5cdFx0X2NhcHRpb25Db250YWluZXIsXG5cdFx0X2Zha2VDYXB0aW9uQ29udGFpbmVyLFxuXHRcdF9pbmRleEluZGljYXRvcixcblx0XHRfc2hhcmVCdXR0b24sXG5cdFx0X3NoYXJlTW9kYWwsXG5cdFx0X3NoYXJlTW9kYWxIaWRkZW4gPSB0cnVlLFxuXHRcdF9pbml0YWxDbG9zZU9uU2Nyb2xsVmFsdWUsXG5cdFx0X2lzSWRsZSxcblx0XHRfbGlzdGVuLFxuXG5cdFx0X2xvYWRpbmdJbmRpY2F0b3IsXG5cdFx0X2xvYWRpbmdJbmRpY2F0b3JIaWRkZW4sXG5cdFx0X2xvYWRpbmdJbmRpY2F0b3JUaW1lb3V0LFxuXG5cdFx0X2dhbGxlcnlIYXNPbmVTbGlkZSxcblxuXHRcdF9vcHRpb25zLFxuXHRcdF9kZWZhdWx0VUlPcHRpb25zID0ge1xuXHRcdFx0YmFyc1NpemU6IHt0b3A6NDQsIGJvdHRvbTonYXV0byd9LFxuXHRcdFx0Y2xvc2VFbENsYXNzZXM6IFsnaXRlbScsICdjYXB0aW9uJywgJ3pvb20td3JhcCcsICd1aScsICd0b3AtYmFyJ10sIFxuXHRcdFx0dGltZVRvSWRsZTogNDAwMCwgXG5cdFx0XHR0aW1lVG9JZGxlT3V0c2lkZTogMTAwMCxcblx0XHRcdGxvYWRpbmdJbmRpY2F0b3JEZWxheTogMTAwMCwgLy8gMnNcblx0XHRcdFxuXHRcdFx0YWRkQ2FwdGlvbkhUTUxGbjogZnVuY3Rpb24oaXRlbSwgY2FwdGlvbkVsIC8qLCBpc0Zha2UgKi8pIHtcblx0XHRcdFx0aWYoIWl0ZW0udGl0bGUpIHtcblx0XHRcdFx0XHRjYXB0aW9uRWwuY2hpbGRyZW5bMF0uaW5uZXJIVE1MID0gJyc7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhcHRpb25FbC5jaGlsZHJlblswXS5pbm5lckhUTUwgPSBpdGVtLnRpdGxlO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0sXG5cblx0XHRcdGNsb3NlRWw6dHJ1ZSxcblx0XHRcdGNhcHRpb25FbDogdHJ1ZSxcblx0XHRcdGZ1bGxzY3JlZW5FbDogdHJ1ZSxcblx0XHRcdHpvb21FbDogdHJ1ZSxcblx0XHRcdHNoYXJlRWw6IHRydWUsXG5cdFx0XHRjb3VudGVyRWw6IHRydWUsXG5cdFx0XHRhcnJvd0VsOiB0cnVlLFxuXHRcdFx0cHJlbG9hZGVyRWw6IHRydWUsXG5cblx0XHRcdHRhcFRvQ2xvc2U6IGZhbHNlLFxuXHRcdFx0dGFwVG9Ub2dnbGVDb250cm9sczogdHJ1ZSxcblxuXHRcdFx0Y2xpY2tUb0Nsb3NlTm9uWm9vbWFibGU6IHRydWUsXG5cblx0XHRcdHNoYXJlQnV0dG9uczogW1xuXHRcdFx0XHR7aWQ6J2ZhY2Vib29rJywgbGFiZWw6J1NoYXJlIG9uIEZhY2Vib29rJywgdXJsOidodHRwczovL3d3dy5mYWNlYm9vay5jb20vc2hhcmVyL3NoYXJlci5waHA/dT17e3VybH19J30sXG5cdFx0XHRcdHtpZDondHdpdHRlcicsIGxhYmVsOidUd2VldCcsIHVybDonaHR0cHM6Ly90d2l0dGVyLmNvbS9pbnRlbnQvdHdlZXQ/dGV4dD17e3RleHR9fSZ1cmw9e3t1cmx9fSd9LFxuXHRcdFx0XHR7aWQ6J3BpbnRlcmVzdCcsIGxhYmVsOidQaW4gaXQnLCB1cmw6J2h0dHA6Ly93d3cucGludGVyZXN0LmNvbS9waW4vY3JlYXRlL2J1dHRvbi8nK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQnP3VybD17e3VybH19Jm1lZGlhPXt7aW1hZ2VfdXJsfX0mZGVzY3JpcHRpb249e3t0ZXh0fX0nfSxcblx0XHRcdFx0e2lkOidkb3dubG9hZCcsIGxhYmVsOidEb3dubG9hZCBpbWFnZScsIHVybDone3tyYXdfaW1hZ2VfdXJsfX0nLCBkb3dubG9hZDp0cnVlfVxuXHRcdFx0XSxcblx0XHRcdGdldEltYWdlVVJMRm9yU2hhcmU6IGZ1bmN0aW9uKCAvKiBzaGFyZUJ1dHRvbkRhdGEgKi8gKSB7XG5cdFx0XHRcdHJldHVybiBwc3dwLmN1cnJJdGVtLnNyYyB8fCAnJztcblx0XHRcdH0sXG5cdFx0XHRnZXRQYWdlVVJMRm9yU2hhcmU6IGZ1bmN0aW9uKCAvKiBzaGFyZUJ1dHRvbkRhdGEgKi8gKSB7XG5cdFx0XHRcdHJldHVybiB3aW5kb3cubG9jYXRpb24uaHJlZjtcblx0XHRcdH0sXG5cdFx0XHRnZXRUZXh0Rm9yU2hhcmU6IGZ1bmN0aW9uKCAvKiBzaGFyZUJ1dHRvbkRhdGEgKi8gKSB7XG5cdFx0XHRcdHJldHVybiBwc3dwLmN1cnJJdGVtLnRpdGxlIHx8ICcnO1xuXHRcdFx0fSxcblx0XHRcdFx0XG5cdFx0XHRpbmRleEluZGljYXRvclNlcDogJyAvICcsXG5cdFx0XHRmaXRDb250cm9sc1dpZHRoOiAxMjAwXG5cblx0XHR9LFxuXHRcdF9ibG9ja0NvbnRyb2xzVGFwLFxuXHRcdF9ibG9ja0NvbnRyb2xzVGFwVGltZW91dDtcblxuXG5cblx0dmFyIF9vbkNvbnRyb2xzVGFwID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0aWYoX2Jsb2NrQ29udHJvbHNUYXApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblxuXHRcdFx0ZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuXG5cdFx0XHRpZihfb3B0aW9ucy50aW1lVG9JZGxlICYmIF9vcHRpb25zLm1vdXNlVXNlZCAmJiAhX2lzSWRsZSkge1xuXHRcdFx0XHQvLyByZXNldCBpZGxlIHRpbWVyXG5cdFx0XHRcdF9vbklkbGVNb3VzZU1vdmUoKTtcblx0XHRcdH1cblxuXG5cdFx0XHR2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LFxuXHRcdFx0XHR1aUVsZW1lbnQsXG5cdFx0XHRcdGNsaWNrZWRDbGFzcyA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycsXG5cdFx0XHRcdGZvdW5kO1xuXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgX3VpRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dWlFbGVtZW50ID0gX3VpRWxlbWVudHNbaV07XG5cdFx0XHRcdGlmKHVpRWxlbWVudC5vblRhcCAmJiBjbGlja2VkQ2xhc3MuaW5kZXhPZigncHN3cF9fJyArIHVpRWxlbWVudC5uYW1lICkgPiAtMSApIHtcblx0XHRcdFx0XHR1aUVsZW1lbnQub25UYXAoKTtcblx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XG5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZihmb3VuZCkge1xuXHRcdFx0XHRpZihlLnN0b3BQcm9wYWdhdGlvbikge1xuXHRcdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0X2Jsb2NrQ29udHJvbHNUYXAgPSB0cnVlO1xuXG5cdFx0XHRcdC8vIFNvbWUgdmVyc2lvbnMgb2YgQW5kcm9pZCBkb24ndCBwcmV2ZW50IGdob3N0IGNsaWNrIGV2ZW50IFxuXHRcdFx0XHQvLyB3aGVuIHByZXZlbnREZWZhdWx0KCkgd2FzIGNhbGxlZCBvbiB0b3VjaHN0YXJ0IGFuZC9vciB0b3VjaGVuZC5cblx0XHRcdFx0Ly8gXG5cdFx0XHRcdC8vIFRoaXMgaGFwcGVucyBvbiB2NC4zLCA0LjIsIDQuMSwgXG5cdFx0XHRcdC8vIG9sZGVyIHZlcnNpb25zIHN0cmFuZ2VseSB3b3JrIGNvcnJlY3RseSwgXG5cdFx0XHRcdC8vIGJ1dCBqdXN0IGluIGNhc2Ugd2UgYWRkIGRlbGF5IG9uIGFsbCBvZiB0aGVtKVx0XG5cdFx0XHRcdHZhciB0YXBEZWxheSA9IGZyYW1ld29yay5mZWF0dXJlcy5pc09sZEFuZHJvaWQgPyA2MDAgOiAzMDtcblx0XHRcdFx0X2Jsb2NrQ29udHJvbHNUYXBUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRfYmxvY2tDb250cm9sc1RhcCA9IGZhbHNlO1xuXHRcdFx0XHR9LCB0YXBEZWxheSk7XG5cdFx0XHR9XG5cblx0XHR9LFxuXHRcdF9maXRDb250cm9sc0luVmlld3BvcnQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAhcHN3cC5saWtlbHlUb3VjaERldmljZSB8fCBfb3B0aW9ucy5tb3VzZVVzZWQgfHwgc2NyZWVuLndpZHRoID4gX29wdGlvbnMuZml0Q29udHJvbHNXaWR0aDtcblx0XHR9LFxuXHRcdF90b2dnbGVQc3dwQ2xhc3MgPSBmdW5jdGlvbihlbCwgY05hbWUsIGFkZCkge1xuXHRcdFx0ZnJhbWV3b3JrWyAoYWRkID8gJ2FkZCcgOiAncmVtb3ZlJykgKyAnQ2xhc3MnIF0oZWwsICdwc3dwX18nICsgY05hbWUpO1xuXHRcdH0sXG5cblx0XHQvLyBhZGQgY2xhc3Mgd2hlbiB0aGVyZSBpcyBqdXN0IG9uZSBpdGVtIGluIHRoZSBnYWxsZXJ5XG5cdFx0Ly8gKGJ5IGRlZmF1bHQgaXQgaGlkZXMgbGVmdC9yaWdodCBhcnJvd3MgYW5kIDFvZlggY291bnRlcilcblx0XHRfY291bnROdW1JdGVtcyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGhhc09uZVNsaWRlID0gKF9vcHRpb25zLmdldE51bUl0ZW1zRm4oKSA9PT0gMSk7XG5cblx0XHRcdGlmKGhhc09uZVNsaWRlICE9PSBfZ2FsbGVyeUhhc09uZVNsaWRlKSB7XG5cdFx0XHRcdF90b2dnbGVQc3dwQ2xhc3MoX2NvbnRyb2xzLCAndWktLW9uZS1zbGlkZScsIGhhc09uZVNsaWRlKTtcblx0XHRcdFx0X2dhbGxlcnlIYXNPbmVTbGlkZSA9IGhhc09uZVNsaWRlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0X3RvZ2dsZVNoYXJlTW9kYWxDbGFzcyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0X3RvZ2dsZVBzd3BDbGFzcyhfc2hhcmVNb2RhbCwgJ3NoYXJlLW1vZGFsLS1oaWRkZW4nLCBfc2hhcmVNb2RhbEhpZGRlbik7XG5cdFx0fSxcblx0XHRfdG9nZ2xlU2hhcmVNb2RhbCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRfc2hhcmVNb2RhbEhpZGRlbiA9ICFfc2hhcmVNb2RhbEhpZGRlbjtcblx0XHRcdFxuXHRcdFx0XG5cdFx0XHRpZighX3NoYXJlTW9kYWxIaWRkZW4pIHtcblx0XHRcdFx0X3RvZ2dsZVNoYXJlTW9kYWxDbGFzcygpO1xuXHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmKCFfc2hhcmVNb2RhbEhpZGRlbikge1xuXHRcdFx0XHRcdFx0ZnJhbWV3b3JrLmFkZENsYXNzKF9zaGFyZU1vZGFsLCAncHN3cF9fc2hhcmUtbW9kYWwtLWZhZGUtaW4nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIDMwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZyYW1ld29yay5yZW1vdmVDbGFzcyhfc2hhcmVNb2RhbCwgJ3Bzd3BfX3NoYXJlLW1vZGFsLS1mYWRlLWluJyk7XG5cdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYoX3NoYXJlTW9kYWxIaWRkZW4pIHtcblx0XHRcdFx0XHRcdF90b2dnbGVTaGFyZU1vZGFsQ2xhc3MoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIDMwMCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmKCFfc2hhcmVNb2RhbEhpZGRlbikge1xuXHRcdFx0XHRfdXBkYXRlU2hhcmVVUkxzKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblxuXHRcdF9vcGVuV2luZG93UG9wdXAgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG5cdFx0XHR2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuXG5cdFx0XHRwc3dwLnNob3V0KCdzaGFyZUxpbmtDbGljaycsIGUsIHRhcmdldCk7XG5cblx0XHRcdGlmKCF0YXJnZXQuaHJlZikge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmKCB0YXJnZXQuaGFzQXR0cmlidXRlKCdkb3dubG9hZCcpICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0d2luZG93Lm9wZW4odGFyZ2V0LmhyZWYsICdwc3dwX3NoYXJlJywgJ3Njcm9sbGJhcnM9eWVzLHJlc2l6YWJsZT15ZXMsdG9vbGJhcj1ubywnK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQnbG9jYXRpb249eWVzLHdpZHRoPTU1MCxoZWlnaHQ9NDIwLHRvcD0xMDAsbGVmdD0nICsgXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCh3aW5kb3cuc2NyZWVuID8gTWF0aC5yb3VuZChzY3JlZW4ud2lkdGggLyAyIC0gMjc1KSA6IDEwMCkgICk7XG5cblx0XHRcdGlmKCFfc2hhcmVNb2RhbEhpZGRlbikge1xuXHRcdFx0XHRfdG9nZ2xlU2hhcmVNb2RhbCgpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHRfdXBkYXRlU2hhcmVVUkxzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2hhcmVCdXR0b25PdXQgPSAnJyxcblx0XHRcdFx0c2hhcmVCdXR0b25EYXRhLFxuXHRcdFx0XHRzaGFyZVVSTCxcblx0XHRcdFx0aW1hZ2VfdXJsLFxuXHRcdFx0XHRwYWdlX3VybCxcblx0XHRcdFx0c2hhcmVfdGV4dDtcblxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IF9vcHRpb25zLnNoYXJlQnV0dG9ucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRzaGFyZUJ1dHRvbkRhdGEgPSBfb3B0aW9ucy5zaGFyZUJ1dHRvbnNbaV07XG5cblx0XHRcdFx0aW1hZ2VfdXJsID0gX29wdGlvbnMuZ2V0SW1hZ2VVUkxGb3JTaGFyZShzaGFyZUJ1dHRvbkRhdGEpO1xuXHRcdFx0XHRwYWdlX3VybCA9IF9vcHRpb25zLmdldFBhZ2VVUkxGb3JTaGFyZShzaGFyZUJ1dHRvbkRhdGEpO1xuXHRcdFx0XHRzaGFyZV90ZXh0ID0gX29wdGlvbnMuZ2V0VGV4dEZvclNoYXJlKHNoYXJlQnV0dG9uRGF0YSk7XG5cblx0XHRcdFx0c2hhcmVVUkwgPSBzaGFyZUJ1dHRvbkRhdGEudXJsLnJlcGxhY2UoJ3t7dXJsfX0nLCBlbmNvZGVVUklDb21wb25lbnQocGFnZV91cmwpIClcblx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKCd7e2ltYWdlX3VybH19JywgZW5jb2RlVVJJQ29tcG9uZW50KGltYWdlX3VybCkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoJ3t7cmF3X2ltYWdlX3VybH19JywgaW1hZ2VfdXJsIClcblx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKCd7e3RleHR9fScsIGVuY29kZVVSSUNvbXBvbmVudChzaGFyZV90ZXh0KSApO1xuXG5cdFx0XHRcdHNoYXJlQnV0dG9uT3V0ICs9ICc8YSBocmVmPVwiJyArIHNoYXJlVVJMICsgJ1wiIHRhcmdldD1cIl9ibGFua1wiICcrXG5cdFx0XHRcdFx0XHRcdFx0XHQnY2xhc3M9XCJwc3dwX19zaGFyZS0tJyArIHNoYXJlQnV0dG9uRGF0YS5pZCArICdcIicgK1xuXHRcdFx0XHRcdFx0XHRcdFx0KHNoYXJlQnV0dG9uRGF0YS5kb3dubG9hZCA/ICdkb3dubG9hZCcgOiAnJykgKyAnPicgKyBcblx0XHRcdFx0XHRcdFx0XHRcdHNoYXJlQnV0dG9uRGF0YS5sYWJlbCArICc8L2E+JztcblxuXHRcdFx0XHRpZihfb3B0aW9ucy5wYXJzZVNoYXJlQnV0dG9uT3V0KSB7XG5cdFx0XHRcdFx0c2hhcmVCdXR0b25PdXQgPSBfb3B0aW9ucy5wYXJzZVNoYXJlQnV0dG9uT3V0KHNoYXJlQnV0dG9uRGF0YSwgc2hhcmVCdXR0b25PdXQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRfc2hhcmVNb2RhbC5jaGlsZHJlblswXS5pbm5lckhUTUwgPSBzaGFyZUJ1dHRvbk91dDtcblx0XHRcdF9zaGFyZU1vZGFsLmNoaWxkcmVuWzBdLm9uY2xpY2sgPSBfb3BlbldpbmRvd1BvcHVwO1xuXG5cdFx0fSxcblx0XHRfaGFzQ2xvc2VDbGFzcyA9IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdFx0Zm9yKHZhciAgaSA9IDA7IGkgPCBfb3B0aW9ucy5jbG9zZUVsQ2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiggZnJhbWV3b3JrLmhhc0NsYXNzKHRhcmdldCwgJ3Bzd3BfXycgKyBfb3B0aW9ucy5jbG9zZUVsQ2xhc3Nlc1tpXSkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdF9pZGxlSW50ZXJ2YWwsXG5cdFx0X2lkbGVUaW1lcixcblx0XHRfaWRsZUluY3JlbWVudCA9IDAsXG5cdFx0X29uSWRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KF9pZGxlVGltZXIpO1xuXHRcdFx0X2lkbGVJbmNyZW1lbnQgPSAwO1xuXHRcdFx0aWYoX2lzSWRsZSkge1xuXHRcdFx0XHR1aS5zZXRJZGxlKGZhbHNlKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdF9vbk1vdXNlTGVhdmVXaW5kb3cgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRlID0gZSA/IGUgOiB3aW5kb3cuZXZlbnQ7XG5cdFx0XHR2YXIgZnJvbSA9IGUucmVsYXRlZFRhcmdldCB8fCBlLnRvRWxlbWVudDtcblx0XHRcdGlmICghZnJvbSB8fCBmcm9tLm5vZGVOYW1lID09PSAnSFRNTCcpIHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KF9pZGxlVGltZXIpO1xuXHRcdFx0XHRfaWRsZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR1aS5zZXRJZGxlKHRydWUpO1xuXHRcdFx0XHR9LCBfb3B0aW9ucy50aW1lVG9JZGxlT3V0c2lkZSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRfc2V0dXBGdWxsc2NyZWVuQVBJID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZihfb3B0aW9ucy5mdWxsc2NyZWVuRWwgJiYgIWZyYW1ld29yay5mZWF0dXJlcy5pc09sZEFuZHJvaWQpIHtcblx0XHRcdFx0aWYoIV9mdWxsc2NyZW5BUEkpIHtcblx0XHRcdFx0XHRfZnVsbHNjcmVuQVBJID0gdWkuZ2V0RnVsbHNjcmVlbkFQSSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKF9mdWxsc2NyZW5BUEkpIHtcblx0XHRcdFx0XHRmcmFtZXdvcmsuYmluZChkb2N1bWVudCwgX2Z1bGxzY3JlbkFQSS5ldmVudEssIHVpLnVwZGF0ZUZ1bGxzY3JlZW4pO1xuXHRcdFx0XHRcdHVpLnVwZGF0ZUZ1bGxzY3JlZW4oKTtcblx0XHRcdFx0XHRmcmFtZXdvcmsuYWRkQ2xhc3MocHN3cC50ZW1wbGF0ZSwgJ3Bzd3AtLXN1cHBvcnRzLWZzJyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZnJhbWV3b3JrLnJlbW92ZUNsYXNzKHBzd3AudGVtcGxhdGUsICdwc3dwLS1zdXBwb3J0cy1mcycpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRfc2V0dXBMb2FkaW5nSW5kaWNhdG9yID0gZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBTZXR1cCBsb2FkaW5nIGluZGljYXRvclxuXHRcdFx0aWYoX29wdGlvbnMucHJlbG9hZGVyRWwpIHtcblx0XHRcdFxuXHRcdFx0XHRfdG9nZ2xlTG9hZGluZ0luZGljYXRvcih0cnVlKTtcblxuXHRcdFx0XHRfbGlzdGVuKCdiZWZvcmVDaGFuZ2UnLCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdGNsZWFyVGltZW91dChfbG9hZGluZ0luZGljYXRvclRpbWVvdXQpO1xuXG5cdFx0XHRcdFx0Ly8gZGlzcGxheSBsb2FkaW5nIGluZGljYXRvciB3aXRoIGRlbGF5XG5cdFx0XHRcdFx0X2xvYWRpbmdJbmRpY2F0b3JUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0aWYocHN3cC5jdXJySXRlbSAmJiBwc3dwLmN1cnJJdGVtLmxvYWRpbmcpIHtcblxuXHRcdFx0XHRcdFx0XHRpZiggIXBzd3AuYWxsb3dQcm9ncmVzc2l2ZUltZygpIHx8IChwc3dwLmN1cnJJdGVtLmltZyAmJiAhcHN3cC5jdXJySXRlbS5pbWcubmF0dXJhbFdpZHRoKSAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2hvdyBwcmVsb2FkZXIgaWYgcHJvZ3Jlc3NpdmUgbG9hZGluZyBpcyBub3QgZW5hYmxlZCwgXG5cdFx0XHRcdFx0XHRcdFx0Ly8gb3IgaW1hZ2Ugd2lkdGggaXMgbm90IGRlZmluZWQgeWV0IChiZWNhdXNlIG9mIHNsb3cgY29ubmVjdGlvbilcblx0XHRcdFx0XHRcdFx0XHRfdG9nZ2xlTG9hZGluZ0luZGljYXRvcihmYWxzZSk7IFxuXHRcdFx0XHRcdFx0XHRcdC8vIGl0ZW1zLWNvbnRyb2xsZXIuanMgZnVuY3Rpb24gYWxsb3dQcm9ncmVzc2l2ZUltZ1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0X3RvZ2dsZUxvYWRpbmdJbmRpY2F0b3IodHJ1ZSk7IC8vIGhpZGUgcHJlbG9hZGVyXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9LCBfb3B0aW9ucy5sb2FkaW5nSW5kaWNhdG9yRGVsYXkpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0X2xpc3RlbignaW1hZ2VMb2FkQ29tcGxldGUnLCBmdW5jdGlvbihpbmRleCwgaXRlbSkge1xuXHRcdFx0XHRcdGlmKHBzd3AuY3Vyckl0ZW0gPT09IGl0ZW0pIHtcblx0XHRcdFx0XHRcdF90b2dnbGVMb2FkaW5nSW5kaWNhdG9yKHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdH1cblx0XHR9LFxuXHRcdF90b2dnbGVMb2FkaW5nSW5kaWNhdG9yID0gZnVuY3Rpb24oaGlkZSkge1xuXHRcdFx0aWYoIF9sb2FkaW5nSW5kaWNhdG9ySGlkZGVuICE9PSBoaWRlICkge1xuXHRcdFx0XHRfdG9nZ2xlUHN3cENsYXNzKF9sb2FkaW5nSW5kaWNhdG9yLCAncHJlbG9hZGVyLS1hY3RpdmUnLCAhaGlkZSk7XG5cdFx0XHRcdF9sb2FkaW5nSW5kaWNhdG9ySGlkZGVuID0gaGlkZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdF9hcHBseU5hdkJhckdhcHMgPSBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHR2YXIgZ2FwID0gaXRlbS52R2FwO1xuXG5cdFx0XHRpZiggX2ZpdENvbnRyb2xzSW5WaWV3cG9ydCgpICkge1xuXHRcdFx0XHRcblx0XHRcdFx0dmFyIGJhcnMgPSBfb3B0aW9ucy5iYXJzU2l6ZTsgXG5cdFx0XHRcdGlmKF9vcHRpb25zLmNhcHRpb25FbCAmJiBiYXJzLmJvdHRvbSA9PT0gJ2F1dG8nKSB7XG5cdFx0XHRcdFx0aWYoIV9mYWtlQ2FwdGlvbkNvbnRhaW5lcikge1xuXHRcdFx0XHRcdFx0X2Zha2VDYXB0aW9uQ29udGFpbmVyID0gZnJhbWV3b3JrLmNyZWF0ZUVsKCdwc3dwX19jYXB0aW9uIHBzd3BfX2NhcHRpb24tLWZha2UnKTtcblx0XHRcdFx0XHRcdF9mYWtlQ2FwdGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZCggZnJhbWV3b3JrLmNyZWF0ZUVsKCdwc3dwX19jYXB0aW9uX19jZW50ZXInKSApO1xuXHRcdFx0XHRcdFx0X2NvbnRyb2xzLmluc2VydEJlZm9yZShfZmFrZUNhcHRpb25Db250YWluZXIsIF9jYXB0aW9uQ29udGFpbmVyKTtcblx0XHRcdFx0XHRcdGZyYW1ld29yay5hZGRDbGFzcyhfY29udHJvbHMsICdwc3dwX191aS0tZml0Jyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKCBfb3B0aW9ucy5hZGRDYXB0aW9uSFRNTEZuKGl0ZW0sIF9mYWtlQ2FwdGlvbkNvbnRhaW5lciwgdHJ1ZSkgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBjYXB0aW9uU2l6ZSA9IF9mYWtlQ2FwdGlvbkNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG5cdFx0XHRcdFx0XHRnYXAuYm90dG9tID0gcGFyc2VJbnQoY2FwdGlvblNpemUsMTApIHx8IDQ0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRnYXAuYm90dG9tID0gYmFycy50b3A7IC8vIGlmIG5vIGNhcHRpb24sIHNldCBzaXplIG9mIGJvdHRvbSBnYXAgdG8gc2l6ZSBvZiB0b3Bcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Z2FwLmJvdHRvbSA9IGJhcnMuYm90dG9tID09PSAnYXV0bycgPyAwIDogYmFycy5ib3R0b207XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdC8vIGhlaWdodCBvZiB0b3AgYmFyIGlzIHN0YXRpYywgbm8gbmVlZCB0byBjYWxjdWxhdGUgaXRcblx0XHRcdFx0Z2FwLnRvcCA9IGJhcnMudG9wO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Z2FwLnRvcCA9IGdhcC5ib3R0b20gPSAwO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0X3NldHVwSWRsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gSGlkZSBjb250cm9scyB3aGVuIG1vdXNlIGlzIHVzZWRcblx0XHRcdGlmKF9vcHRpb25zLnRpbWVUb0lkbGUpIHtcblx0XHRcdFx0X2xpc3RlbignbW91c2VVc2VkJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0ZnJhbWV3b3JrLmJpbmQoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCBfb25JZGxlTW91c2VNb3ZlKTtcblx0XHRcdFx0XHRmcmFtZXdvcmsuYmluZChkb2N1bWVudCwgJ21vdXNlb3V0JywgX29uTW91c2VMZWF2ZVdpbmRvdyk7XG5cblx0XHRcdFx0XHRfaWRsZUludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRfaWRsZUluY3JlbWVudCsrO1xuXHRcdFx0XHRcdFx0aWYoX2lkbGVJbmNyZW1lbnQgPT09IDIpIHtcblx0XHRcdFx0XHRcdFx0dWkuc2V0SWRsZSh0cnVlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCBfb3B0aW9ucy50aW1lVG9JZGxlIC8gMik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0X3NldHVwSGlkaW5nQ29udHJvbHNEdXJpbmdHZXN0dXJlcyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBIaWRlIGNvbnRyb2xzIG9uIHZlcnRpY2FsIGRyYWdcblx0XHRcdF9saXN0ZW4oJ29uVmVydGljYWxEcmFnJywgZnVuY3Rpb24obm93KSB7XG5cdFx0XHRcdGlmKF9jb250cm9sc1Zpc2libGUgJiYgbm93IDwgMC45NSkge1xuXHRcdFx0XHRcdHVpLmhpZGVDb250cm9scygpO1xuXHRcdFx0XHR9IGVsc2UgaWYoIV9jb250cm9sc1Zpc2libGUgJiYgbm93ID49IDAuOTUpIHtcblx0XHRcdFx0XHR1aS5zaG93Q29udHJvbHMoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEhpZGUgY29udHJvbHMgd2hlbiBwaW5jaGluZyB0byBjbG9zZVxuXHRcdFx0dmFyIHBpbmNoQ29udHJvbHNIaWRkZW47XG5cdFx0XHRfbGlzdGVuKCdvblBpbmNoQ2xvc2UnICwgZnVuY3Rpb24obm93KSB7XG5cdFx0XHRcdGlmKF9jb250cm9sc1Zpc2libGUgJiYgbm93IDwgMC45KSB7XG5cdFx0XHRcdFx0dWkuaGlkZUNvbnRyb2xzKCk7XG5cdFx0XHRcdFx0cGluY2hDb250cm9sc0hpZGRlbiA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSBpZihwaW5jaENvbnRyb2xzSGlkZGVuICYmICFfY29udHJvbHNWaXNpYmxlICYmIG5vdyA+IDAuOSkge1xuXHRcdFx0XHRcdHVpLnNob3dDb250cm9scygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0X2xpc3Rlbignem9vbUdlc3R1cmVFbmRlZCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRwaW5jaENvbnRyb2xzSGlkZGVuID0gZmFsc2U7XG5cdFx0XHRcdGlmKHBpbmNoQ29udHJvbHNIaWRkZW4gJiYgIV9jb250cm9sc1Zpc2libGUpIHtcblx0XHRcdFx0XHR1aS5zaG93Q29udHJvbHMoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHR9O1xuXG5cblxuXHR2YXIgX3VpRWxlbWVudHMgPSBbXG5cdFx0eyBcblx0XHRcdG5hbWU6ICdjYXB0aW9uJywgXG5cdFx0XHRvcHRpb246ICdjYXB0aW9uRWwnLFxuXHRcdFx0b25Jbml0OiBmdW5jdGlvbihlbCkgeyAgXG5cdFx0XHRcdF9jYXB0aW9uQ29udGFpbmVyID0gZWw7IFxuXHRcdFx0fSBcblx0XHR9LFxuXHRcdHsgXG5cdFx0XHRuYW1lOiAnc2hhcmUtbW9kYWwnLCBcblx0XHRcdG9wdGlvbjogJ3NoYXJlRWwnLFxuXHRcdFx0b25Jbml0OiBmdW5jdGlvbihlbCkgeyAgXG5cdFx0XHRcdF9zaGFyZU1vZGFsID0gZWw7XG5cdFx0XHR9LFxuXHRcdFx0b25UYXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRfdG9nZ2xlU2hhcmVNb2RhbCgpO1xuXHRcdFx0fSBcblx0XHR9LFxuXHRcdHsgXG5cdFx0XHRuYW1lOiAnYnV0dG9uLS1zaGFyZScsIFxuXHRcdFx0b3B0aW9uOiAnc2hhcmVFbCcsXG5cdFx0XHRvbkluaXQ6IGZ1bmN0aW9uKGVsKSB7IFxuXHRcdFx0XHRfc2hhcmVCdXR0b24gPSBlbDtcblx0XHRcdH0sXG5cdFx0XHRvblRhcDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdF90b2dnbGVTaGFyZU1vZGFsKCk7XG5cdFx0XHR9IFxuXHRcdH0sXG5cdFx0eyBcblx0XHRcdG5hbWU6ICdidXR0b24tLXpvb20nLCBcblx0XHRcdG9wdGlvbjogJ3pvb21FbCcsXG5cdFx0XHRvblRhcDogcHN3cC50b2dnbGVEZXNrdG9wWm9vbVxuXHRcdH0sXG5cdFx0eyBcblx0XHRcdG5hbWU6ICdjb3VudGVyJywgXG5cdFx0XHRvcHRpb246ICdjb3VudGVyRWwnLFxuXHRcdFx0b25Jbml0OiBmdW5jdGlvbihlbCkgeyAgXG5cdFx0XHRcdF9pbmRleEluZGljYXRvciA9IGVsO1xuXHRcdFx0fSBcblx0XHR9LFxuXHRcdHsgXG5cdFx0XHRuYW1lOiAnYnV0dG9uLS1jbG9zZScsIFxuXHRcdFx0b3B0aW9uOiAnY2xvc2VFbCcsXG5cdFx0XHRvblRhcDogcHN3cC5jbG9zZVxuXHRcdH0sXG5cdFx0eyBcblx0XHRcdG5hbWU6ICdidXR0b24tLWFycm93LS1sZWZ0JywgXG5cdFx0XHRvcHRpb246ICdhcnJvd0VsJyxcblx0XHRcdG9uVGFwOiBwc3dwLnByZXZcblx0XHR9LFxuXHRcdHsgXG5cdFx0XHRuYW1lOiAnYnV0dG9uLS1hcnJvdy0tcmlnaHQnLCBcblx0XHRcdG9wdGlvbjogJ2Fycm93RWwnLFxuXHRcdFx0b25UYXA6IHBzd3AubmV4dFxuXHRcdH0sXG5cdFx0eyBcblx0XHRcdG5hbWU6ICdidXR0b24tLWZzJywgXG5cdFx0XHRvcHRpb246ICdmdWxsc2NyZWVuRWwnLFxuXHRcdFx0b25UYXA6IGZ1bmN0aW9uKCkgeyAgXG5cdFx0XHRcdGlmKF9mdWxsc2NyZW5BUEkuaXNGdWxsc2NyZWVuKCkpIHtcblx0XHRcdFx0XHRfZnVsbHNjcmVuQVBJLmV4aXQoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfZnVsbHNjcmVuQVBJLmVudGVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gXG5cdFx0fSxcblx0XHR7IFxuXHRcdFx0bmFtZTogJ3ByZWxvYWRlcicsIFxuXHRcdFx0b3B0aW9uOiAncHJlbG9hZGVyRWwnLFxuXHRcdFx0b25Jbml0OiBmdW5jdGlvbihlbCkgeyAgXG5cdFx0XHRcdF9sb2FkaW5nSW5kaWNhdG9yID0gZWw7XG5cdFx0XHR9IFxuXHRcdH1cblxuXHRdO1xuXG5cdHZhciBfc2V0dXBVSUVsZW1lbnRzID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGl0ZW0sXG5cdFx0XHRjbGFzc0F0dHIsXG5cdFx0XHR1aUVsZW1lbnQ7XG5cblx0XHR2YXIgbG9vcFRocm91Z2hDaGlsZEVsZW1lbnRzID0gZnVuY3Rpb24oc0NoaWxkcmVuKSB7XG5cdFx0XHRpZighc0NoaWxkcmVuKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGwgPSBzQ2hpbGRyZW4ubGVuZ3RoO1xuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpdGVtID0gc0NoaWxkcmVuW2ldO1xuXHRcdFx0XHRjbGFzc0F0dHIgPSBpdGVtLmNsYXNzTmFtZTtcblxuXHRcdFx0XHRmb3IodmFyIGEgPSAwOyBhIDwgX3VpRWxlbWVudHMubGVuZ3RoOyBhKyspIHtcblx0XHRcdFx0XHR1aUVsZW1lbnQgPSBfdWlFbGVtZW50c1thXTtcblxuXHRcdFx0XHRcdGlmKGNsYXNzQXR0ci5pbmRleE9mKCdwc3dwX18nICsgdWlFbGVtZW50Lm5hbWUpID4gLTEgICkge1xuXG5cdFx0XHRcdFx0XHRpZiggX29wdGlvbnNbdWlFbGVtZW50Lm9wdGlvbl0gKSB7IC8vIGlmIGVsZW1lbnQgaXMgbm90IGRpc2FibGVkIGZyb20gb3B0aW9uc1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0ZnJhbWV3b3JrLnJlbW92ZUNsYXNzKGl0ZW0sICdwc3dwX19lbGVtZW50LS1kaXNhYmxlZCcpO1xuXHRcdFx0XHRcdFx0XHRpZih1aUVsZW1lbnQub25Jbml0KSB7XG5cdFx0XHRcdFx0XHRcdFx0dWlFbGVtZW50Lm9uSW5pdChpdGVtKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0Ly9pdGVtLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZnJhbWV3b3JrLmFkZENsYXNzKGl0ZW0sICdwc3dwX19lbGVtZW50LS1kaXNhYmxlZCcpO1xuXHRcdFx0XHRcdFx0XHQvL2l0ZW0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdGxvb3BUaHJvdWdoQ2hpbGRFbGVtZW50cyhfY29udHJvbHMuY2hpbGRyZW4pO1xuXG5cdFx0dmFyIHRvcEJhciA9ICBmcmFtZXdvcmsuZ2V0Q2hpbGRCeUNsYXNzKF9jb250cm9scywgJ3Bzd3BfX3RvcC1iYXInKTtcblx0XHRpZih0b3BCYXIpIHtcblx0XHRcdGxvb3BUaHJvdWdoQ2hpbGRFbGVtZW50cyggdG9wQmFyLmNoaWxkcmVuICk7XG5cdFx0fVxuXHR9O1xuXG5cblx0XG5cblx0dWkuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0Ly8gZXh0ZW5kIG9wdGlvbnNcblx0XHRmcmFtZXdvcmsuZXh0ZW5kKHBzd3Aub3B0aW9ucywgX2RlZmF1bHRVSU9wdGlvbnMsIHRydWUpO1xuXG5cdFx0Ly8gY3JlYXRlIGxvY2FsIGxpbmsgZm9yIGZhc3QgYWNjZXNzXG5cdFx0X29wdGlvbnMgPSBwc3dwLm9wdGlvbnM7XG5cblx0XHQvLyBmaW5kIHBzd3BfX3VpIGVsZW1lbnRcblx0XHRfY29udHJvbHMgPSBmcmFtZXdvcmsuZ2V0Q2hpbGRCeUNsYXNzKHBzd3Auc2Nyb2xsV3JhcCwgJ3Bzd3BfX3VpJyk7XG5cblx0XHQvLyBjcmVhdGUgbG9jYWwgbGlua1xuXHRcdF9saXN0ZW4gPSBwc3dwLmxpc3RlbjtcblxuXG5cdFx0X3NldHVwSGlkaW5nQ29udHJvbHNEdXJpbmdHZXN0dXJlcygpO1xuXG5cdFx0Ly8gdXBkYXRlIGNvbnRyb2xzIHdoZW4gc2xpZGVzIGNoYW5nZVxuXHRcdF9saXN0ZW4oJ2JlZm9yZUNoYW5nZScsIHVpLnVwZGF0ZSk7XG5cblx0XHQvLyB0b2dnbGUgem9vbSBvbiBkb3VibGUtdGFwXG5cdFx0X2xpc3RlbignZG91YmxlVGFwJywgZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRcdHZhciBpbml0aWFsWm9vbUxldmVsID0gcHN3cC5jdXJySXRlbS5pbml0aWFsWm9vbUxldmVsO1xuXHRcdFx0aWYocHN3cC5nZXRab29tTGV2ZWwoKSAhPT0gaW5pdGlhbFpvb21MZXZlbCkge1xuXHRcdFx0XHRwc3dwLnpvb21Ubyhpbml0aWFsWm9vbUxldmVsLCBwb2ludCwgMzMzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBzd3Auem9vbVRvKF9vcHRpb25zLmdldERvdWJsZVRhcFpvb20oZmFsc2UsIHBzd3AuY3Vyckl0ZW0pLCBwb2ludCwgMzMzKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEFsbG93IHRleHQgc2VsZWN0aW9uIGluIGNhcHRpb25cblx0XHRfbGlzdGVuKCdwcmV2ZW50RHJhZ0V2ZW50JywgZnVuY3Rpb24oZSwgaXNEb3duLCBwcmV2ZW50T2JqKSB7XG5cdFx0XHR2YXIgdCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcblx0XHRcdGlmKFxuXHRcdFx0XHR0ICYmIFxuXHRcdFx0XHR0LmdldEF0dHJpYnV0ZSgnY2xhc3MnKSAmJiBlLnR5cGUuaW5kZXhPZignbW91c2UnKSA+IC0xICYmIFxuXHRcdFx0XHQoIHQuZ2V0QXR0cmlidXRlKCdjbGFzcycpLmluZGV4T2YoJ19fY2FwdGlvbicpID4gMCB8fCAoLyhTTUFMTHxTVFJPTkd8RU0pL2kpLnRlc3QodC50YWdOYW1lKSApIFxuXHRcdFx0KSB7XG5cdFx0XHRcdHByZXZlbnRPYmoucHJldmVudCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gYmluZCBldmVudHMgZm9yIFVJXG5cdFx0X2xpc3RlbignYmluZEV2ZW50cycsIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZnJhbWV3b3JrLmJpbmQoX2NvbnRyb2xzLCAncHN3cFRhcCBjbGljaycsIF9vbkNvbnRyb2xzVGFwKTtcblx0XHRcdGZyYW1ld29yay5iaW5kKHBzd3Auc2Nyb2xsV3JhcCwgJ3Bzd3BUYXAnLCB1aS5vbkdsb2JhbFRhcCk7XG5cblx0XHRcdGlmKCFwc3dwLmxpa2VseVRvdWNoRGV2aWNlKSB7XG5cdFx0XHRcdGZyYW1ld29yay5iaW5kKHBzd3Auc2Nyb2xsV3JhcCwgJ21vdXNlb3ZlcicsIHVpLm9uTW91c2VPdmVyKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIHVuYmluZCBldmVudHMgZm9yIFVJXG5cdFx0X2xpc3RlbigndW5iaW5kRXZlbnRzJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRpZighX3NoYXJlTW9kYWxIaWRkZW4pIHtcblx0XHRcdFx0X3RvZ2dsZVNoYXJlTW9kYWwoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYoX2lkbGVJbnRlcnZhbCkge1xuXHRcdFx0XHRjbGVhckludGVydmFsKF9pZGxlSW50ZXJ2YWwpO1xuXHRcdFx0fVxuXHRcdFx0ZnJhbWV3b3JrLnVuYmluZChkb2N1bWVudCwgJ21vdXNlb3V0JywgX29uTW91c2VMZWF2ZVdpbmRvdyk7XG5cdFx0XHRmcmFtZXdvcmsudW5iaW5kKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgX29uSWRsZU1vdXNlTW92ZSk7XG5cdFx0XHRmcmFtZXdvcmsudW5iaW5kKF9jb250cm9scywgJ3Bzd3BUYXAgY2xpY2snLCBfb25Db250cm9sc1RhcCk7XG5cdFx0XHRmcmFtZXdvcmsudW5iaW5kKHBzd3Auc2Nyb2xsV3JhcCwgJ3Bzd3BUYXAnLCB1aS5vbkdsb2JhbFRhcCk7XG5cdFx0XHRmcmFtZXdvcmsudW5iaW5kKHBzd3Auc2Nyb2xsV3JhcCwgJ21vdXNlb3ZlcicsIHVpLm9uTW91c2VPdmVyKTtcblxuXHRcdFx0aWYoX2Z1bGxzY3JlbkFQSSkge1xuXHRcdFx0XHRmcmFtZXdvcmsudW5iaW5kKGRvY3VtZW50LCBfZnVsbHNjcmVuQVBJLmV2ZW50SywgdWkudXBkYXRlRnVsbHNjcmVlbik7XG5cdFx0XHRcdGlmKF9mdWxsc2NyZW5BUEkuaXNGdWxsc2NyZWVuKCkpIHtcblx0XHRcdFx0XHRfb3B0aW9ucy5oaWRlQW5pbWF0aW9uRHVyYXRpb24gPSAwO1xuXHRcdFx0XHRcdF9mdWxsc2NyZW5BUEkuZXhpdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9mdWxsc2NyZW5BUEkgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cblx0XHQvLyBjbGVhbiB1cCB0aGluZ3Mgd2hlbiBnYWxsZXJ5IGlzIGRlc3Ryb3llZFxuXHRcdF9saXN0ZW4oJ2Rlc3Ryb3knLCBmdW5jdGlvbigpIHtcblx0XHRcdGlmKF9vcHRpb25zLmNhcHRpb25FbCkge1xuXHRcdFx0XHRpZihfZmFrZUNhcHRpb25Db250YWluZXIpIHtcblx0XHRcdFx0XHRfY29udHJvbHMucmVtb3ZlQ2hpbGQoX2Zha2VDYXB0aW9uQ29udGFpbmVyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmcmFtZXdvcmsucmVtb3ZlQ2xhc3MoX2NhcHRpb25Db250YWluZXIsICdwc3dwX19jYXB0aW9uLS1lbXB0eScpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihfc2hhcmVNb2RhbCkge1xuXHRcdFx0XHRfc2hhcmVNb2RhbC5jaGlsZHJlblswXS5vbmNsaWNrID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdGZyYW1ld29yay5yZW1vdmVDbGFzcyhfY29udHJvbHMsICdwc3dwX191aS0tb3Zlci1jbG9zZScpO1xuXHRcdFx0ZnJhbWV3b3JrLmFkZENsYXNzKCBfY29udHJvbHMsICdwc3dwX191aS0taGlkZGVuJyk7XG5cdFx0XHR1aS5zZXRJZGxlKGZhbHNlKTtcblx0XHR9KTtcblx0XHRcblxuXHRcdGlmKCFfb3B0aW9ucy5zaG93QW5pbWF0aW9uRHVyYXRpb24pIHtcblx0XHRcdGZyYW1ld29yay5yZW1vdmVDbGFzcyggX2NvbnRyb2xzLCAncHN3cF9fdWktLWhpZGRlbicpO1xuXHRcdH1cblx0XHRfbGlzdGVuKCdpbml0aWFsWm9vbUluJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRpZihfb3B0aW9ucy5zaG93QW5pbWF0aW9uRHVyYXRpb24pIHtcblx0XHRcdFx0ZnJhbWV3b3JrLnJlbW92ZUNsYXNzKCBfY29udHJvbHMsICdwc3dwX191aS0taGlkZGVuJyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0X2xpc3RlbignaW5pdGlhbFpvb21PdXQnLCBmdW5jdGlvbigpIHtcblx0XHRcdGZyYW1ld29yay5hZGRDbGFzcyggX2NvbnRyb2xzLCAncHN3cF9fdWktLWhpZGRlbicpO1xuXHRcdH0pO1xuXG5cdFx0X2xpc3RlbigncGFyc2VWZXJ0aWNhbE1hcmdpbicsIF9hcHBseU5hdkJhckdhcHMpO1xuXHRcdFxuXHRcdF9zZXR1cFVJRWxlbWVudHMoKTtcblxuXHRcdGlmKF9vcHRpb25zLnNoYXJlRWwgJiYgX3NoYXJlQnV0dG9uICYmIF9zaGFyZU1vZGFsKSB7XG5cdFx0XHRfc2hhcmVNb2RhbEhpZGRlbiA9IHRydWU7XG5cdFx0fVxuXG5cdFx0X2NvdW50TnVtSXRlbXMoKTtcblxuXHRcdF9zZXR1cElkbGUoKTtcblxuXHRcdF9zZXR1cEZ1bGxzY3JlZW5BUEkoKTtcblxuXHRcdF9zZXR1cExvYWRpbmdJbmRpY2F0b3IoKTtcblx0fTtcblxuXHR1aS5zZXRJZGxlID0gZnVuY3Rpb24oaXNJZGxlKSB7XG5cdFx0X2lzSWRsZSA9IGlzSWRsZTtcblx0XHRfdG9nZ2xlUHN3cENsYXNzKF9jb250cm9scywgJ3VpLS1pZGxlJywgaXNJZGxlKTtcblx0fTtcblxuXHR1aS51cGRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHQvLyBEb24ndCB1cGRhdGUgVUkgaWYgaXQncyBoaWRkZW5cblx0XHRpZihfY29udHJvbHNWaXNpYmxlICYmIHBzd3AuY3Vyckl0ZW0pIHtcblx0XHRcdFxuXHRcdFx0dWkudXBkYXRlSW5kZXhJbmRpY2F0b3IoKTtcblxuXHRcdFx0aWYoX29wdGlvbnMuY2FwdGlvbkVsKSB7XG5cdFx0XHRcdF9vcHRpb25zLmFkZENhcHRpb25IVE1MRm4ocHN3cC5jdXJySXRlbSwgX2NhcHRpb25Db250YWluZXIpO1xuXG5cdFx0XHRcdF90b2dnbGVQc3dwQ2xhc3MoX2NhcHRpb25Db250YWluZXIsICdjYXB0aW9uLS1lbXB0eScsICFwc3dwLmN1cnJJdGVtLnRpdGxlKTtcblx0XHRcdH1cblxuXHRcdFx0X292ZXJsYXlVSVVwZGF0ZWQgPSB0cnVlO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdF9vdmVybGF5VUlVcGRhdGVkID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYoIV9zaGFyZU1vZGFsSGlkZGVuKSB7XG5cdFx0XHRfdG9nZ2xlU2hhcmVNb2RhbCgpO1xuXHRcdH1cblxuXHRcdF9jb3VudE51bUl0ZW1zKCk7XG5cdH07XG5cblx0dWkudXBkYXRlRnVsbHNjcmVlbiA9IGZ1bmN0aW9uKGUpIHtcblxuXHRcdGlmKGUpIHtcblx0XHRcdC8vIHNvbWUgYnJvd3NlcnMgY2hhbmdlIHdpbmRvdyBzY3JvbGwgcG9zaXRpb24gZHVyaW5nIHRoZSBmdWxsc2NyZWVuXG5cdFx0XHQvLyBzbyBQaG90b1N3aXBlIHVwZGF0ZXMgaXQganVzdCBpbiBjYXNlXG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRwc3dwLnNldFNjcm9sbE9mZnNldCggMCwgZnJhbWV3b3JrLmdldFNjcm9sbFkoKSApO1xuXHRcdFx0fSwgNTApO1xuXHRcdH1cblx0XHRcblx0XHQvLyB0b29nbGUgcHN3cC0tZnMgY2xhc3Mgb24gcm9vdCBlbGVtZW50XG5cdFx0ZnJhbWV3b3JrWyAoX2Z1bGxzY3JlbkFQSS5pc0Z1bGxzY3JlZW4oKSA/ICdhZGQnIDogJ3JlbW92ZScpICsgJ0NsYXNzJyBdKHBzd3AudGVtcGxhdGUsICdwc3dwLS1mcycpO1xuXHR9O1xuXG5cdHVpLnVwZGF0ZUluZGV4SW5kaWNhdG9yID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYoX29wdGlvbnMuY291bnRlckVsKSB7XG5cdFx0XHRfaW5kZXhJbmRpY2F0b3IuaW5uZXJIVE1MID0gKHBzd3AuZ2V0Q3VycmVudEluZGV4KCkrMSkgKyBcblx0XHRcdFx0XHRcdFx0XHRcdFx0X29wdGlvbnMuaW5kZXhJbmRpY2F0b3JTZXAgKyBcblx0XHRcdFx0XHRcdFx0XHRcdFx0X29wdGlvbnMuZ2V0TnVtSXRlbXNGbigpO1xuXHRcdH1cblx0fTtcblx0XG5cdHVpLm9uR2xvYmFsVGFwID0gZnVuY3Rpb24oZSkge1xuXHRcdGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcblx0XHR2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuXG5cdFx0aWYoX2Jsb2NrQ29udHJvbHNUYXApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZihlLmRldGFpbCAmJiBlLmRldGFpbC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykge1xuXG5cdFx0XHQvLyBjbG9zZSBnYWxsZXJ5IGlmIGNsaWNrZWQgb3V0c2lkZSBvZiB0aGUgaW1hZ2Vcblx0XHRcdGlmKF9oYXNDbG9zZUNsYXNzKHRhcmdldCkpIHtcblx0XHRcdFx0cHN3cC5jbG9zZSgpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmKGZyYW1ld29yay5oYXNDbGFzcyh0YXJnZXQsICdwc3dwX19pbWcnKSkge1xuXHRcdFx0XHRpZihwc3dwLmdldFpvb21MZXZlbCgpID09PSAxICYmIHBzd3AuZ2V0Wm9vbUxldmVsKCkgPD0gcHN3cC5jdXJySXRlbS5maXRSYXRpbykge1xuXHRcdFx0XHRcdGlmKF9vcHRpb25zLmNsaWNrVG9DbG9zZU5vblpvb21hYmxlKSB7XG5cdFx0XHRcdFx0XHRwc3dwLmNsb3NlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBzd3AudG9nZ2xlRGVza3RvcFpvb20oZS5kZXRhaWwucmVsZWFzZVBvaW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gdGFwIGFueXdoZXJlIChleGNlcHQgYnV0dG9ucykgdG8gdG9nZ2xlIHZpc2liaWxpdHkgb2YgY29udHJvbHNcblx0XHRcdGlmKF9vcHRpb25zLnRhcFRvVG9nZ2xlQ29udHJvbHMpIHtcblx0XHRcdFx0aWYoX2NvbnRyb2xzVmlzaWJsZSkge1xuXHRcdFx0XHRcdHVpLmhpZGVDb250cm9scygpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHVpLnNob3dDb250cm9scygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHRhcCB0byBjbG9zZSBnYWxsZXJ5XG5cdFx0XHRpZihfb3B0aW9ucy50YXBUb0Nsb3NlICYmIChmcmFtZXdvcmsuaGFzQ2xhc3ModGFyZ2V0LCAncHN3cF9faW1nJykgfHwgX2hhc0Nsb3NlQ2xhc3ModGFyZ2V0KSkgKSB7XG5cdFx0XHRcdHBzd3AuY2xvc2UoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0fVxuXHR9O1xuXHR1aS5vbk1vdXNlT3ZlciA9IGZ1bmN0aW9uKGUpIHtcblx0XHRlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG5cdFx0dmFyIHRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcblxuXHRcdC8vIGFkZCBjbGFzcyB3aGVuIG1vdXNlIGlzIG92ZXIgYW4gZWxlbWVudCB0aGF0IHNob3VsZCBjbG9zZSB0aGUgZ2FsbGVyeVxuXHRcdF90b2dnbGVQc3dwQ2xhc3MoX2NvbnRyb2xzLCAndWktLW92ZXItY2xvc2UnLCBfaGFzQ2xvc2VDbGFzcyh0YXJnZXQpKTtcblx0fTtcblxuXHR1aS5oaWRlQ29udHJvbHMgPSBmdW5jdGlvbigpIHtcblx0XHRmcmFtZXdvcmsuYWRkQ2xhc3MoX2NvbnRyb2xzLCdwc3dwX191aS0taGlkZGVuJyk7XG5cdFx0X2NvbnRyb2xzVmlzaWJsZSA9IGZhbHNlO1xuXHR9O1xuXG5cdHVpLnNob3dDb250cm9scyA9IGZ1bmN0aW9uKCkge1xuXHRcdF9jb250cm9sc1Zpc2libGUgPSB0cnVlO1xuXHRcdGlmKCFfb3ZlcmxheVVJVXBkYXRlZCkge1xuXHRcdFx0dWkudXBkYXRlKCk7XG5cdFx0fVxuXHRcdGZyYW1ld29yay5yZW1vdmVDbGFzcyhfY29udHJvbHMsJ3Bzd3BfX3VpLS1oaWRkZW4nKTtcblx0fTtcblxuXHR1aS5zdXBwb3J0c0Z1bGxzY3JlZW4gPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgZCA9IGRvY3VtZW50O1xuXHRcdHJldHVybiAhIShkLmV4aXRGdWxsc2NyZWVuIHx8IGQubW96Q2FuY2VsRnVsbFNjcmVlbiB8fCBkLndlYmtpdEV4aXRGdWxsc2NyZWVuIHx8IGQubXNFeGl0RnVsbHNjcmVlbik7XG5cdH07XG5cblx0dWkuZ2V0RnVsbHNjcmVlbkFQSSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkRSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcblx0XHRcdGFwaSxcblx0XHRcdHRGID0gJ2Z1bGxzY3JlZW5jaGFuZ2UnO1xuXG5cdFx0aWYgKGRFLnJlcXVlc3RGdWxsc2NyZWVuKSB7XG5cdFx0XHRhcGkgPSB7XG5cdFx0XHRcdGVudGVySzogJ3JlcXVlc3RGdWxsc2NyZWVuJyxcblx0XHRcdFx0ZXhpdEs6ICdleGl0RnVsbHNjcmVlbicsXG5cdFx0XHRcdGVsZW1lbnRLOiAnZnVsbHNjcmVlbkVsZW1lbnQnLFxuXHRcdFx0XHRldmVudEs6IHRGXG5cdFx0XHR9O1xuXG5cdFx0fSBlbHNlIGlmKGRFLm1velJlcXVlc3RGdWxsU2NyZWVuICkge1xuXHRcdFx0YXBpID0ge1xuXHRcdFx0XHRlbnRlcks6ICdtb3pSZXF1ZXN0RnVsbFNjcmVlbicsXG5cdFx0XHRcdGV4aXRLOiAnbW96Q2FuY2VsRnVsbFNjcmVlbicsXG5cdFx0XHRcdGVsZW1lbnRLOiAnbW96RnVsbFNjcmVlbkVsZW1lbnQnLFxuXHRcdFx0XHRldmVudEs6ICdtb3onICsgdEZcblx0XHRcdH07XG5cblx0XHRcdFxuXG5cdFx0fSBlbHNlIGlmKGRFLndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKSB7XG5cdFx0XHRhcGkgPSB7XG5cdFx0XHRcdGVudGVySzogJ3dlYmtpdFJlcXVlc3RGdWxsc2NyZWVuJyxcblx0XHRcdFx0ZXhpdEs6ICd3ZWJraXRFeGl0RnVsbHNjcmVlbicsXG5cdFx0XHRcdGVsZW1lbnRLOiAnd2Via2l0RnVsbHNjcmVlbkVsZW1lbnQnLFxuXHRcdFx0XHRldmVudEs6ICd3ZWJraXQnICsgdEZcblx0XHRcdH07XG5cblx0XHR9IGVsc2UgaWYoZEUubXNSZXF1ZXN0RnVsbHNjcmVlbikge1xuXHRcdFx0YXBpID0ge1xuXHRcdFx0XHRlbnRlcks6ICdtc1JlcXVlc3RGdWxsc2NyZWVuJyxcblx0XHRcdFx0ZXhpdEs6ICdtc0V4aXRGdWxsc2NyZWVuJyxcblx0XHRcdFx0ZWxlbWVudEs6ICdtc0Z1bGxzY3JlZW5FbGVtZW50Jyxcblx0XHRcdFx0ZXZlbnRLOiAnTVNGdWxsc2NyZWVuQ2hhbmdlJ1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRpZihhcGkpIHtcblx0XHRcdGFwaS5lbnRlciA9IGZ1bmN0aW9uKCkgeyBcblx0XHRcdFx0Ly8gZGlzYWJsZSBjbG9zZS1vbi1zY3JvbGwgaW4gZnVsbHNjcmVlblxuXHRcdFx0XHRfaW5pdGFsQ2xvc2VPblNjcm9sbFZhbHVlID0gX29wdGlvbnMuY2xvc2VPblNjcm9sbDsgXG5cdFx0XHRcdF9vcHRpb25zLmNsb3NlT25TY3JvbGwgPSBmYWxzZTsgXG5cblx0XHRcdFx0aWYodGhpcy5lbnRlcksgPT09ICd3ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbicpIHtcblx0XHRcdFx0XHRwc3dwLnRlbXBsYXRlW3RoaXMuZW50ZXJLXSggRWxlbWVudC5BTExPV19LRVlCT0FSRF9JTlBVVCApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBwc3dwLnRlbXBsYXRlW3RoaXMuZW50ZXJLXSgpOyBcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGFwaS5leGl0ID0gZnVuY3Rpb24oKSB7IFxuXHRcdFx0XHRfb3B0aW9ucy5jbG9zZU9uU2Nyb2xsID0gX2luaXRhbENsb3NlT25TY3JvbGxWYWx1ZTtcblxuXHRcdFx0XHRyZXR1cm4gZG9jdW1lbnRbdGhpcy5leGl0S10oKTsgXG5cblx0XHRcdH07XG5cdFx0XHRhcGkuaXNGdWxsc2NyZWVuID0gZnVuY3Rpb24oKSB7IHJldHVybiBkb2N1bWVudFt0aGlzLmVsZW1lbnRLXTsgfTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYXBpO1xuXHR9O1xuXG5cblxufTtcbnJldHVybiBQaG90b1N3aXBlVUlfRGVmYXVsdDtcblxuXG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/photoswipe/src/js/ui/photoswipe-ui-default.js\n");

/***/ }),

/***/ 0:
/*!**********************************************************************!*\
  !*** multi photoswipe photoswipe/src/js/ui/photoswipe-ui-default.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! photoswipe */"./node_modules/photoswipe/dist/photoswipe.js");
module.exports = __webpack_require__(/*! photoswipe/src/js/ui/photoswipe-ui-default.js */"./node_modules/photoswipe/src/js/ui/photoswipe-ui-default.js");


/***/ })

/******/ });